{"epoch": "1", "task_id": "4", "completion": "#!/usr/bin/env python\\nfrom sys import stdin\\n\\nn = int(stdin.readline())\\nfor i in range(n):\\n\\tp = int(stdin.readline())\\n\\tx = p / (2**p)\\n\\tif x % 2 == 0:\\n\\t\\tprint \"2 4\"\\n\\telse:\\n\\t\\tprint p", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "1", "task_id": "5", "completion": "def is_enemy(x,y):\\n    return int(x) + int(y)\\n\\ndef is_enemy(x,y):\\n    return len(x) == len(y) + 1\\n\\n\\n\\nt = input()\\nfor _ in range(t):\\n    n = input()\\n    s = raw_input()\\n    d = raw_input()\\n    print is_enemy(s)\\n", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "1", "task_id": "6", "completion": "import math\\nn,m=map(int,raw_input().split())\\nq=input()\\n\\nfor i in range(q):\\n\\tx,v=map(int,raw_input().split())\\n\\tfor j in range(u,v+1):\\n\\t\\tif u==1 and v==1:\\n\\t\\t\\tprint 1\\n\\t\\t\\tbreak\\n\\telse:\\n\\t\\tprint 1", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "1", "task_id": "7", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n = int(stdin.readline())\\n    arr = map(int, stdin.readline().split())\\n    count = 0\\n    for i in range(n):\\n        if arr[i] % 2 == 1:\\n            count += 1\\n        else:\\n            count += 1\\n    print count", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "1", "task_id": "8", "completion": "from fractions import gcd\\nfrom fractions import gcd\\ndef main():\\n    t = input()\\n    for i in xrange(t):\\n        n = input()\\n        c = gcd(n, a)\\n        c = gcd(c, d)\\n        print '%d %d' % (c, d)\\n\\nmain()", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "1", "task_id": "9", "completion": "'''\\nCreated on Mon Jun 12.02.2014\\n\\n@author: sahr.ai\\n\\n@author: zukp\\n@author: halzk\\n\"\"\"\\n\\nfrom __future__ import division\\nfrom sys import stdin\\nfrom collections import defaultdict as ddic\\nfrom itertools import repeat\\nfrom bisect import bisect_left, bisect_right, bisect_right\\n\\nt = int(stdin.readline())\\nfor _ in range(t):\\n\\ts = stdin.readline()\\n\\ts = [0] * 26\\n\\tans = 0\\n\\t\\n\\tmax = 0\\n\\t\\n\\t\\n\\tfor i in range(2, 26):\\n\\t\\tif s[i] in max:\\n\\t\\t\\tans += 1\\n\\t\\telif s[i] in max:\\n\\t\\t\\tmax = i\\n\\treturn ans\\n\\n\\nfor _ in range(input()):\\n\\tS = [raw_input() for i in range(2)]\\n\\t\\n\\tprint ans", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "1", "task_id": "10", "completion": "from __future__ import division, print_function\\nfrom collections import Counter\\nfrom io import BytesIO\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nfrom itertools import repeat\\nfrom heapq import *\\nfrom collections import *\\nfrom itertools import repeat\\nimport copy\\nfrom collections import *\\nfrom itertools import repeat\\nimport heapq\\nfrom sys import stdin\\n\\nt=input()\\nfor i in range(t):\\n    n,k=map(int,stdin.readline().split())\\n    a=map(int,stdin.readline().split())\\n    ans=[0] * (n-k+1) + 1\\n    while n:\\n        n,k=n,n\\n        a.append(n)\\n    ans[n-k-1] = a[n]\\n    if n==1:\\n        a.sort()\\n    ans[0] = a[n-1] + 1\\n    ans[0] = a[n-1]\\n    print_function(a,k+1,k+1)\\n    print_function(a,k+1)", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "1", "task_id": "11", "completion": "t=input()\\nfor _ in range(t):\\n    n=input()\\n    s=raw_input()\\n    b=[]\\n    for i in range(n):\\n        a,b=raw_input().split()\\n        b.append(a)\\n        s=a[0]\\n        c=0\\n        for i in range(n):\\n            if(b[i]!=b[i+1]):\\n                s+=1\\n                b.append(a)\\n                b.append(a)\\n            c=c+1\\n        print len(s)\\nfor i in b:\\n    print i\\n", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "1", "task_id": "12", "completion": "n = input()\\nfor _ in range(n):\\n    n,m,k = map(int,raw_input().split())\\n    if k>=n or k<n or k>m:\\n        print \"YES\"\\n    else:\\n        print \"NO\"\\n", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "1", "task_id": "16", "completion": "t=input()\\nfor i in range(t):\\n    n=input()\\n    s=raw_input()\\n    i=0\\n    s=s.upper()\\n    l=len(s)\\n    a=0\\n    while a<l:\\n        if s[a]==s[i-1]:\\n            a+=1\\n            a=s[i-1]\\n            i+=1\\n    print a\\n", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "1", "task_id": "17", "completion": "t=int(raw_input())\\nfor _ in range(t):\\n    n=int(raw_input())\\n    p=0\\n    ans=0\\n    for _ in range(n):\\n        l=raw_input().split()\\n        for i in l:\\n            if int(i)>5:\\n                if i+1<=5:\\n                    ans+=1\\n                    p+=1\\n                break\\n        else:\\n            ans+=1\\n            break\\n        p+=1\\n    print ans\\n\\n", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "1", "task_id": "18", "completion": "t=input()\\nwhile t:\\n    t-=1\\n    n,k=map(int,raw_input().split())\\n    a=[]\\n    b=[]\\n    for i in range(k):\\n        x,y=map(int,raw_input().split())\\n        a.append(x)\\n        b.append(y)\\n    print max(a)", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "1", "task_id": "19", "completion": "t = input()\\nfor i in range(t):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    b = [a[i]-1]\\n    for j in range(n-1):\\n        if b[j]==a[j-1]:\\n            print 'YES'\\n            break\\n    if b[j]>0 and b[j+1]-b[j]<=0:\\n        print 'NO'\\n    else:\\n        print 'YES'", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "1", "task_id": "20", "completion": "import sys\\nfrom collections import Counter\\nfrom bisect import bisect_left\\n\\ndef main():\\n\\tn, k = map(int, raw_input().split())\\n\\tc = map(int, raw_input().split())\\n\\tl = sorted(set(c))\\n\\tprint l.count(1)\\n\\tprint''.join(map(str, l))\\n", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "1", "task_id": "21", "completion": "from math import ceil\\ndef solve(n):\\n    d = {}\\n    for x in xrange(n):\\n        d[x] = int(ceil(s / 10.0))\\n    for i in xrange(n):\\n        d[i] = int(ceil(s / 10.0))\\n    return d\\n\\ndef main():\\n    t, s = map(int, raw_input().split())\\n    for i in xrange(n):\\n        x, y, s = map(int, raw_input().split())\\n        s = min(x, x)\\n        s = min(x, y)\\n        s = min(x, y)\\n        s = min(x, y)\\n        s = max(s, s)\\n        s = s * 100000000\\n        s = 0\\n        s = 0\\n        for i in xrange(n):\\n            if s % 10 == 0:\\n                s += 1\\n                s += 1\\n            else:\\n                s = max(y, s)\\n    print s", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "1", "task_id": "24", "completion": "t = input()\\n\\nfor i in range(t):\\n    n = input()\\n    if n < 9:\\n        print 0\\n    else:\\n        for j in range(n-1):\\n            s = str(j)\\n            s = s - str(i)\\n            print s\\n", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "1", "task_id": "25", "completion": "import string\\nq = int(raw_input())\\nfor i in xrange(q):\\n    s = raw_input()\\n    t = raw_input()\\n    if s == t:\\n        print \"YES\"\\n    else:\\n        print \"NO\"\\n\\n", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "1", "task_id": "26", "completion": "def is_goals(a,b):\\n    return a == b\\ndef check(a,b):\\n    return not a % b\\ndef check(a,b):\\n    return not a % b\\ndef get_max_goals(x):\\n    return max(x, b)\\n\\nt = input()\\nwhile t > 0:\\n    a = input()\\n    a = a[::-1]\\n    if a==0:\\n        return False\\n    print check(a,b)", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "1", "task_id": "27", "completion": "from sys import stdin\\nfrom sys import stdin\\nfrom itertools import *\\nfrom collections import deque\\nfrom itertools import repeat\\nfrom collections import deque\\nfrom collections import deque\\nfrom operator import itemgetter\\n\\ninput = stdin.readline\\n\\n\\nR = lambda : stdin.readline().rstrip()\\nQ = lambda : map(int, input().split())\\nR_POS = lambda : stdin.readline().rstrip()\\n\\nR_POS = lambda : stdin.readline().rstrip()\\ndef is_ints(n):\\n    return len(n) == 0\\n\\ndef is_list(x, y):\\n    if y == x: return True\\n    return False\\n\\nfor _ in range(R_POS()):\\n    s, t = R()\\n    t = R()\\n    for i in range(len(t)):\\n        if len(s) == 0 and t[i] == t[i]: return False\\n    print 'YES'\\n    else:\\n        print 'NO'\\n", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "1", "task_id": "28", "completion": "t = input()\\nfor i in range(t):\\n\\tn, m = map(int, raw_input().split())\\n\\ta = map(int, raw_input().split())\\n\\tb = map(int, raw_input().split())\\n\\tprint \" \".join([str(i) for i in range(n)] + a[n - 1])\\n\\tprint \" \".join([str(i) for i in b])", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "1", "task_id": "33", "completion": "from sys import stdin\\n\\ndef gcd(a, b):\\n\\tans = 0\\n\\tfor i in range(a, b+1):\\n\\t\\tif i%2==0:\\n\\t\\t\\tans += 1\\n\\t\\telse:\\n\\t\\t\\tans += b\\n\\treturn ans\\n\\nfor i in range(input()):\\n\\tn = input()\\n\\tarr = map(int, stdin.readline().split())\\n\\tarr.sort()\\n\\tfor j in arr:\\n\\t\\tif j > 0:\\n\\t\\t\\tarr[j] += 1\\n\\t\\telse:\\n\\t\\t\\tarr[j] = 2\\n\\t\\telse:\\n\\t\\t\\tarr[j] = 1\\n\\tprint ans", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "1", "task_id": "34", "completion": "for _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    max=a[k]\\n    k-=1\\n    max=a[k-1]\\n    if k<1:\\n        if a[k]>max:\\n            max=a[k-1]\\n        else:\\n            max=a[k-1]-min\\n        else:\\n            max=a[k]-min\\n    print max", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "1", "task_id": "35", "completion": "t = input()\\nfor _ in range(t):\\n    n, m = map(int, raw_input().split())\\n    k = n % m\\n    print k", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "1", "task_id": "36", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nwhile t:\\n    t-=1\\n    n = int(stdin.readline())\\n    if n%2==0:\\n        print s[n/2:]\\n        break\\n    else:\\n        print s[0]\\n", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "1", "task_id": "38", "completion": "t = int(raw_input())\\nfor i in range(t):\\n    n = int(raw_input())\\n    if n % 4 == 0:\\n        print n/4\\n    else:\\n        print n/4", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "1", "task_id": "39", "completion": "import sys\\nfor t in range(input()):\\n    w,h = map(int,raw_input().split())\\n    x1,y1,x2,y2 = map(int,raw_input().split())\\n    x2,y2 = map(int,raw_input().split())\\n    w,h = map(int,raw_input().split())\\n    x1,y2,x1,y2 = map(int,raw_input().split())\\n    x1,y1 = x1,y1\\n    x2,y2 = x1,y2\\n    y2 = y1,x2\\n    y1 = x2\\n    y1 = y2\\n    x2,y2 = x2,y2\\n    x2 = x2\\n    y2 = y2\\n    y1 = y2\\n    x1 = x2\\n    y1 = x2\\n    y2 = y2\\n    x1 = y2\\n    y2 = y2\\n    y1 = y2\\n    x1 = x1 + x2\\n    x1 = x1\\n   ", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "1", "task_id": "40", "completion": "for _ in range(input()):\\n    m=input()\\n    for i in range(m):\\n        s=raw_input()\\n        s=s.split()\\n        m-=1\\n    print max(s)\\n", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "1", "task_id": "41", "completion": "n,m=map(int,raw_input().split())\\ns=raw_input()\\ns=s.split()\\nm=m-n\\nk=0\\nfor i in range(m):\\n    k+=input()\\n    s=s[i]\\n    k+=input()\\n    k+=input()\\n    print k\\n", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "1", "task_id": "44", "completion": "for i in range(input()):\\n    a,b=map(int,raw_input().split())\\n    if a==0 and b==0:\\n        print b\\n    else:\\n        print -1\\n", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "1", "task_id": "45", "completion": "def main():\\n    t = int(raw_input())\\n    for i in xrange(t):\\n        n = int(raw_input())\\n        a = map(int,raw_input().split())\\n        b = [0]*n\\n        for j in xrange(n):\\n            if b[j] == 1:\\n                if a[i] == 1:\\n                    b[j] = 0\\n                    else:\\n                    b[i] = 0\\n                    b[j] = 0\\n                        if b[j] == 1:\\n                    print -1\\n                    else:\\n                    print 0\\n                    break\\n        print 1\\n\\n\\nif __name__ == '__main__':\\n    main()\\n", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "1", "task_id": "46", "completion": "from fractions import gcd\\nn = int(raw_input())\\nc = map(int, raw_input().split())\\nb = c[0]\\nc[0] = c[1] + a\\nif len(c) % 2 == 0:\\n    print c[0] + 1\\nelse:\\n    print c[0] + 1\\n", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "1", "task_id": "52", "completion": "for _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    a.sort()\\n    s=(s/n)*2\\n    s=s/n\\n    print s", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "1", "task_id": "53", "completion": "t=int(input())\\nfor _ in range(t):\\n\\tn,k=map(int,raw_input().split())\\n\\tarr=map(int,raw_input().split())\\n\\tarr=sorted(arr)\\n\\tif k>=n:\\n\\t\\tprint 'NO'\\n\\telse:\\n\\t\\tprint 'YES'", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "1", "task_id": "54", "completion": "for i in range(input()):\\n\\tn,k=map(int,raw_input().split())\\n\\tif k>n:\\n\\t\\tprint n%10**9+7\\n\\telse:\\n\\t\\tprint n%10**9+7", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "1", "task_id": "60", "completion": "for _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    m=0\\n    for i in a:\\n        if i%2==0:\\n            m+=1\\n        else:\\n            m-=1\\n    print m", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "1", "task_id": "61", "completion": "for _ in range(input()):\\n\\tn=input()\\n\\ts=raw_input()\\n\\ta=s[0:n]\\n\\tb=s[n:n+1]\\n\\tif(a==b) or (a==b) or (a==b) or (a==c) or (a==r):\\n\\t\\tprint \"BRBR\"\\n\\t\\tbreak\\n\\telse:\\n\\t\\tprint \"BBRBR\"", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "1", "task_id": "62", "completion": "for i in range(input()):\\n    n = input()\\n    a = map(int,raw_input().split())\\n    a.sort()\\n    print \"-1\"\\n    for i in range(n):\\n        print a[i],\\n    print\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "1", "task_id": "66", "completion": "t=input()\\nwhile t>0:\\n\\tt-=1\\n\\tk=input()\\n\\tn=int(raw_input())\\n\\tk-=1\\n\\tk-=1\\n\\ts=k\\n\\twhile k>0:\\n\\t\\ts+=1\\n\\t\\tn-=1\\n\\tprint s\\n", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "1", "task_id": "67", "completion": "for _ in range(input()):\\n\\ta,b,c=map(int,raw_input().split())\\n\\tif a==b and c==c:\\n\\t\\tprint \"-1\"\\n\\telse:\\n\\t\\tprint c\\n\\t\\ta,b,c=b,a\\n\\tif a==b and a!=c:\\n\\t\\tprint a,b,c\\n\\telif c==c:\\n\\t\\tprint a,b\\n\\telif a%2==1 and a%2==2:\\n\\t\\tprint -1", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "1", "task_id": "68", "completion": "t = input()\\nfor i in range(t):\\n    k = input()\\n    for j in range(2,k+1):\\n        print j, j + 1\\n    print''.join([str(i) for i in range(1,k+1)])\\n", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "1", "task_id": "69", "completion": "t = input()\\nfor _ in xrange(t):\\n    n = input()\\n    if n == 1:\\n        print 0\\n    else:\\n        print (n-1)*2+n-1", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "1", "task_id": "70", "completion": "# your code goes here\\nfor t in xrange(input()):\\n    t = raw_input()\\n    if t in ['a','b','c','d']:\\n        print -1\\n    else:\\n        print t,\\n", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "1", "task_id": "71", "completion": "t = input()\\n\\nfor i in range(t):\\n\\tn,k = map(int,raw_input().split())\\n\\tif k == 1:\\n\\t\\tprint n\\n\\t\\tbreak\\n\\tif k > 2:\\n\\t\\tprint n\\n\\telse:\\n\\t\\tprint n", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "1", "task_id": "72", "completion": "for _ in range(input()):\\n    n,k = map(int,raw_input().split())\\n    ans = 0\\n    while n!= 1:\\n        if n % 10 == 0:\\n            ans += n / 10\\n        n /= 10\\n        n /= 10\\n    print ans", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "1", "task_id": "73", "completion": "for _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    if a[0]>a[1]:\\n        print 0\\n    else:\\n        print 0", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "1", "task_id": "74", "completion": "for _ in range(input()):\\n    a,b=map(int,raw_input().split())\\n    if a+b>0:\\n        print 0,\\n    elif a+b>0:\\n        print 1,\\n    else:\\n        print 2,\\n    else:\\n        print 3,\\n    print 2,\\n", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "1", "task_id": "75", "completion": "for _ in xrange(input()):\\n    n = input()\\n    k = sorted([map(int, raw_input().split()) for i in xrange(n)]])\\n    k.sort()\\n    i = 0\\n    j = 0\\n    while k:\\n        i += 1\\n        j += 1\\n    if k[j] > k[j]:\\n        j += 1\\n    print i", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "1", "task_id": "76", "completion": "#!/usr/bin/env python\\nimport sys\\n\\nn,m = [int(x) for x in sys.stdin.readline().split()]\\n\\nmod = 10**9 + 10\\n\\nres = 0\\nwhile n:\\n\\tres += m\\n\\tn -= m\\n\\tm -= 1\\n\\tn -= m\\n\\tres %= mod\\n\\nprint res\\n", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "1", "task_id": "77", "completion": "n,m = map(int,raw_input().split())\\nans = 0\\nwhile n:\\n    if m % 2 == 0:\\n        ans += m\\n    n %= m\\n    n /= 2\\n    m = m % 2\\nprint ans\\n", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "1", "task_id": "78", "completion": "t = input()\\nwhile t:\\n    t -= 1\\n    l,r = map(int,raw_input().split())\\n    if l % 2 == 0 and r % 2 == 0:\\n        print (r * r) % 2\\n    else:\\n        print 0", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "1", "task_id": "79", "completion": "#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\nfrom sys import stdin\\nt = int(stdin.readline())\\nfor i in xrange(t):\\n\\tk = int(stdin.readline())\\n\\tn = int(stdin.readline())\\n\\tif n%2:\\n\\t\\tprint n\\n\\telse:\\n\\t\\tprint n/2 + 1\\n\\t", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "1", "task_id": "80", "completion": "from sys import stdin\\nfrom itertools import repeat\\nimport math\\nfor _ in range(input()):\\n    n=input()\\n    a=stdin.readline()\\n    b=stdin.readline()\\n    b=b.split()\\n    a.sort()\\n    print a,b,a.index(a[0])\\n    print a.index(b[1])+1,a.index(a[2])+1,a.index(b[3]))\\n    print a.index(b[2])\\n    print a.index(b[1])+1,a.index(b[0])-1\\n    ", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "1", "task_id": "81", "completion": "from sys import stdin\\nfrom collections import Counter, defaultdict\\nfrom operator import mul\\nfrom itertools import permutations, combinations\\nfrom itertools import permutations, permutations\\nfrom itertools import permutations\\nfrom itertools import permutations, combinations, permutations, permutations, combinations\\nfrom itertools import combinations, combinations, permutations, combinations, combinations\\nfrom itertools import permutations, permutations, permutations, combinations\\nfrom fractions import gcd, combinations\\nfrom fractions import gcd\\nfrom bisect import bisect_right, bisect\\nfrom fractions import gcd\\nimport heapq\\nfrom bisect import bisect_left, bisect\\nfrom fractions import gcd\\nfrom math import factorial, pi, sqrt\\nfrom bisect import permutations, product, permutations, permutations, combinations\\nfrom collections import permutations\\nfrom random import permutations, combinations\\nfrom collections import permutations\\nfrom itertools import permutations\\nfrom collections import permutations\\nimport copy\\nfrom random import permutations\\nfrom fractions import Fraction, permutations, permutations, combinations, product, combinations\\nfrom itertools import combinations\\nfrom bisect import bisect_left, combinations, permutations\\nfrom heapq import bisect_right, bisect\\nfrom copy import *\\nfrom operator import factorial, permutations, bisect\\nfrom fractions import *\\nfrom copy import permutations\\nfrom bisect import permutations", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "1", "task_id": "84", "completion": "t=input()\\nwhile t:\\n    n,s=map(int,raw_input().split())\\n    n+=1\\n    s-=1\\n    if n%2==0 and s%2==0:\\n        print n-s\\n    else:\\n        print s-s", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "1", "task_id": "85", "completion": "t = input()\\nfor _ in range(t):\\n    a = raw_input()\\n    c = a.count('1')\\n    if c == 0:\\n        print 0\\n    else:\\n        print 2\\n\\n", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "1", "task_id": "86", "completion": "from sys import stdin, stdout\\nfrom itertools import repeat\\nfrom collections import deque\\n\\ndef main():\\n    t = int(stdin.readline())\\n    for i in xrange(t):\\n        n = int(stdin.readline())\\n        b = [False] * n\\n        for j in xrange(n):\\n            b.append(stdin.readline())\\n        for i in xrange(n):\\n            b[i] = True\\n        b = [False] * n\\n        for j in xrange(n):\\n            b[j] = False\\n            b[i] = True\\n        for k in xrange(n):\\n            b[k] = False\\n            b[k] = False\\n        for k in xrange(n):\\n            b[k] = False\\n        for k in xrange(n):\\n                b[k] = True\\n\\n    for i in xrange(n):\\n        for j in xrange(n):\\n            b[i][j] = True\\n\\n\\nfor _ in xrange(t):\\n    n = int(stdin.readline())\\n    for j in xrange(n):\\n        a =", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "1", "task_id": "87", "completion": "for _ in range(input()):\\n    n,m=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    print sum(a)-min(a)", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "1", "task_id": "88", "completion": "t=input()\\nfor i in range(t):\\n    n,m=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    a.sort()\\n    b=[0]*n\\n    b[0]=0\\n    for j in range(n):\\n        b[j]=a[j-1]+1\\n        b[j]=b[i-1]+1\\n        c[i-1]+=1\\n    for j in range(m):\\n        c[j]=c[j]\\n    print min(c)\\n    t=t-1", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "1", "task_id": "93", "completion": "import sys\\nfor _ in range(int(sys.stdin.readline())):\\n    a,b=map(int,sys.stdin.readline().split())\\n    if b<0:\\n        print 2\\n    else:\\n        print 2\\n    if a==0 and b==0:\\n        print 2\\n    else:\\n        print 3", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "1", "task_id": "94", "completion": "t = int(raw_input())\\nwhile t:\\n    t-=1\\n    n=input()\\n    print n*(n-1)+1\\n", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "1", "task_id": "95", "completion": "for _ in range(input()):\\n\\ts,n=map(int,raw_input().split())\\n\\ta=0\\n\\tfor i in range(0,n):\\n\\t\\ta+=i\\n\\tif n<=s:\\n\\t\\tprint s,\\n\\telse:\\n\\t\\tprint s,\\n\\tprint", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "1", "task_id": "98", "completion": "import sys\\nfrom bisect import bisect_left\\nfor _ in range(input()):\\n    n = input()\\n    s = raw_input()\\n    s1 = s[0]\\n    s2 = s[1:]\\n    s2 = s[1:]\\n    if len(s2) == n and s2[0] == s1[0]:\\n        print -1\\n    else:\\n        print 1, -1\\n        return\\n\\n    #print s2\\n    for i in xrange(1, n):\\n        s1 = s1[i]\\n        s2 = s2[i]\\n        s2 = s2[i]\\n        s2 = s1[i]\\n        if s2[i]!= s1[i]:\\n            s2[i] = s2[i+1]\\n            s2[i+1] = s2[i+1] + 1\\n        else:\\n            s2[i] = s2[i]\\n\\n    #print s2\\n    n = input()\\n    s = s2[0]\\n    if n == 1:\\n       ", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "1", "task_id": "99", "completion": "from math import factorial\\nfor _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    if s[0]=='=':\\n        print(\"YES\")\\n    else:\\n        print(\"NO\")\\n    print(\"YES\")\\n", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "1", "task_id": "100", "completion": "import math\\nimport sys\\n\\ndef test():\\n    return sys.stdin.readline().strip()\\n\\nt = input()\\nfor i in range(t):\\n    n = input()\\n    a = [int(i) for i in raw_input().split()]\\n    a.sort()\\n    if a[n - 1]!= a[n]:\\n        print a[n - 1] % 998244350\\n    else:\\n        print a[n - 1] % 998244350", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "1", "task_id": "101", "completion": "from sys import stdin\\nfrom collections import defaultdict\\ndef solve(s):\\n    return s\\n\\nfor i in range(input()):\\n    n, m, k = map(int, stdin.readline().split())\\n    X = map(int, stdin.readline().split())\\n    Y = map(int, stdin.readline().split())\\n    A = [0 for _ in xrange(m)]\\n    K = map(int, stdin.readline().split())\\n    Y = [0 for _ in xrange(m)]\\n    A[X[0]] = 0\\n    B[Y[0]] = 0\\n    for x in B[x]:\\n        b = y\\n        if x>a:\\n            B[x] = b\\n        elif y>a:\\n            B[x] = b\\n        else:\\n            B[y] = a\\n        elif x-a[y] > a:\\n            A[x] = a\\n            y += b\\n    print A[0]\\n", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "1", "task_id": "109", "completion": "for _ in range(input()):\\n    n = input()\\n    s = raw_input()\\n    s1 = s.split(\"0\")[0]\\n    s2 = s.split(\"1\")[1]\\n    s3 = s.split(\"0\")[0]\\n    c = s.split(\"1\")[0]\\n    d = d.split(\"0\")[0]\\n    d1 = int(d[0])[1]\\n    d2 = int(d[1])[0]\\n    d3 = int(d[2])[0]\\n    d3 = int(d[3])[1]\\n    d3 = int(d[3])[1]\\n    d4 = int(d[3])[1]\\n    d3 = int(d[3])[1]\\n    d3 = int(d[3])[1]\\n    d4 = int(d[3])[1]\\n    d4 = int(d[3])[2]\\n    d4 = int(d[3])[2]\\n    d3 = int(d[3", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "1", "task_id": "110", "completion": "#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\nimport sys\\n\\ndef main():\\n    testcases = int(sys.stdin.readline())\\n    for _ in range(testcases):\\n        n = int(sys.stdin.readline())\\n        k = [int(x) for x in sys.stdin.readline().split()]\\n        count = 0\\n        for i in range(n):\\n            count += k[i]\\n            count += k[i]\\n\\n        if count >= n:\\n            print -1\\n        else:\\n            print count\\n", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "1", "task_id": "111", "completion": "for _ in range(input()):\\n    n=input()\\n    if n%2==0:\\n        print \"(\"\\n    else:\\n        print \")\"\\n    ", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "1", "task_id": "112", "completion": "from collections import Counter\\nfor _ in range(input()):\\n    a,b,c,m=map(int,raw_input().split())\\n    if b==c and c>m:\\n        print 'YES'\\n    else:\\n        print 'NO'\\n", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "1", "task_id": "113", "completion": "n=int(raw_input())\\nm=int(raw_input())\\na=list(map(int,raw_input().split()))\\na.sort()\\nm=int(raw_input())\\nm=m-1\\nfor i in range(m):\\n    x,y=raw_input().split()\\n    a.sort()\\n    m-=1\\n    a.append(y)\\ncount=0\\nfor i in range(m):\\n    x+=1\\n    if a[i]==x and a[i]==y:\\n        count+=1\\nprint count", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "1", "task_id": "114", "completion": "n = input()\\na = []\\nb = []\\nfor i in range(n):\\n    c = [0]\\n    b.append(raw_input().split())\\n    a.append(c[0])\\n    b.append(c[1])\\nfor i in range(n):\\n    a.append(raw_input().split())\\nb.sort()\\nm = input()\\nfor i in range(m):\\n    print i,\\n    b[0]", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "2", "task_id": "4", "completion": "import sys\\n\\ndef is_prime(p):\\n\\tif p%2 == 0:\\n\\t\\treturn False\\n\\telse:\\n\\t\\treturn True\\n\\ndef gcd(a, b):\\n\\tif b == 0:\\n\\t\\treturn a\\n\\treturn gcd(b, a%b)\\n\\ndef gcd(a, b):\\n\\tif a == 0:\\n\\t\\treturn b\\n\\telse:\\n\\t\\treturn gcd(b, a%b)\\n\\ndef lcm(a, b):\\n\\tif b == 0:\\n\\t\\treturn b\\n\\tif b == 0:\\n\\t\\treturn b\\n\\telse:\\n\\t\\treturn gcd(b, a%b)\\n\\nt=int(raw_input())\\nfor _ in range(t):\\n\\tp=int(raw_input())\\n\\tp=int(raw_input())\\n\\ta=ncm(p)\\n\\tb=ncm(p)\\n\\tprint a,b\\n\\tprint b,a", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "2", "task_id": "5", "completion": "for t in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    s1 = raw_input()\\n    s2 = raw_input()\\n    cnt = 0\\n    s1 = s1[::-1]\\n    s2 = s2[::-1]\\n    if s1!= s2[::-1]:\\n        cnt += 1\\n    else:\\n        s1 = s1[::-1]\\n    s2 = s2[::-1]\\n    print cnt", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "2", "task_id": "6", "completion": "n, m = map(int, raw_input().split())\\n\\ndef power(n):\\n    for i in range(1, n+1):\\n        if i == 0:\\n            return 0\\n    return (n - i) % n\\n\\n\\nn = int(raw_input())\\nm = int(raw_input())\\n\\nfor _ in xrange(m):\\n    u, v = map(int, raw_input().split())\\n    u, v = map(int, raw_input().split())\\n    power = [0] * (n+1)\\n    power[u] = power[v] + 1\\n\\n    if power[v] < power[u]:\\n        power[u] = power[v] + 1\\n    if power[u] < power[v]:\\n        power[u] = power[v] + 1\\n    else:\\n        power[u] = power[u]\\n\\nq = int(raw_input())\\n\\nq = int(raw_input())\\n\\nfor _ in xrange(q):\\n    u, v = map(int, raw_input().split())\\n", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "2", "task_id": "7", "completion": "for i in range(input()):\\n    n = input()\\n    a = map(int,raw_input().split())\\n    a.sort()\\n    a.reverse()\\n    cnt = [0]*n\\n    for i in a:\\n        cnt[i%2] = cnt[i%2] + 1\\n    ans = 0\\n    for j in range(n):\\n        if (a[j]%j == 1):\\n            ans = max(ans, cnt[j-1])\\n        if (a[j]%j == 0):\\n            ans = max(ans, cnt[j-1])\\n    print ans", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "2", "task_id": "8", "completion": "t = input()\\nfor _ in xrange(t):\\n    n = input()\\n    print n%2, n/2\\n    print 1, n/2", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "2", "task_id": "9", "completion": "from collections import Counter\\n\\nfor _ in range(input()):\\n    s = raw_input()\\n    c = Counter(s)\\n    r = min(len(s), len(c))\\n    print r + r", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "2", "task_id": "10", "completion": "for _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    a.sort()\\n    c=0\\n    for i in range(1,n):\\n        if i%k==0:\\n            a[i]=c+1\\n    a=sorted(a,key=lambda x:x[1])\\n    print \" \".join(map(str,a))", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "2", "task_id": "11", "completion": "t = int(raw_input())\\nfor _ in xrange(t):\\n\\tn = int(raw_input())\\n\\twords = []\\n\\tfor i in xrange(n):\\n\\t\\twords.append(raw_input())\\n\\n\\t\\n\\tl = []\\n\\tfor i in xrange(n):\\n\\t\\tl.append(list(raw_input()))\\n\\n\\t\\n\\tans = 0\\n\\tfor i in xrange(n):\\n\\t\\tfor j in xrange(n):\\n\\t\\t\\tif words[i][j] not in l:\\n\\t\\t\\t\\tans += 1\\n\\t\\t\\tl.append(words[j])\\n\\t\\n\\tfor i in ans:\\n\\t\\tif len(i) == 2:\\n\\t\\t\\tprint i\\n\\t\\t\\tcontinue\\n\\t\\tif i[-1] not in l:\\n\\t\\t\\tprint i\\n\\n\\n\\n", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "2", "task_id": "12", "completion": "for _ in range(input()):\\n    n,m,k=map(int,raw_input().split())\\n    if k>n or k>=m:\\n        print \"YES\"\\n    else:\\n        print \"NO\"", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "2", "task_id": "16", "completion": "for _ in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    s = raw_input()\\n    l = len(s)\\n    l1 = len(s)\\n    l2 = len(s)\\n    if l1 > l2:\\n        print(l1-l2)\\n    else:\\n        print(0)\\n\\n", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "2", "task_id": "17", "completion": "for _ in range(input()):\\n    n = input()\\n    a = []\\n    for i in range(n):\\n        a.append(map(int,raw_input().split()))\\n    b = [0] * (n+1)\\n    for i in range(n):\\n        for j in range(n):\\n            b[i][j] = a[i][j-1] + 1\\n    for i in range(n):\\n        for j in range(n):\\n            if b[i][j] == b[i]:\\n                b[i][j] = 0\\n    for i in range(n):\\n        for j in range(n):\\n            if b[i][j] == b[i]:\\n                b[i][j] = b[i] + 1\\n\\n    if len(b) < 4:\\n        print -1\\n    else:\\n        print -1\\n", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "2", "task_id": "18", "completion": "for _ in xrange(input()):\\n    n, k = map(int, raw_input().split())\\n    l = []\\n    for _ in xrange(k):\\n        x, y = map(int, raw_input().split())\\n        l.append((x,y))\\n    p = []\\n    p.sort(reverse=True)\\n    for i in xrange(k):\\n        if p[2*i+1] == p[i]:\\n            p.pop(0)\\n        p.pop(0)\\n    return p\\n\\n\\n    for i in xrange(k):\\n        p.append((x,y))\\n\\n    ans = 0\\n    for i in xrange(k):\\n        if i!= 0:\\n            ans += (i[1] - i[0]) * (i[0] - i[1])\\n    print ans\\n", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "2", "task_id": "19", "completion": "import sys\\nfrom collections import Counter\\n\\nt = int(sys.stdin.readline())\\nfor _ in range(t):\\n\\tn = int(sys.stdin.readline())\\n\\ta = map(int, sys.stdin.readline().split())\\n\\tans = 'NO'\\n\\tfor x in a:\\n\\t\\tans = 'YES' if x%n==0 else 'NO'\\n\\tprint ans", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "2", "task_id": "20", "completion": "from collections import defaultdict\\nn, k = map(int, raw_input().split())\\nc = map(int, raw_input().split())\\n\\na = defaultdict(list)\\n\\nfor i in range(k):\\n    c[i] = 1\\n\\nfor i in range(n):\\n    for j in range(n):\\n        a[i] = c[i] - 1\\n\\nk = sorted(sorted(c))\\nc[0] = 1\\n\\nfor i in range(k):\\n    for j in range(k):\\n        if c[i] == 0:\\n            print i, j\\n            break\\n    print", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "2", "task_id": "21", "completion": "import sys\\n\\nimport math\\n\\ndef main():\\n    n = int(sys.stdin.readline())\\n    a = [map(int, sys.stdin.readline().split()) for _ in xrange(n)]\\n    # a[i] = [i[0],i[1]]\\n    for i in xrange(n):\\n        x,y,s = [i[0],i[1],i[2]\\n        if (x == 0):\\n            ans = abs(x - y)\\n            if s == 1:\\n                ans = abs(x - y) + s\\n            if x == 0:\\n                ans = 0\\n                a[i] = 0\\n            if y == 0:\\n                ans = -1\\n                a[i] = 0\\n            a[i] = 1\\n            else:\\n                ans = abs(y - y) + s\\n                a[i] = (ans + (a[i] - x) % 998244353)\\n\\n\\n    for i in xrange(n):\\n        x,y,s = [int(i) for i in sys.stdin", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "2", "task_id": "24", "completion": "#!/usr/bin/env python\\nimport sys\\nimport time\\nimport time\\nimport itertools\\n\\ndef my_func():\\n    t = int(sys.stdin.readline())\\n    for i in range(t):\\n        n = int(sys.stdin.readline())\\n        print len(set(str(sum(map(int, str(sum(str(i))))))", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "2", "task_id": "25", "completion": "import sys\\nfrom collections import defaultdict\\nimport copy\\nfrom math import ceil\\nfrom bisect import bisect_left, bisect_right\\nfrom collections import deque\\nimport itertools as it\\nimport math\\nfrom bisect import bisect_left\\nimport itertools as it\\nimport operator\\nimport copy\\nimport math\\nimport heapq\\n\\n\\n\\ndef ia():\\n    return int(raw_input())\\n\\n\\ndef ia2():\\n    line = raw_input()\\n    return map(int, line.split())\\n\\n\\ndef ia():\\n    return map(int, line.split())\\n\\n\\ndef ia2():\\n    return map(int, line.split())\\n\\n\\nq = ia()\\nfor _ in xrange(q):\\n    s = ia()\\n    t = ia()\\n    s_pos = []\\n    t_pos.append(s)\\n    t_pos.append(t)\\n    s_pos.append(t)\\n    t_pos.append(t)\\n    ans = 'YES'\\n    if len(s_pos) == 1:\\n        if len(s_pos) == 1:\\n            ans = 'NO'\\n", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "2", "task_id": "26", "completion": "\\ndef solve(s):\\n    min = 0\\n    count = 0\\n    for x in s:\\n        if x == '?':\\n            min += 1\\n        else:\\n            count += 1\\n        if count > 10:\\n            min = count\\n            count = 0\\n        if count > 10:\\n            min = count\\n        if count > 10:\\n            min = count\\n            count -= 10\\n    return min\\n\\n\\n\\ndef main():\\n    t = int(raw_input())\\n    for _ in range(t):\\n        s = raw_input()\\n        s = s.split(\"?\")\\n        n = int(n)\\n        res = solve(s)\\n        n -= 1\\n        for i in range(n):\\n            res -= solve(s)\\n        print res", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "2", "task_id": "27", "completion": "for _ in xrange(input()):\\n    s = raw_input()\\n    t = raw_input()\\n    count = 0\\n    while s[count] == t[count]:\\n        if s[count] == t[count - 1]:\\n            count += 1\\n        else:\\n            count -= 1\\n        s[count] = t[count - 1]\\n    print \"YES\" if count > 0 else \"NO\"", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "2", "task_id": "28", "completion": "from sys import stdin\\n\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n,m = map(int,stdin.readline().split())\\n    p = map(int,stdin.readline().split())\\n    p = [0 for _ in xrange(n)]\\n    p.sort(key=lambda x:x[1])\\n\\n    for i in xrange(n-1):\\n        if p[i-1] == i+1:\\n            p[i-1] = i-1\\n            if p[i-1] > i:\\n                p[i-1] = p[i-1]\\n            p[i-1] = p[i-1]\\n\\n\\n    #print p\\n    k = 0\\n    #for i in xrange(n-1):\\n        k += p[i][i]\\n        k += p[i][i]\\n        k += p[i][i+1]\\n\\n    print k\\n    if k >= m:\\n        print k,\\n    else:\\n        print 0,\\n    for i in xrange(n-", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "2", "task_id": "33", "completion": "t=input()\\nfor _ in range(t):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    l=sorted(a)\\n    s=l[-1]\\n    r=0\\n    while l:\\n        a.remove(l)\\n        if r>n:\\n            l=r\\n        else:\\n            r=r-n\\n    print max(l,r)\\n", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "2", "task_id": "34", "completion": "import math\\n\\n\\nfor _ in range(int(raw_input())):\\n    n, k = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n    a.sort()\\n    if k == 1:\\n        k -= 1\\n    ans = 0\\n    for i in range(n):\\n        ans = max(ans, a[i] - a[i - k])\\n    print ans\\n", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "2", "task_id": "35", "completion": "t = int(raw_input())\\n\\nfor i in xrange(t):\\n\\tn,m = map(int, raw_input().split())\\n\\tn,m = m,n\\n\\tif n == 0:\\n\\t\\tprint 0\\n\\telse:\\n\\t\\tif m == 0:\\n\\t\\t\\tprint n\\n\\t\\telif m == 0:\\n\\t\\t\\tprint n\\n\\t\\telif m == 0:\\n\\t\\t\\tprint m\\n\\t\\telse:\\n\\t\\t\\tprint m", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "2", "task_id": "36", "completion": "def find_even(s):\\n    if s == s[-1]:\\n        return 'a'\\n    elif s == s[0]:\\n        return 'a'\\n    else:\\n        return s\\n\\ndef solve(n):\\n    result = ''\\n    for i in range(1, n+1):\\n        result += find_even(s[:i])\\n        if result % 2 == 0:\\n            return result\\n    return ''.join(result)\\n\\n\\nt = int(raw_input())\\nfor i in xrange(t):\\n    n = int(raw_input())\\n    print solve(n)\\n", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "2", "task_id": "38", "completion": "from collections import defaultdict\\n\\ndef main():\\n    n = int(raw_input())\\n    for i in range(n):\\n        print int(raw_input())\\n\\nmain()\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "2", "task_id": "39", "completion": "import math\\n\\n\\ndef solve(W,H,x1,y1,x2,y2):\\n    return -1 if w > h else min(x2-x1,h-y1)\\n\\n\\n\\n\\nfor _ in range(int(raw_input())):\\n    w,h = map(int,raw_input().split())\\n    x1,y1 = map(int,raw_input().split())\\n    w,h = map(int,raw_input().split())\\n    w1 = W - w\\n    y1 = H-h\\n    y2 = H-h\\n\\n    if w <= h:\\n        return -1\\n\\n    d = [x2 - x1,y2]\\n    if d[d[d[d[d[d[d]]]] == 0:\\n        d = [x2 - x1,y2]\\n    elif d[d[d[d[d[d[d[d]]]] == 0]:\\n        d = [x2 - x1,x2]][0]\\n    elif d[d[d[d[d", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "2", "task_id": "40", "completion": "for t in range(int(raw_input())):\\n    m = int(raw_input())\\n    arr = [[] for i in range(2)]\\n    for i in range(1,m+1):\\n        arr[i] = map(int, raw_input().split())\\n    ans = 0\\n    for i in range(1,m+1):\\n        for j in range(m):\\n            arr[i][j] = map(int, raw_input().split())\\n        ans += max(arr[i-1][j-1]+1,arr[i-1][j-1]+1)\\n\\n    print ans", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "2", "task_id": "41", "completion": "n,m=map(int,raw_input().split())\\ns=raw_input()\\nfor i in range(m):\\n    l,r=map(int,raw_input().split())\\n    if l==r:\\n        print (0)\\n    else:\\n        ans=1\\n        for j in range(l,r+1):\\n            if s[j]!=s[j+1]:\\n                ans=ans+1\\n            elif s[j]!=s[j+1]:\\n                ans=ans+1\\n            elif s[j]!=s[j+1]:\\n                ans=ans+1\\n        print ans\\n", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "2", "task_id": "44", "completion": "def main():\\n    t = int(raw_input())\\n    for i in range(t):\\n        n, m = raw_input().split()\\n        c, d = int(n), int(m)\\n        c -= 1\\n        d -= 1\\n        ans = -1\\n        if c == d:\\n            ans = 1\\n            break\\n        elif d == c:\\n            ans = 0\\n            break\\n        elif c == d:\\n            ans += 1\\n            break\\n        else:\\n            ans += 1\\n            b -= 1\\n        if c == d:\\n            ans += 1\\n            break\\n        else:\\n            ans += 1\\n    print ans\\n   \\nmain()", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "2", "task_id": "45", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nfrom itertools import permutations, combinations\\nimport math\\nimport bisect\\nfrom collections import deque\\nimport copy\\nimport bisect\\n\\nsys.setrecursionlimit(1000000)\\n\\nINF = 10 ** 18\\nMOD = 10 ** 18\\nMOD = 10 ** 18 + 7\\n\\nT = int(stdin.readline())\\nfor _ in xrange(T):\\n    n = int(stdin.readline())\\n    a = [int(x) for x in stdin.readline().split()]\\n    c = Counter(a)\\n    if c[0] > c[1]:\\n        c[0] -= c[1]\\n    print c[1] - c[2]", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "2", "task_id": "46", "completion": "n = int(raw_input())\\nc = map(int, raw_input().split())\\nc.sort()\\nr = 0\\nc = 0\\ns = 0\\nfor i in range(n):\\n    c += c[i]\\n    s += c[i]\\n    if i % 2 == 0:\\n        r += 1\\n    else:\\n        s += c[i]\\nprint r", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "2", "task_id": "52", "completion": "for _ in xrange(input()):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    s = sum(a)\\n    print(s)", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "2", "task_id": "53", "completion": "from sys import stdin\\n\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n, k = map(int, stdin.readline().split())\\n    a = map(int, stdin.readline().split())\\n    if sum(a) <= k:\\n        print 'YES'\\n    else:\\n        print 'NO'", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "2", "task_id": "54", "completion": "t = input()\\nfor i in range(t):\\n    n,k = map(int, raw_input().split())\\n    ans = 1\\n    for i in range(1, k+1):\\n        ans = ans * i\\n        if i < n-k:\\n            ans *= 2\\n            ans %= (10**9+7)\\n    print ans", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "2", "task_id": "60", "completion": "from collections import Counter\\nfrom collections import deque\\n\\n\\ndef main():\\n    t = int(raw_input())\\n    for _ in xrange(t):\\n        n = int(raw_input())\\n        a = [int(x) for x in raw_input().split(' ')]\\n        a.sort()\\n        ans = 1\\n        while a[a.index(a[a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(a.index(", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "2", "task_id": "61", "completion": "for _ in xrange(input()):\\n    n = input()\\n    s = raw_input()\\n    s = list(s)\\n    if 'B' not in s:\\n        print 'BR'\\n        for i in xrange(n):\\n            if s[i] == '?':\\n                s[i] = 'B'\\n                for j in xrange(n):\\n                    s[j] = s[j] + 'R'\\n        else:\\n            if s[i] == '?':\\n                s[j] = 'B'\\n            else:\\n                s[j] = 'R'\\n            else:\\n                s[i] = 'B'\\n    print s[n - 1]\\n", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "2", "task_id": "62", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\n\\ndef read():\\n    return int(input())\\n\\ndef read_ints():\\n    return [int(x) for x in sys.stdin.readline().split()]\\n\\ndef read_int_list():\\n    return [int(x) for x in sys.stdin.readline().split()]\\n\\ndef read_int_list():\\n    return [int(x) for x in sys.stdin.readline().split()]\\n\\ndef read_ints():\\n    return [int(x) for x in sys.stdin.readline().split()]\\n\\ndef read_ints():\\n    return [sys.stdin.readline().split() for i in range(input())]\\n\\ndef write():\\n    for i in range(input()):\\n        if read_ints():\\n            sys.stdout.write(read_ints())\\n\\n\\ndef read_int():\\n    return [int(x) for x in sys.stdin.readline().split()]\\n\\ndef get_arr():\\n    return [int(x) for x in sys.stdin.", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "2", "task_id": "66", "completion": "\\nfor t in range(input()):\\n    k = input()\\n    for i in range(1, 1001):\\n        for j in range(1,1001):\\n            if int(str(i))%3 == 0:\\n                print j\\n                break\\n\\n", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "2", "task_id": "67", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\n\\nt = int(input())\\nfor _ in range(t):\\n\\ta,b,c = [int(x) for x in input().split()]\\n\\tprint abs(a-b) if b%c==0 else (-1 if b%c==0 else (a-b/c-c) % c)\\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "2", "task_id": "68", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    r = 1\\n    for i in range(n):\\n        print i*2+i,(k-i)/2\\n    print r,(k-i)/2\\n\\n", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "2", "task_id": "69", "completion": "t=input()\\nfor _ in xrange(t):\\n    n=input()\\n    ans=0\\n    for i in xrange(1,1052+1):\\n        if n%i==0:\\n            ans+=1\\n        else:\\n            n/=i\\n        if n%2==0:\\n            n/=2\\n        ans+=1\\n    print ans", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "2", "task_id": "70", "completion": "for _ in xrange(int(raw_input())):\\n    s = list(raw_input())\\n    if s.count(s[0]) > len(s) - 1:\\n        print -1\\n        continue\\n    s[0] = s[0]\\n    for i in xrange(1, len(s)-1):\\n        if s[i] == s[i+1]:\\n            s[i] = s[i+1] + s[i]\\n            if s[i] == s[i+1]:\\n                print -1\\n                continue\\n            if s[i]!= s[i+1]:\\n                print -1\\n                continue\\n            print s[i], s[i]\\n        else:\\n            if s[i] == s[i+1]:\\n                print -1\\n                continue\\n            print -1\\n            continue\\n            for i in xrange(0, len(s)):\\n                if s[i]!= s[i]:\\n                    s[i] = s[i]\\n                    s[i] = s[i]\\n                break\\n            elif s[i", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "2", "task_id": "71", "completion": "import math\\nfor _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    s=n%k\\n    s=s%k\\n    ans=int(math.ceil(s*k))\\n    if ans<k:\\n        print n\\n    else:\\n        if n==n:\\n            s=s\\n        if k>1:\\n            ans=n/k\\n        if n>k:\\n            ans=n%k\\n            ans=n%k\\n    print ans\\n", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "2", "task_id": "72", "completion": "import sys\\n\\nt = int(sys.stdin.readline())\\n\\nfor t in range(t):\\n    n, k = map(int, sys.stdin.readline().split())\\n    if n < k:\\n        print '0'\\n        sys.exit(0)\\n    else:\\n        ans = n\\n        while (n >= k):\\n            n -= k\\n            ans += n % k\\n            ans += 1\\n        print ans\\n\\n", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "2", "task_id": "73", "completion": "def f(l):\\n    t = len(l)\\n    while l > 0:\\n        if l % 2 == 0:\\n            t -= 1\\n            l /= 2\\n        else:\\n            t -= 1\\n    return t\\n\\n\\nfor _ in range(input()):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    l.sort()\\n    b = [0]*n\\n    ans = 0\\n    for i in range(n-1):\\n        if l[i] == a[i+1]:\\n            ans += 1\\n            b[i] = b[i] + 1\\n            b[i+1] = b[i] + 1\\n            b[i] = b[i+1] + 1\\n            b[i] = b[i] + 1\\n    print ans\\n", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "2", "task_id": "74", "completion": "def main():\\n    t = int(raw_input())\\n    for _ in xrange(t):\\n        a, b = map(int, raw_input().split())\\n        print len(set(a))\\n        print a - b,\\n        print\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "2", "task_id": "75", "completion": "T=int(raw_input())\\nfor _ in xrange(T):\\n    n=int(raw_input())\\n    caves=[]\\n    for i in xrange(n):\\n        k=int(raw_input())\\n        caves.append(k)\\n    cnt=0\\n    for i in xrange(n):\\n        caves.append(map(int,raw_input().split()))\\n    caves.sort(key=lambda x:x[0])\\n    cnt+=cnt\\n    print(cnt)\\n    print(cnt)", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "2", "task_id": "76", "completion": "n, m = map(int, raw_input().split())\\n\\ndef f(n):\\n    if n == 1 or n == 2:\\n        return 1\\n    else:\\n        return f(n - 1)\\n\\ndef mod(n, m):\\n    if m == 1:\\n        return 1\\n    elif n == 2:\\n        return 2\\n    else:\\n        return 2\\n\\ndef ncr(n, m):\\n    return mod(2, n - 1) % mod\\n\\nif n == 1:\\n    return mod(n - 1, m)\\n\\nif n == 2:\\n    if n == 3:\\n        if m < 1:\\n            return 1\\n\\n    if n > 4:\\n        if n > 5:\\n            return 1\\n\\n    elif n == 5:\\n        if n > 5:\\n            return 2\\n    elif n == 5:\\n        return 2\\n\\n    if n == 5:\\n        if n == 4:\\n            return 0\\n        else:\\n            return 2\\n        return 2\\n    else:\\n        if n == 4:\\n            return 1\\n        else:\\n", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "2", "task_id": "77", "completion": "n,m=map(int,raw_input().split())\\nn-=1\\nprint (pow(2,n,m),m)%1000000001\\n", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "2", "task_id": "78", "completion": "from math import *\\nt = int(raw_input())\\n\\nwhile t > 0:\\n\\tt-=1\\n\\t\\n\\ta,b = map(int, raw_input().split())\\n\\t\\n\\ta,b = 0,a\\n\\t\\n\\twhile a>0 and b > 0:\\n\\t\\ta,b = b,a%b\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tprint a\\n\\t\\n\\n\\n", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "2", "task_id": "79", "completion": "def isPrime(x):\\n    if x%2:\\n        return 0\\n    for i in xrange(1,x/2+1):\\n        if x%i==0:\\n            return 0\\n    return 1\\n\\nfor i in xrange(input()):\\n    k=input()\\n    n=input()\\n    if k==1:\\n        print 1\\n        print n\\n        print n\\n    print n,\\n    print", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "2", "task_id": "80", "completion": "from collections import Counter\\nfor _ in range(input()):\\n    n=input()\\n    a=raw_input()\\n    b=raw_input()\\n    c=Counter(a)\\n    c1=Counter(b)\\n    c2=Counter(c)\\n    for i in range(1,len(a)):\\n        if a[i]=='1':\\n            c1[i-1]=1\\n        if a[i]=='1':\\n            c1[i]=1\\n        if a[i]=='1':\\n            c2[i]=1\\n            if a[i]=='1':\\n                c2[i]=1\\n            elif a[i]=='1':\\n                c2[i]=1\\n        c2[i]=1\\n    for i in range(1,len(a)):\\n        if a[i]=='1':\\n            c1[i]=1\\n    print 1,c1[0],c2[1],c2[1]\\n    print 2,c1[0],c2[0],c2[1]", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "2", "task_id": "81", "completion": "from collections import Counter\\n\\ndef solve(n, q):\\n    m, q = [int(i) for i in raw_input().split()]\\n    s = [int(i) for i in raw_input().split()]\\n    m.sort()\\n    i = 0\\n    for i in xrange(n):\\n        m[i] += 1\\n        j = 0\\n        while i < m[j]:\\n            if s[i] == '+':\\n                j += 1\\n                j += 1\\n        i += 1\\n    return m[0]\\n\\nfor _ in xrange(int(raw_input())):\\n    n, q = [int(i) for i in raw_input().split()]\\n    s = [int(i) for i in raw_input().split()]\\n    l, r = [int(i) for i in raw_input().split()]\\n    s.sort()\\n    ans = [0] * n\\n    for i in xrange(1, n + 1):\\n        ans[i] = 0\\n    for i in xrange(1, n + 1):\\n       ", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "2", "task_id": "84", "completion": "def solve(N, S):\\n    M = 0\\n    N = 0\\n    for i in range(len(N)):\\n        if N < i:\\n            M += N/i\\n        else:\\n            S += N%i\\n    return M\\n\\n\\nfor t in range(int(raw_input())):\\n    N, S = map(int, raw_input().split())\\n    for i in range(2, N):\\n        if S - i > S:\\n            M += S - i\\n    print solve(N, S)\\n", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "2", "task_id": "85", "completion": "from sys import stdin\\n\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n\\ts = stdin.readline().strip()\\n\\ta,b,ans,c,d = 0,0,0,0,0\\n\\tfor i in xrange(1,len(s)):\\n\\t\\tif s[i]=='1':\\n\\t\\t\\tif i==len(s) and a==0:\\n\\t\\t\\t\\ta=a+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ta=a-1\\n\\t\\t\\tb=b+1\\n\\t\\t\\tc=c-1\\n\\tprint max(c,a)", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "2", "task_id": "86", "completion": "for _ in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    for _ in xrange(n):\\n        n += 1\\n        a = raw_input()\\n        b = raw_input()\\n        a = a.split('0')\\n        b = b.split('1')\\n        ans = 0\\n        for i in xrange(len(a)):\\n            if a[i] == '1':\\n                ans = ans + (a[i] == '1')\\n                ans += (a[i] == '1')\\n    print ans\\n", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "2", "task_id": "87", "completion": "for t in xrange(input()):\\n    n,m=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    a=sorted(a)\\n    a.sort()\\n    s=0\\n    for i in range(n):\\n        if a[i]>a[i+1]:\\n            s+=a[i]\\n        else:\\n            s+=a[i]\\n        if s==0:\\n            break\\n    print s", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "2", "task_id": "88", "completion": "def find_res(sight, sight, k, i):\\n\\tif k == 0:\\n\\t\\treturn 0\\n\\telif k == 1:\\n\\t\\treturn 0\\n\\telif k == 2:\\n\\t\\treturn 0\\n\\telif k == 3:\\n\\t\\treturn find_res(sight, i+1, j)\\n\\telse:\\n\\t\\treturn find_res(sight, i+1, j-1)\\n\\n\\nT = int(raw_input())\\nfor t in xrange(T):\\n\\tN, M = map(int, raw_input().split())\\n\\tA = map(int, raw_input().split())\\n\\tA.sort()\\n\\tA.reverse()\\n\\tans = 0\\n\\tfor i in xrange(1, M):\\n\\t\\tif A[i] == 1:\\n\\t\\t\\tans += A[i-1]\\n\\t\\t\\tans += A[i]\\n\\t\\t\\tans += A[i]\\n\\t\\t\\tans += A[i]\\n\\tprint ans\\n", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "2", "task_id": "93", "completion": "for _ in range(input()):\\n    a,b=map(int,raw_input().split())\\n    s=0\\n    for i in range(2,a+1):\\n        s+=i\\n    print s", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "2", "task_id": "94", "completion": "#!/usr/bin/python\\n\\nfrom collections import deque\\nimport itertools as it\\nimport math\\nfrom fractions import gcd\\nimport math\\nimport re\\n\\ndef inp():\\n    return int(raw_input())\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef insr():\\n    return map(int,raw_input().split())\\n\\ndef insr2():\\n    return raw_input().strip()\\n\\ndef gcd_int_list():\\n    return map(int,raw_input().strip().split())\\n\\ndef my_main():\\n    for i in range(int(raw_input())):\\n        n=inp()\\n        l=[]\\n        while n>0:\\n            l.append(l[-1]-n%2)\\n            l.append(l[-1]-n%2)\\n        print len(l)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "2", "task_id": "95", "completion": "from sys import stdin, stdout\\n\\nt = int(stdin.readline())\\nfor i in range(t):\\n    s, n = map(int, stdin.readline().split())\\n    print''.join(map(str, list(map(int, stdin.readline().split())))\\n\\n", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "2", "task_id": "98", "completion": "#!/usr/bin/env python\\n\\nfrom __future__ import division\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\\n\\nfor _ in range(int(input())):\\n    n, s = rints()\\n    if 'a' in s:\\n        print('-1 -1')\\n    else:\\n        print(''.join(map(str, args)) + '\\n')\\n", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "2", "task_id": "99", "completion": "for _ in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    s = raw_input()\\n    a, b = map(int, raw_input())\\n    if a == 1:\\n        print(\"YES\")\\n    else:\\n        for i in xrange(n):\\n            if (i+b)%2 == 0:\\n                print(\"X==\")\\n            else:\\n                print(\"X++\")\\n    if a == 0:\\n        for i in xrange(n):\\n            print(\"X--+\")\\n        for j in xrange(n):\\n            if (s[j]%2 == 0):\\n                print(\"X+=\")\\n                print(\"+\")\\n                for i in xrange(n):\\n                    print(\"++\")\\n                print(\"++\")\\n                print(\"-\")", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "2", "task_id": "100", "completion": "from collections import deque\\nt = input()\\nfor _ in range(t):\\n\\tn = input()\\n\\ta = map(int, raw_input().split())\\n\\tans = []\\n\\t\\n\\tm = 998244353\\n\\tfor i in range(1, n):\\n\\t\\ta[i] += m\\n\\t\\tans.append(1)\\n\\tans.sort()\\n\\tans.reverse()\\n\\tans = [0] * (n + 1)\\n\\n\\tfor i in range(n):\\n\\t\\tans[i] = ans[i - 1] % m\\n\\t\\tans[i - 1] = ans[i - 1] % m\\n\\t\\tans[i - 1] = ans[i - 2] % m\\n\\tans[n - 1] = ans[i - 1] % m\\n\\t\\n\\tres = [0] * (n + 1)\\n\\tfor i in range(n):\\n\\t\\tres[i] = res[i - 2] % m\\n\\t\\n\\tfor i in range(1, n):\\n\\t\\tres[i - 1] = res[i -", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "2", "task_id": "101", "completion": "for _ in range(input()):\\n    n,m,k=[int(x) for x in raw_input().split()]\\n    x1=map(int,raw_input().split())\\n    y1=map(int,raw_input().split())\\n    x2=map(int,raw_input().split())\\n    y2=map(int,raw_input().split())\\n    y3=map(int,raw_input().split())\\n    d=min(abs(x1[0]-x2[0],abs(y1[0]-y2[0]))\\n    x3=min(abs(y1[0]-y2[0]),abs(y1[1]-y2[0]))\\n    y3=min(abs(y1[0]-y2[0]))\\n    d=min(abs(y1[0]-y2[0]),abs(y2[0]-y2[1]))\\n    d=min(abs(y2[0]-y2[0]))\\n    d=min(abs(y2[", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "2", "task_id": "109", "completion": "t=int(raw_input())\\nfor i in xrange(t):\\n    n=int(raw_input())\\n    s=raw_input()\\n    l=[]\\n    n1=0\\n    s2=0\\n    i=0\\n    while l[i]=='0':\\n        n1=n1+1\\n        n1=n1+1\\n        l.append(n)\\n    for i in xrange(n1):\\n        l.append(s[i])\\n        n1=n1+1\\n    print min(n1,n1)", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "2", "task_id": "110", "completion": "from __future__ import division\\nfrom collections import deque\\nfrom math import ceil, log, factorial\\nfrom itertools import product, combinations\\nfrom collections import deque\\nimport copy\\nimport itertools as it\\nimport sys\\nimport math\\nfrom collections import deque\\nimport itertools as ite\\nimport bisect\\n\\nR = raw_input\\npr = stdout.write\\nmod = 10 ** 9 + 7\\n\\n\\n\\n# f(1) -> [None] * (10 ** 6)\\n\\n# f(2) -> [a, b] * (10 ** 6)\\n# f(2) -> [b, c, d]\\n\\n\\ndef f(n):\\n    if n == 1:\\n        return []\\n    if n == 1:\\n        return []\\n    return [i for i in range(n)]\\n\\n\\n\\ndef solve():\\n    q = int(R())\\n    for _ in range(q):\\n        n = R()\\n        l = [int(x) for x in R().split()]\\n        m = m[0]\\n        for i in range(1, n+1):\\n            if m[i] == m[", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "2", "task_id": "111", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    if n == 1:\\n        print \"(\"\\n        for i in range(n - 2):\\n            print \")\"\\n        print ')'\\n    else:\\n        for i in range(n):\\n            print '(' * (n - i) + ')'\\n        print ')'\\n", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "2", "task_id": "112", "completion": "t=input()\\nfor i in range(t):\\n    a,b,c,m=map(int,raw_input().split())\\n    s=set([])\\n    for j in range(m):\\n        if a==b:\\n            s.add(b)\\n            s.add(c)\\n    if m!=0:\\n        print \"NO\"\\n    else:\\n        print \"YES\"\\n", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "2", "task_id": "113", "completion": "def main():\\n    n = input()\\n    a = map(int, raw_input().split())\\n    m = input()\\n    dragons = []\\n    for i in xrange(n):\\n        a[i] = map(int, raw_input().split())\\n    dragons.sort()\\n    coins = 0\\n    for i in xrange(m):\\n        x, y = input()\\n        x -= 1\\n        y -= 1\\n        if x < 0:\\n            coins += y\\n            coins += 1\\n    print coins\\n\\nmain()\\n", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "2", "task_id": "114", "completion": "n = int(raw_input())\\nc = {}\\na = []\\nm = int(raw_input())\\nfor i in range(n):\\n    c[i] = map(int, raw_input().split())\\n    m = min(m, [int(x) for x in raw_input().split()])\\nm = int(raw_input())\\n\\nm_set = [None] * n\\nfor i in range(m):\\n    c[i] = map(int, raw_input().split())\\n    m_set.append(c[i])\\n\\nm_set = sorted(m_set, key = lambda x: x[1])\\n\\nm_set = sorted(m_set)\\nfor i in range(m):\\n    print m_set[i],\\n", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "3", "task_id": "4", "completion": "import math\\ndef prime(a):\\n    if(a==1):\\n        return 2\\n    else:\\n        return a\\n\\ndef prime(a):\\n    return (a*a) % (a+1)\\n\\n\\n\\ndef prime_num(a):\\n    return ((a+1)*(a%2) - 1) / 2\\n\\n\\nif __name__ == \"__main__\":\\n    t = int(raw_input())\\n    while(t):\\n        p = int(raw_input())\\n        for i in range(1, int(math.sqrt(p)) + 1):\\n            if prime(i) and prime(p-1)%i==0:\\n                print i, p-1\\n                continue\\n            if prime(p-1)%i==0:\\n                print i, p-1\\n                break", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "3", "task_id": "5", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    s1 = input()\\n    s2 = input()\\n\\n    ans = 0\\n    for i in range(n):\\n        if s1[i] == '1':\\n            ans += 1\\n        else:\\n            if s2[i] == '1':\\n                ans += 1\\n            else:\\n                ans += 1\\n    print ans", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "3", "task_id": "6", "completion": "n, m = map(int, raw_input().split())\\nd = {}\\nfor i in xrange(m):\\n    u, v = map(int, raw_input().split())\\n    d[u].append(v)\\n    d[v].append(u)\\nq = int(raw_input())\\nfor i in xrange(q):\\n    u, v = map(int, raw_input().split())\\n    if d[u] == 2:\\n        if d[v]!= 1:\\n            if d[u]!= 1:\\n                d[u] = 1\\n        else:\\n            if d[v]!= 1:\\n                d[v] = 1\\n        else:\\n            d[u] = 1\\nprint n\\n", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "3", "task_id": "7", "completion": "from sys import stdin, stdout\\ndef main():\\n    n = int(stdin.readline())\\n    for i in xrange(n):\\n        n = int(stdin.readline())\\n        a = map(int, stdin.readline().split())\\n        print len(set(a))\\n\\nif __name__ == '__main__':\\n    main()\\n", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "3", "task_id": "8", "completion": "for _ in xrange(int(raw_input())):\\n    n=int(raw_input())\\n    a=n/2\\n    if n%2==0:\\n        print a,a\\n    else:\\n        print a,n/2\\n", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "3", "task_id": "9", "completion": "def read():\\n    return raw_input().strip()\\n\\ndef read_ints():\\n    return map(int,read().split())\\n\\nfor _ in range(input()):\\n    s = read()\\n    s = set(s)\\n    m = {}\\n    for i in s:\\n        if m.has_key(i):\\n            m[i] = 0\\n        else:\\n            m[i] += 1\\n    print m.get(len(m))\\n", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "3", "task_id": "10", "completion": "from __future__ import division, print_function\\nfrom heapq import *\\nfrom collections import *\\nfrom collections import *\\nfrom sys import *\\n\\n\\n\\n\\n\\n\\n\\n\\ndef solve(n, k, a):\\n    a.sort(reverse = True)\\n    for i in xrange(k):\\n        print(0)\\n\\n\\n\\n\\nif __name__ == '__main__':\\n    testcases = int(raw_input())\\n    for _ in xrange(testcases):\\n        n, k = map(int, raw_input().split())\\n        print(\" \".join(map(str, a)))", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "3", "task_id": "11", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nT = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    chars = []\\n    for i in range(n):\\n        chars.append(input())\\n    chars.sort()\\n    prev = 0\\n    for i in chars:\\n        if prev >= prev:\\n            prev = i\\n    print len(set(chars)) - len(prev)\\n", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "3", "task_id": "12", "completion": "for _ in range(input()):\\n    n, m, k = map(int, raw_input().split())\\n    if k%2==0 or n>=m:\\n        print(\"YES\")\\n    else:\\n        print(\"NO\")", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "3", "task_id": "16", "completion": "for _ in range(input()):\\n    n = input()\\n    s = raw_input()\\n    for i in range(n):\\n        s = s[n-i-1]\\n        if s!= s[i]:\\n            print i\\n            break\\n    else:\\n        print n - s[-i-1]", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "3", "task_id": "17", "completion": "import sys\\n\\nT = int(sys.stdin.readline())\\n\\nfor _ in range(T):\\n    N = int(sys.stdin.readline())\\n    a = []\\n    for _ in range(N):\\n        a.append(map(int, sys.stdin.readline().split()))\\n    n = len(a)\\n    a = [0]*N\\n    for i in range(n):\\n        a[i] += 1\\n\\n    for i in range(N):\\n        a[i] = [i]*N\\n\\n    for i in range(N):\\n        a[i] = [0]*N\\n    for i in range(N):\\n        a[i] = [0]*N\\n\\n    for i in range(N):\\n        for j in range(N):\\n            a[j][i] = a[j] - 1\\n\\n    if n <= 3:\\n        print -1\\n        sys.exit()\\n\\n    for i in range(N):\\n        for j in range(N):\\n            if a[i][j]!= a[j]:\\n               ", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "3", "task_id": "18", "completion": "from __future__ import print_function\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, k = rints()\\n    xs, ys = rints()\\n    xs -= k\\n    ys -= k\\n    xs += 1\\n    ys += k\\n    if xs + ys < n - k:\\n        out.append(ys)\\n    else:\\n        out.append(k - ys)\\n\\nfor _ in out:\\n    print(n - k)", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "3", "task_id": "19", "completion": "from collections import Counter\\nimport math\\nimport sys\\n\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor _ in range(int(le.pop())):\\n    n = int(le.pop())\\n    a = map(int,le.pop().split(\" \"))\\n    b = [0] * n\\n    for i in range(n):\\n        b[a[i] - i - 1] = b[i] - i\\n    if b:\\n        af.append(\"YES\")\\n    else:\\n        af.append(\"NO\")\\n\\n\\nfor _ in range(int(le.pop())):\\n    n = int(le.pop())\\n    l = map(int,le.pop().split())\\n    if n == 1:\\n        print(\"YES\")\\n    else:\\n        print(\"NO\")\\n", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "3", "task_id": "20", "completion": "import sys\\nn,k=map(int,raw_input().split())\\nl=map(int,raw_input().split())\\nl.sort()\\n\\nfor i in range(k-1):\\n    for j in range(n-1,i+1,-1):\\n        if l[j]>l[j+1]:\\n            l[j]=l[j+1]\\n\\nfor i in range(k):\\n    print l[i],l[i+1]\\n", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "3", "task_id": "21", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nmod = 998244353\\n\\nMOD = 998244353\\n\\ndef next_node(x,y,s):\\n    if(x == 0): return\\n    return [(x,y)]\\n\\ndef dfs(x,y):\\n    dfs(x,y,s)\\n\\ndef dfs(x,y,s):\\n    s = dfs(x,y,s)\\n    return (s*x-y)%MOD\\n\\nn = int(input())\\na = [map(int,input().split()) for i in range(n)]\\nb = [(i[0],i[1],i[2]) for i in range(1,n)]\\n\\ndef dfs(x,y,s):\\n    ans = 0\\n    for i in range(1,n):\\n        ans += dfs(x,y,s)\\n    return ans\\n\\ndef calc(x,y,s):\\n    s = dfs(x,y,s)\\n    if s == 1:\\n        return 1\\n    return ans\\n\\nl", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "3", "task_id": "24", "completion": "n = int(raw_input())\\n\\nfor i in range(n):\\n    c = int(raw_input())\\n    print c - sum(map(int,str(i)) for i in str(c)))", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "3", "task_id": "25", "completion": "q = int(raw_input())\\nfor _ in range(q):\\n    s = list(raw_input())\\n    t = list(raw_input())\\n    p = 0\\n    for c in s:\\n        if c == c: p += 1\\n    if p == 0: p -= 1\\n    if p == 0: p += 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p += 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p -= 1\\n    if p == 0: p += 1\\n\\n    if p > 0: p -= 1\\n\\n    if p == 0: p -= 1\\n\\n    if p == 0: p -= 1\\n    if", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "3", "task_id": "26", "completion": "t = int(raw_input())\\nfor i in range(t):\\n    s = raw_input()\\n    s = list(s)\\n    s = s.replace('?', '')\\n    n = len(s)\\n    a = []\\n    for c in s:\\n        a.append(int(c))\\n    if '1' in a:\\n        a.append(int(c))\\n    a.sort()\\n    a.sort()\\n    #print '1'\\n    for i in range(1,n+1):\\n        x = a[i]\\n        if x == '?':\\n            a[i] += 1\\n        else:\\n            a[i] += 1\\n    #print x,n\\n    ans = 0\\n    #print a\\n    for i in a:\\n        if x == '?':\\n            a[i] += 1\\n        ans += 1\\n    print ans\\n", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "3", "task_id": "27", "completion": "from sys import stdin\\nfrom collections import *\\n\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    s, t = rint(), rint()\\n    t -= 1\\n    ans = True\\n    if len(t) == 0:\\n        if s in out:\\n            out.append(\"YES\")\\n        else:\\n            out.append(\"NO\")\\n    else:\\n        for i in range(1, len(t)):\\n            if t[i] == s[i-1]:\\n                ans = False\\n            if t[i-1] == t[i]:\\n                break\\n            if s[i-1] == t[i]:\\n                out.append(\"NO\")\\n                break\\n        if len(t) > 0:\\n            ans = False\\n\\n    if ans:\\n        out.append(\"YES\")\\n\\nprint(\"\\n\".join(out))\\n", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "3", "task_id": "28", "completion": "for _ in xrange(int(raw_input())):\\n    n, m = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n    a = [x - 1 for x in a]\\n    b = [x - 1 for x in a]\\n    if n == 1:\\n        print 0\\n    elif n == 2:\\n        print 1,\\n    elif n == 3:\\n        print n - 1,\\n    else:\\n        print 0,\\n    print\\n", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "3", "task_id": "33", "completion": "def f(n):\\n    ret = []\\n    for i in xrange(1, n + 1):\\n        ret.append(max(n - i - 1, i * a[i - 1]))\\n    return ret\\n\\ndef solve(n, arr):\\n    if n % 2:\\n        return sum(map(int, arr[n / 2:]))\\n    if n % 2:\\n        return 0\\n    ret.sort()\\n    res = 0\\n    while n % 2:\\n        ret.append(min(n // 2, arr[n - 1]))\\n        n -= 2\\n        n -= 1\\n    return res\\n\\nfor _ in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    arr = map(int, raw_input().split())\\n    print solve(n, arr)", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "3", "task_id": "34", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nT = int(input())\\nfor t in range(T):\\n    N, K = [int(x) for x in input().split()]\\n    A = [int(x) for x in input().split()]\\n    A.sort(reverse=True)\\n    ans = [-1]*N\\n    for a in A:\\n        ans[a&k] = ans[a] - 1\\n    ans[0] = -1\\n    ans[1] = -1\\n    ans[0] = -1\\n    for a in A:\\n        ans[a] = max(ans[a], ans[a])\\n    print(ans[0])\\n", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "3", "task_id": "35", "completion": "from sys import stdin\\nfrom math import ceil\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n, m = map(int, stdin.readline().split())\\n    ans = ceil((n*m)%2)\\n    print ans", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "3", "task_id": "36", "completion": "for _ in range(input()):\\n    n=input()\\n    m=n/2\\n    i=0\\n    s=n-(m-1)*2\\n    if m<2:\\n        s=s+\"a\"\\n    elif m%2:\\n        s=s+s\\n    else:\\n        s=s+s\\n    print s", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "3", "task_id": "38", "completion": "t = int(raw_input())\\nfor i in range(t):\\n    n = int(raw_input())\\n    print(n * 6 + 15 * 7 - n)", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "3", "task_id": "39", "completion": "T = int(raw_input())\\n\\nfor i in range(T):\\n    W, H = map(int, raw_input().split())\\n    x1, y1, x2, y2 = map(int, raw_input().split())\\n    x = abs(x1-x2)\\n    y = abs(y1-y2)\\n    if x<w:\\n        print -1\\n    elif x>w:\\n        print abs(x-x2)\\n    elif x>h:\\n        print abs(y-y2)\\n    else:\\n        print abs(x-y2)\\n", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "3", "task_id": "40", "completion": "def main():\\n\\tfor _ in xrange(input()):\\n\\t\\tm=input()\\n\\t\\tarr=[map(int,raw_input().split()) for _ in xrange(2)]\\n\\t\\tans=0\\n\\t\\tfor i in xrange(2,m):\\n\\t\\t\\tarr[i][i]+=arr[i-1][i-1]\\n\\t\\t\\tarr[i][i+1]+=arr[i-1][i]\\n\\t\\t\\tans+=arr[i-1][i]\\n\\t\\tprint ans\\n\\n\\nmain()", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "3", "task_id": "41", "completion": "n,m = map(int, raw_input().split())\\ns = raw_input()\\nfor i in range(m):\\n    l,r = map(int, raw_input().split())\\n    d = 0\\n    for j in range(n-2):\\n        if s[j]!= s[l-1]:\\n            d += 1\\n    print(d)", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "3", "task_id": "44", "completion": "T = int(raw_input())\\nfor i in xrange(T):\\n    c, d = map(int, raw_input().split())\\n    if c == d == 0:\\n        print 1\\n    else:\\n        if d - c < 0:\\n            print -1\\n        else:\\n            if c > d - d:\\n                print (d - c)\\n            else:\\n                print (d - c)", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "3", "task_id": "45", "completion": "for _ in range(input()):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    ans = 0\\n    for i in range(n):\\n        if i == 0:\\n            ans += 1\\n        if ans > 2:\\n            if a[i] <= 2:\\n                ans -= 2\\n                a[i] = 2\\n        else:\\n            if a[i] <= 1:\\n                ans += 1\\n    if ans > 2:\\n        print -1\\n    else:\\n        print ans\\n", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "3", "task_id": "46", "completion": "n = int(raw_input())\\nlst = map(int, raw_input().split())\\nlst.sort()\\nans = 0\\nfor i in range(len(lst)-1):\\n    ans += lst[i+1] - lst[i]\\nprint ans", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "3", "task_id": "52", "completion": "import atexit, io, sys\\nbuffer = io.BytesIO() \\nsys.stdout = buffer\\n@atexit.register \\ndef write(): sys.__stdout__.write(buffer.getvalue())   \\n\\nfor _ in range(int(raw_input())):\\n    n = int(raw_input())\\n    nums = map(int, raw_input().split())\\n    sum = sum(nums)\\n    a = sum / n\\n    b = sum / n\\n    print \"%f\" % (a + b)\\n", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "3", "task_id": "53", "completion": "for _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    if (n==1):\\n        print \"YES\"\\n    else:\\n        flag=0\\n        for i in range(n-k):\\n            if a[i]>=a[i+k]:\\n                flag=1\\n                break\\n            else:\\n                if a[i]>=a[i+k]:\\n                    flag=1\\n                    break\\n            if flag==0:\\n                print \"YES\"\\n                else:\\n                    print \"NO\"\\n    print \"NO\"", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "3", "task_id": "54", "completion": "from sys import stdin\\nfrom math import log\\nfrom bisect import bisect_right\\nfrom collections import defaultdict\\nfrom bisect import bisect_left\\n\\ninput = stdin.readline\\nMOD = 10**9+7\\n\\n\\ndef read_int():\\n    return int(input())\\n\\ndef read_ints():\\n    return map(int, input().split())\\n\\n\\n\\ndef read_floats():\\n    return (input() * (input() - 1))\\n\\n\\nMOD = 10 ** 9 + 7\\n\\ndef solve(n, k):\\n    r = 0\\n    if k == 0:\\n        r += 1\\n    if k == 0:\\n        r += 1\\n    if k == 1:\\n        r += 1\\n    return r * r\\n\\n\\ndef main():\\n    t = read_int()\\n    for _ in xrange(t):\\n        n, k = read_ints()\\n        print solve(n, k)\\n\\n\\n\\n\\n\\nif __name__ == '__main__':\\n    main()\\n", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "3", "task_id": "60", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\n\\nfor _ in range(int(input())):\\n    n, a = int(input()), rints()\\n    print sum(a) & 1", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "3", "task_id": "61", "completion": "for _ in range(input()):\\n    n = input()\\n    s = raw_input()\\n    c = [0]*n\\n    l = len(s)\\n    for i in range(n-1):\\n        if(s[i] == '?':\\n            l += 1\\n        elif(s[i] == '?'):\\n            l -= 1\\n        else:\\n            c[l] += 1\\n    if(l % 2 == 1):\\n        l = l/2\\n    print l\\n", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "3", "task_id": "62", "completion": "def solve(n, a):\\n    if n == 1:\\n        return [a]\\n    ans = []\\n    cur = 0\\n    ans.append(a[0])\\n    for i in xrange(1, n):\\n        if a[i] == 1:\\n            cur += 1\\n        else:\\n            cur = 1\\n        if cur == 0:\\n            ans.append(i)\\n    ans.append(a[0])\\n    if ans:\\n        ans.append(a[1])\\n    ans = ''\\n    ans.reverse()\\n    for i in ans:\\n        print i,\\n    \\nfor _ in xrange(int(raw_input())):\\n    solve(int(raw_input()), a)\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "3", "task_id": "66", "completion": "t = int(raw_input())\\nfor _ in range(t):\\n\\tk = int(raw_input())\\n\\tk = k%3\\n\\ta = 1\\n\\tprint a\\n\\t\\n\\n", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "3", "task_id": "67", "completion": "for _ in range(input()):\\n    a,b,c=map(int,raw_input().split())\\n    if a==c:\\n        print b-1\\n    elif b==c:\\n        print -1\\n    else:\\n        print a-1\\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "3", "task_id": "68", "completion": "for _ in xrange(input()):\\n    k = input()\\n    print k, k/2", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "3", "task_id": "69", "completion": "for _ in range(input()):\\n\\tn = input()\\n\\tn1 = n[::-1]\\n\\tn2 = n[::-1]\\n\\tans = 1\\n\\twhile n2>=0:\\n\\t\\tans += 1\\n\\t\\tn2 = n2-1\\n\\tprint ans\\n", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "3", "task_id": "70", "completion": "for _ in xrange(input()):\\n    s = raw_input()\\n    if s == t:\\n        print -1\\n    else:\\n        f = False\\n        for i in xrange(len(s)):\\n            if s[i]!= t[i]:\\n                f = True\\n            if f:\\n                print s[i],\\n        print ''.join(s)\\n        else:\\n            if f:\\n                print -1\\n                break\\n        print s[i],\\n\\n", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "3", "task_id": "71", "completion": "for _ in xrange(input()):\\n    n, k = map(int, raw_input().split())\\n    x = n//10\\n    if k==1:\\n        print n\\n    elif k==2:\\n        print n\\n    elif k==1:\\n        print n\\n    else:\\n        print n", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "3", "task_id": "72", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor i in range(t):\\n    n, k = [int(i) for i in input().split()]\\n    x = (n-1)*10\\n    while x > 0:\\n        m = 10**(x%10)\\n        if m == m:\\n            x = m\\n            break\\n    print(x)", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "3", "task_id": "73", "completion": "t=int(raw_input())\\nfor i in range(t):\\n\\tn=int(raw_input())\\n\\tarr=list(map(int,raw_input().split()))\\n\\tarr.sort()\\n\\tl=len(arr)\\n\\tans=0\\n\\tfor j in range(l):\\n\\t\\tif(arr[j]>arr[j+1]):\\n\\t\\t\\tans+=1\\n\\tprint ans", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "3", "task_id": "74", "completion": "from sys import stdin\\nfrom collections import defaultdict\\n\\ndef main():\\n    tc = int(stdin.readline())\\n    for _ in range(tc):\\n        a, b = map(int, stdin.readline().split())\\n        # print a, b\\n        a = min(a, b)\\n        b = max(b, a)\\n        print a\\n        if a <= b:\\n            print 0, 2\\n            continue\\n        a -= 1\\n        b -= 1\\n        print b, 2\\n    # print a\\n\\nmain()\\n", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "3", "task_id": "75", "completion": "for _ in range(input()):\\n    n=input()\\n    cave=0\\n    ans=0\\n    for i in range(n):\\n        l=map(int,raw_input().split())\\n        cave+=l[1]\\n        cave+=l[0]\\n        ans+=max(cave,cave)\\n    print ans\\n\\n", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "3", "task_id": "76", "completion": "n, m = map(int, raw_input().split())\\nprint ((m**n) - (n - 1) % m) % m", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "3", "task_id": "77", "completion": "from math import ceil\\nn,m = map(int,raw_input().split())\\nmod = 1000000001\\nif n == 2:\\n    print 1\\nelif n == 3:\\n    print m\\nelif n == 5:\\n    print m\\nelse:\\n    m = 1\\n    print m\\n\\n\\n\\n\\n", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "3", "task_id": "78", "completion": "for _ in range(int(raw_input())):\\n    a,b=map(int,raw_input().split())\\n    a=a/2\\n    print(a%b)\\n    \\n", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "3", "task_id": "79", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\ndef solve(k,n):\\n    #print n\\n    if n==1:\\n        print 0\\n        for i in range(2,n):\\n            if n%i==0:\\n                return 1\\n        print n\\n    if n==2:\\n        return 1\\n    if k==1:\\n        for i in range(2,n):\\n            if n%i==0:\\n                for j in range(2,n):\\n                    if n%j==0:\\n                        return 0\\n\\n", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "3", "task_id": "80", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    s = input()\\n    a = ''\\n    a += '1'\\n    b = ''\\n    for i in range(n / 2):\\n        a += '1'\\n        b += '1'\\n    for i in range(n/2):\\n        a += '1'\\n    for i in range(n/2):\\n        a += '0'\\n    a += '1'\\n    b += '1'\\n    print(a)\\n", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "3", "task_id": "81", "completion": "from sys import stdin, stdout\\nI = lambda: map(int, stdin.readline().split())\\ndef ia(): return stdin.readline().strip()\\ndef ia2(): return map(int, stdin.readline().split())\\ndef ia(): return map(int, stdin.readline().strip().split())\\ndef it(): return map(int, stdin.readline().strip().split())\\ndef it_split(): return stdin.readline().strip()\\n\\n\\ndef _it(): return int(stdin.readline())\\n\\ndef _it_split(): return stdin.readline().strip()\\n\\n\\nfor _ in range(I()):\\n    n, q = I()\\n    s = I()\\n    l = sum(s)\\n    s.sort()\\n\\n    ans = 0\\n    for i in range(q):\\n        l, r = I()\\n        if l < r:\\n            ans += 1\\n        elif r > l:\\n            r -= l\\n        else:\\n            break\\n    print ans\\n\\n", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "3", "task_id": "84", "completion": "t = input()\\nfor _ in range(t):\\n    n, s = map(int, raw_input().split())\\n    print(s-n)\\n", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "3", "task_id": "85", "completion": "import os\\nimport sys\\nfrom atexit import register\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\n\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\\n\\nfor _ in range(int(input())):\\n\\ts = input()\\n\\tprint(s[0] + 1)", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "3", "task_id": "86", "completion": "t = input()\\nfor _ in range(t):\\n    n = input()\\n    s = raw_input()\\n    res = 0\\n    ans = 0\\n    for i in range(n):\\n        for j in range(n):\\n            if s[i] == '0':\\n                res += 2\\n            elif s[j] == '1':\\n                ans += 2\\n        else:\\n            break\\n    print ans\\n", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "3", "task_id": "87", "completion": "for _ in range(input()):\\n    n,m=[int(k) for k in raw_input().split()]\\n    l=[]\\n    for i in range(1,m+1):\\n        l.append(map(int,raw_input().split()))\\n    m=m-1\\n    for i in l:\\n        m=max(m,m-i)\\n    print sum(l)", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "3", "task_id": "88", "completion": "for _ in range(input()):\\n    n,m=map(int,raw_input().split())\\n    l=map(int,raw_input().split())\\n    l.sort()\\n    ans=0\\n    for i in range(1,n):\\n        #print l[i],ans\\n        #print ans\\n        ans+=l[i-1]\\n    print ans", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "3", "task_id": "93", "completion": "t=int(raw_input())\\nfor _ in xrange(t):\\n    a,b=map(int,raw_input().split())\\n    if a>b:\\n        print a-b\\n    elif b<a:\\n        print b-a\\n    else:\\n        print a", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "3", "task_id": "94", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nT = int(input())\\nfor _ in range(T):\\n    n = int(input())\\n    sum = n / (n - 1)\\n    sum = sum + (n - 1) / 2\\n    print(sum)", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "3", "task_id": "95", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor i in range(t):\\n    n, a = [int(x) for x in input().split()]\\n    if n > 11:\\n        s = 0\\n        for j in range(1, n):\\n            s += (n-10) * a\\n        print(str(s) + \" \" + str(s))\\n", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "3", "task_id": "98", "completion": "from sys import stdin\\nfrom collections import *\\nfrom fractions import gcd\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nfor _ in range(input()):\\n\\tn,s = int(input()), rints()\\n\\ta = s.count('a')\\n\\tb = s.count('b')\\n\\tprint l,r-1", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "3", "task_id": "99", "completion": "for _ in range(input()):\\n    n = input()\\n    s = raw_input()\\n    if len(s) == 2:\\n        print \"YES\"\\n    else:\\n        print \"X==\"\\n    print \"X==?\"*(n-1)\\n    for i in range(n-2):\\n        print \"-\"*n\\n    print \"X==?\"*(n-2)+\"=\"*(n-2)\\n    print \"X==?\"*(n-2)+\"+\"*n\\n    for i in range(n-1):\\n        print \"+\"*n+\"-\"*(n-1)+\"-\"*(n-2)+\"+\"+\"+\"+\"-(n-1)+\"-\"*(n-1)+\"=\"*(n-2)+\"-\"*(n-1)+\"-\"*(n-2)+\"=\"*(n-2)+\"-\"\\n    for i in range(n-1):\\n        print \"-\"*(n-2)+\"+\"*(n-2)+\"+\"+(n-1)+\"-\"*(n-2)+\"+\"+\"+\"\\n    for i in range(n-1):\\n        print \"-\"*", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "3", "task_id": "100", "completion": "from collections import Counter\\nt = input()\\nfor _ in range(t):\\n    n = input()\\n    a = map(int,raw_input().split())\\n    ans = 0\\n    for i in a:\\n        ans += (i-1)/2\\n    print ans\\n", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "3", "task_id": "101", "completion": "from collections import Counter\\nfor _ in range(input()):\\n    n,m,k=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    b=map(int,raw_input().split())\\n    c=Counter(map(int,raw_input().split()))\\n    x,y=0,0\\n    for i in range(k):\\n        a[i]=map(int,raw_input().split())\\n        c[i]=map(int,raw_input().split())\\n    y=0\\n    for i in range(n):\\n        for j in range(m):\\n            if a[i][j]>=a[j][0] and b[j][0]<=b[j][1]:\\n                c[j][1]=c[j][1]\\n    count=0\\n    for i in range(m):\\n        if a[i][j]<=b[j][1]:\\n            count+=1\\n    print count\\n", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "3", "task_id": "109", "completion": "from sys import stdin, stdout\\nI = lambda : map(int,stdin.readline().split())\\nimport math\\nfrom collections import defaultdict\\nfrom collections import deque\\n\\nR = lambda : stdin.readline().strip()\\nrstrs = lambda : stdin.readline().strip()\\nrint = lambda : int(stdin.readline().strip())\\nrints = lambda : [int(x) for x in stdin.readline().split()]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\nout = []\\nt = input()\\nfor _ in range(t):\\n    n = input()\\n    s = R()\\n    s.sort()\\n    if s[-1] > 10**n:\\n        break\\n    if s[-1] < 10**n:\\n        print (n - 1) // 2\\n    else:\\n        print (n - 1) // 2\\n", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "3", "task_id": "110", "completion": "def get_read_array(a):\\n    return map(int, raw_input().split())\\n\\ndef main():\\n    n = input()\\n    arr = []\\n    for i in range(n):\\n        arr.append(get_read_array(map(int, raw_input().split()))\\n    ans = sum(arr)\\n    for _ in range(n):\\n        r = len(set(raw_input().split()))\\n        if r >= n:\\n            ans = r - n\\n    print ans\\n\\n\\n\\nif __name__ == '__main__':\\n    main()\\n\\n", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "3", "task_id": "111", "completion": "for _ in range(input()):\\n    n=input()\\n    a=[x for x in range(2**n)]\\n    for i in range(1,2*n+1):\\n        print '(' * a[i-1]\\n    print ')' * a[n-1]", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "3", "task_id": "112", "completion": "#!/usr/bin/python\\n\\nimport sys\\nimport math\\n\\nfor _ in range(input()):\\n    a, b, c, m = [int(x) for x in sys.stdin.readline().split()]\\n\\n    if m == 0:\\n        a = a\\n    elif a == 0:\\n        b = b\\n    elif b == 0:\\n        c = c\\n    elif c == 0:\\n        a = a\\n    elif c == 0:\\n        c = c\\n\\n    if a > b:\\n        a = b\\n\\n    if c > c:\\n        b = c\\n    if a < b:\\n        c = a\\n\\n    if c > c:\\n        b = c\\n\\n    if a > c:\\n        c = a\\n    if a < b:\\n        a = a\\n\\n    if b > c:\\n        b = b\\n\\n    if a >= c:\\n        c = c\\n\\n    if b > c:\\n        c = a\\n    if c > c:\\n        c = c\\n\\n    if m == 0:\\n        if c <", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "3", "task_id": "113", "completion": "n = int(raw_input())\\nl = [int(x) for x in raw_input().split()]\\narr = [int(x) for x in raw_input().split()]\\narr.sort()\\narr.reverse()\\nm = int(raw_input())\\nfor i in range(m):\\n    x, y = [int(x) for x in raw_input().split()]\\n    arr.insert(0, y)\\n    print max(arr[i+1], 0) - min(arr)\\n", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "3", "task_id": "114", "completion": "n = int(raw_input())\\nsum = 0\\n\\nfor i in range(n):\\n    a, b = map(int, raw_input().split())\\n    sum += a\\n    for j in range(n):\\n        sum += b[j]\\n    sum += b[j]\\n\\nm = int(raw_input())\\n\\nres = []\\nfor i in range(m):\\n    x, y = map(int, raw_input().split())\\n    y -= 1\\n    if x > 0:\\n        res.append(str(x))\\n    else:\\n        res.append(str(y))\\n\\nprint(' '.join(res))\\n", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "4", "task_id": "4", "completion": "def prime(n):\\n    if n % 2 == 0:\\n        return True\\n    return False\\n\\nt = int(raw_input())\\n\\nwhile t > 0:\\n    n = int(raw_input())\\n    print (n - 2) / 2, (n - 1) / 2\\n    t -= 1", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "4", "task_id": "5", "completion": "T = int(raw_input())\\nfor _ in range(T):\\n    N = int(raw_input())\\n    S = raw_input()\\n    ans = 0\\n    for i in range(N):\\n        if S[i] == '1':\\n            ans += 1\\n        else:\\n            if S[i] == '1':\\n                ans += 1\\n        else:\\n            if S[i] == '0':\\n                ans += 1\\n        ans += 1\\n    print ans", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "4", "task_id": "6", "completion": "#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\nfrom collections import defaultdict\\nfrom math import factorial as f\\nfrom fractions import gcd as g\\n\\nN, M = [int (i) for i in raw_input ().split ()]\\nf = [False] * N\\nfor i in range (M):\\n\\tu, v = [int (i) for i in raw_input ().split ()]\\n\\tf[u] = True\\n\\tf[v] = True\\n\\nq = int (raw_input ())\\n\\nfor i in range (M):\\n\\tu, v = [int (i) for i in raw_input ().split ()]\\n\\tprint sum (nobles) - sum (nobles)\\n", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "4", "task_id": "7", "completion": "from collections import Counter\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\ndef inp(force_list=False):\\n    re = map(int, stdin.read().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(a, b):\\n    if b==0:\\n        return a\\n    else:\\n        return gcd(b, a % b)\\n\\ndef my_main():\\n    t = inp()\\n    for _ in xrange(t):\\n        n = inp()\\n        A = inp()\\n        l = A[:n]\\n        r = [a[n] for n in A]\\n        l.sort(reverse=True)\\n        m = n\\n        i = 2\\n        for j in xrange(m):\\n            if l[i]!= j:\\n                i += 1\\n            else:\\n                i = i * 2\\n                m = j\\n        print max(n, m)\\n\\n\\nmain()", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "4", "task_id": "8", "completion": "for _ in range(input()):\\n    n=input()\\n    if n%2==0:\\n        print n/2,n/2+1\\n    else:\\n        print n/2-n,n/2-n\\n", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "4", "task_id": "9", "completion": "for _ in range(input()):\\n    s=raw_input()\\n    l=len(s)\\n    l1=sorted(set(s))\\n    l2=[]\\n    l3=[]\\n    for i in l:\\n        l2.append(ord(i))\\n    i=0\\n    while i<l1:\\n        if s[i]>l[i-1]:\\n            l1[i]-=1\\n            i+=1\\n    print len(l1)\\n    \\n        \\n            ", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "4", "task_id": "10", "completion": "from __future__ import print_function, division\\nimport sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n, k = [int(x) for x in input().split()]\\n    a = [int(x) for x in input().split()]\\n    b = [0] * (n + 1)\\n    for i in a:\\n        print(b[i], i+1),", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "4", "task_id": "11", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nt = inp[ii]; ii += 1\\nfor _ in range(t):\\n    n = inp[ii]; ii += 1\\n    ans = 0\\n    L = []\\n    L_ = []\\n    L_s = set()\\n    L_e = set()\\n    for i in range(n):\\n        L.append(inp[ii]); ii += 1\\n        L_e.add(inp[ii]); ii += 1\\n\\n    # L.append(L_s)\\n    L_s.add(L_s); ii += 1\\n    for i in range(n):\\n        L_s.add(inp[ii]); ii += 1\\n\\n    for i in range(n):\\n        L_s.add(inp[ii]); ii += 1\\n\\n    for i in range(n):\\n        L_s[i].remove(inp[i]); ii += 1\\n\\n    for i in range(n):\\n        L_s[", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "4", "task_id": "12", "completion": "for _ in range(input()):\\n    n,m,k = map(int,raw_input().split())\\n    if k%2 == 1:\\n        if n%2 == 0:\\n            print \"YES\"\\n        else:\\n            print \"NO\"\\n    else:\\n        if m%2 == 1:\\n            print \"YES\"\\n        else:\\n            print \"NO\"", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "4", "task_id": "16", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    k=sorted(s)\\n    for i in range(n-1):\\n        if(s[i]>s[i+1]):\\n            k.remove(s[i])\\n    print k[n-1]", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "4", "task_id": "17", "completion": "from sys import stdin, stdout\\n\\ndef main():\\n\\tn = int(stdin.readline())\\n\\tfor _ in xrange(n):\\n\\t\\tm = int(stdin.readline())\\n\\t\\tpr = [map(int, stdin.readline().split()) for _ in xrange(m)]\\n\\t\\tpr = sorted(pr)\\n\\n\\t\\tcnt = 0\\n\\t\\tfor i in xrange(n):\\n\\t\\t\\tfor j in xrange(i+1, n):\\n\\t\\t\\t\\tif pr[i][j] not in pr[j-1]:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tif cnt >= 3:\\n\\t\\t\\t\\t\\tstdout.write(str(cnt) + \"\\n\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstdout.write(\"-1\")\\n\\t\\t\\tprint cnt\\n\\t\\nmain()\\n\\n", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "4", "task_id": "18", "completion": "def solve(n, k):\\n    #print n\\n    for x in range(k):\\n        p, y = map(int, raw_input().split())\\n        if (n - k) % 2 == 0:\\n            return (n + 1) * (y - 1) / 2\\n        else:\\n            return (n * (n - k) + 1) / 2 + 1\\n    return 0\\n\\nt = int(raw_input())\\nfor _ in range(t):\\n    n, k = map(int, raw_input().split())\\n    ans = 0\\n    for _ in range(k):\\n        x, y = map(int, raw_input().split())\\n        ans += solve(n - k - 1, x, y)\\n    print ans\\n", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "4", "task_id": "19", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = stdin.readline\\npr = stdout.write\\nmod=10**9+7\\n\\ndef in_num():\\n    return int(raw_input())\\n\\n\\ndef in_arr():\\n    return map(int,raw_input().split())\\n\\n\\n\\ndef pr_num(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\n\\ndef pr_arr(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers\\n    # Use Ctrl+D to flush stdin.\\n    return map(int,stdin.read().split())\\n\\nrange = xrange # not for python 3.0+\\n\\n\\ndef in_arr():\\n    return stdin.readline().rstrip()\\n\\n\\n\\ndef pr_arr(arr):\\n    pr(' '.join(map(str,arr)))\\n\\n\\ndef pr_arr(arr):", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "4", "task_id": "20", "completion": "\\nn, k = map(int, raw_input().split())\\n\\nl = map(int, raw_input().split())\\n\\nl.sort()\\n\\ni = 0\\np = k - 1\\nj = 0\\nwhile i < n:\\n    if l[i] == l[j]:\\n        j += 1\\n        p -= 1\\n        p = 1\\n    else:\\n        i += 1\\n\\nwhile i < n and p <= k:\\n    print l[i], p\\n    i += 1\\n", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "4", "task_id": "21", "completion": "n=input()\\ns,t=map(int,raw_input().split())\\nt-=1\\nz=0\\nf=0\\na=[]\\nfor i in range(n):\\n    x,y,s=map(int,raw_input().split())\\n    a.append(x-x+s)\\n    t+=x+s+1\\n    f+=x+s-1\\n    if s<0:\\n        f+=1\\nprint f", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "4", "task_id": "24", "completion": "for _ in xrange(input()):\\n    n = input()\\n    ans = 0\\n    for i in xrange(1, 10):\\n        n += str(i)\\n    for i in xrange(2, 10):\\n        ans += (n - i)\\n    print ans\\n", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "4", "task_id": "25", "completion": "for _ in range(input()):\\n\\ts=raw_input()\\n\\tt=raw_input()\\n\\tl=len(s)\\n\\tl-=1\\n\\ta=l/2\\n\\tb=l%2\\n\\tc=0\\n\\tfor i in range(l):\\n\\t\\tif(s[i]>t[i]):\\n\\t\\t\\tc+=1\\n\\tif(c%2==0):\\n\\t\\tprint \"YES\"\\n\\telse:\\n\\t\\tprint \"NO\"\\n", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "4", "task_id": "26", "completion": "T = int(raw_input())\\nfor _ in xrange(T):\\n    s = raw_input()\\n    l = len(s)\\n    s1 = list(s)\\n    count = 0\\n    l1.sort()\\n    for i in xrange(l-1, -1, -1):\\n        if s[i] == '?' and s1[i+1] == s[i]:\\n            count += 1\\n        else:\\n            break\\n    print count", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "4", "task_id": "27", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nq = inp[ii]; ii += 1\\n\\nfor _ in range(q):\\n    s = inp[ii]; ii += 1\\n    t = inp[ii]; ii += 1\\n\\n    t_b = inp[ii]; ii += 1\\n\\n    for i in range(26):\\n        for j in range(26):\\n            if s[i] == t[j]:\\n                break\\n        if s[i] > t[j]:\\n            break\\n    return \"NO\"\\n\\nfor _ in range(q):\\n    s, t = inp[ii: ii + 2]\\n    print(solve(s, t))", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "4", "task_id": "28", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n, m = map(int, stdin.readline().split())\\n    p = map(int, stdin.readline().split(), repeat(10, n))\\n    ans = []\\n    for i in xrange(n):\\n        ans.append(p[i - 1] + i)\\n    ans.reverse()\\n    if n > m:\\n        print 0\\n        print 0\\n    else:\\n        for i in xrange(n):\\n            print ans[i],\\n            print\\n", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "4", "task_id": "33", "completion": "for _ in range(input()):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    a.sort()\\n    ans = a[0]\\n    for i in range(1, n):\\n        ans = max(ans, a[i] * a[i - 1])\\n    print ans\\n", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "4", "task_id": "34", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n \\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\n\\n\\n\\ndef solve():\\n    n,k = RI()\\n    a = RI()\\n    if n==1:\\n        return 0\\n    ans = 0\\n    f = [1]\\n    for i in range(n):\\n        f.append(0)\\n\\n    for i in range(n-2, -1, -1):\\n        f.append(a[i|1]^a[i])\\n\\n    ans = max(ans, f[-k]+1)\\n\\n    for", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "4", "task_id": "35", "completion": "for _ in xrange(int(raw_input())):\\n    n,m=map(int,raw_input().split())\\n    if m==0:\\n        print 0\\n    else:\\n        n^=m\\n        if n<0:\\n            print 0\\n        else:\\n            print m\\n", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "4", "task_id": "36", "completion": "for _ in range(input()):\\n    n=input()\\n    s=\"\"\\n    for i in range(n):\\n        if i%2==0:\\n            s+=i\\n        else:\\n            s+=i\\n    print s\\n", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "4", "task_id": "38", "completion": "for _ in xrange(input()):\\n    n = input()\\n    min_t = 6\\n    max_t = 10\\n    for i in xrange(3):\\n        min_t -= 6 * i\\n        if n <= 0:\\n            min_t += 1\\n        if n >= 15:\\n            max_t += 20 * i\\n        if n >= 10:\\n            max_t += 15\\n        if n >= 9:\\n            max_t += 20 * i\\n        if n >= 9:\\n            min_t += 25 * i\\n            max_t += 25 * i\\n    print min_t\\n", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "4", "task_id": "39", "completion": "import sys\\n\\ndef readints():\\n    return map(int, raw_input().split())\\n\\ndef readstr():\\n    return raw_input().split()\\n\\ndef readint():\\n    return int(raw_input())\\n\\ndef readstrs():\\n    return [int(x) for x in raw_input().split()]\\n\\ndef readint():\\n    return int(raw_input())\\n\\ndef readlist():\\n    return [int(x) for x in raw_input().split()]\\n\\n\\nfor _ in xrange(readint()):\\n    w, h = readlist()\\n    w, h = readlist()\\n    x = w\\n    y = h\\n    w, h = readlist()\\n    ans = -1\\n    w -= 1\\n    h -= 1\\n    if x < 0 or y < 0:\\n        ans = -1\\n    else:\\n        ans = min(ans, x - x)\\nprint ans\\n", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "4", "task_id": "40", "completion": "for _ in range(input()):\\n    n=input()\\n    a=[]\\n    for i in range(n):\\n        a.append(map(int,raw_input().split()))\\n    a.sort()\\n    ans=0\\n    for i in range(n-2,0,-1):\\n        for j in range(n-2,0,-1):\\n            a[i][j]-=a[j][i+1][j]\\n            if ans%2==0:\\n                ans+=1\\n    print ans\\n", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "4", "task_id": "41", "completion": "n, m = map(int, raw_input().split())\\na = raw_input()\\ns = 0\\nfor _ in range(m):\\n\\tl, r = map(int, raw_input().split())\\n\\ts += abs(l - 1)\\n\\tt = abs(r - 1)\\n\\tif s >= 2:\\n\\t\\ts += t\\n\\tprint s", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "4", "task_id": "44", "completion": "for _ in range(input()):\\n\\tc,d = map(int,raw_input().split())\\n\\tif c==0 and d==0:\\n\\t\\tprint 0\\n\\t\\tcontinue\\n\\tif c==0 and d==0:\\n\\t\\tprint -1\\n\\telif c<d:\\n\\t\\tprint c-d\\n\\telse:\\n\\t\\tif (c+d-d)%3==0 and c>d:\\n\\t\\t\\tprint d-d/3\\n\\t\\telse:\\n\\t\\t\\tprint -1", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "4", "task_id": "45", "completion": "import sys\\nimport math\\n\\ndef readints():\\n    return map(int, sys.stdin.readline().split())\\n\\n\\ndef readstring():\\n    return sys.stdin.readline().strip()\\n\\ndef readstring():\\n    return sys.stdin.readline().strip()\\n\\n\\ndef readstring():\\n    return sys.stdin.readline().strip()\\n\\ndef solve():\\n    n = readint()\\n    a = readints()\\n    for i in a:\\n        if i == 1:\\n            return -1\\n        else:\\n            return i\\n\\ndef solve():\\n    print 0 if solve() else -1\\n\\nfor _ in range(int(readints())):\\n    solve()\\n", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "4", "task_id": "46", "completion": "n=int(raw_input())\\nl=map(int,raw_input().split())\\nd={}\\nans=0\\ni=0\\nwhile i<n and d.has_key(l[i]):\\n    if l[i]<l[i+1]:\\n        ans+=1\\n    i+=1\\n    d[l[i]]=d.get(l[i],0)+1\\n    d[l[i]]=d.get(l[i],0)+1\\nprint ans\\n", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "4", "task_id": "52", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = [int(x) for x in input().split()]\\n\\n    d = {}\\n    for i in range(n):\\n        if a[i] not in d:\\n            d[a[i]] = 1\\n            d[a[i]] += 1\\n\\n    p = 1.0/n\\n    a = [p, p]\\n    for i in range(1, n):\\n        p += d[i]\\n    print p*1.0/(n+1)", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "4", "task_id": "53", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\n\\n\\nfor _ in xrange(RN()):\\n    n,k = RI()\\n    A = RI()\\n\\n    A = A[:k]\\n    arr = sorted(A)\\n    if arr[k]>=0:\\n        print \"YES\"\\n    else:\\n        print \"NO\"\\n", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "4", "task_id": "54", "completion": "import math\\nfrom math import sqrt\\nt = input()\\nfor i in range(t):\\n    n, k = map(int, raw_input().split())\\n    mod = (k + 1) / 2\\n    res = pow(2, (2 ** n) - 1) * pow(2, n - 1) + pow(2, k - 1, mod)\\n    print res\\n", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "4", "task_id": "60", "completion": "for _ in range(input()):\\n    n = input()\\n    a = map(int,raw_input().split())\\n    a.sort()\\n    ans = 0\\n    for i in range(n):\\n        ans |= a[i]\\n    print(ans)\\n", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "4", "task_id": "61", "completion": "for _ in xrange(input()):\\n    n = input()\\n    s = raw_input()\\n    cnt = []\\n    for i in xrange(n):\\n        if s[i] == '?':\\n            cnt.append('B')\\n        elif s[i] == 'R':\\n            cnt.append('R')\\n        else:\\n            cnt.append('B')\\n    print \"\".join(cnt)", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "4", "task_id": "62", "completion": "t=int(raw_input())\\nfor _ in range(t):\\n    n=int(raw_input())\\n    arr=map(int,raw_input().split())\\n    #print arr\\n    if arr[0]==1:\\n        if arr[0]==1:\\n            print \"-1\"\\n        else:\\n            print \" \".join(map(str,arr))\\n    else:\\n        print \" \".join(map(str,arr))\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "4", "task_id": "66", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    k = int(input())\\n    num = [1,2,4,5,8,10,11,14,16]\\n    print num[k-1]\\n\\n", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "4", "task_id": "67", "completion": "import sys\\n\\nfor _ in range(int(sys.stdin.readline())):\\n\\ta, b, c = map(int, sys.stdin.readline().split())\\n\\t\\n\\tif c in a or b in a or c in b or b in c:\\n\\t\\tprint c\\n\\telif a not in b:\\n\\t\\tprint -1\\n\\telse:\\n\\t\\tprint c\\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "4", "task_id": "68", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, ans = int(input()), 1\\n    while n >= 0:\\n        ans *= n\\n        n -= 1\\n    for i in range(1, n+1):\\n        if n == 1:\\n            ans += 1\\n            ans += 1\\n    out.append(str(ans))\\n    print''.join(out)\\n", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "4", "task_id": "69", "completion": "for _ in range(input()):\\n\\tn=raw_input()\\n\\tl=[]\\n\\tp=0\\n\\twhile(n!=0):\\n\\t\\tl.append(n%2)\\n\\t\\tn=n/2\\n\\tn=str(n)\\n\\tfor i in range(len(l)):\\n\\t\\tif(l[i]=='1'):\\n\\t\\t\\tp=p+1\\n\\t\\telse:\\n\\t\\t\\tp=p+1\\n\\tprint(p)", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "4", "task_id": "70", "completion": "def solve():\\n\\tt=raw_input()\\n\\tfor i in range(t):\\n\\t\\ts=raw_input()\\n\\t\\ts1=\"\"\\n\\t\\ts2=\"\"\\n\\t\\tfor x in s:\\n\\t\\t\\tif x=='a':\\n\\t\\t\\t\\ts1+=x\\n\\t\\tif s1 in s2:\\n\\t\\t\\tprint s1,s1\\n\\t\\telse:\\n\\t\\t\\tprint -1\\n\\t\\t\\treturn\\n\\tprint s1,\"\".join(s2)\\nfor i in range(int(raw_input())):\\n\\tsolve()", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "4", "task_id": "71", "completion": "from collections import Counter\\n\\ndef solution(n,k):\\n    if n == 1:\\n        return 1\\n    if k == 1:\\n        return str(n) + str(n)\\n    else:\\n        return str(n) + str(k-1) + str(n)\\n\\nfor _ in range(input()):\\n    n,k = map(int,raw_input().split())\\n    ans = solution(n,k)\\n    print ans\\n", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "4", "task_id": "72", "completion": "t = int(raw_input())\\nfor _ in range(t):\\n    n, k = map(int, raw_input().split())\\n    if k > 10:\\n        print n\\n    elif n == 1:\\n        print n\\n    elif k <= 10:\\n        print n\\n    else:\\n        if k > 10:\\n            print n\\n        else:\\n            print n\\n\\n\\n", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "4", "task_id": "73", "completion": "import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n\\tn = int(input())\\n\\tinp = [int(x) for x in input().split()]\\n\\n\\tpos = -1\\n\\tc = 0\\n\\tfor i in range(n):\\n\\t\\tif i%2 == 0:\\n\\t\\t\\tif inp[i] > inp[i+1]:\\n\\t\\t\\t\\tpos = i\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tpos = i\\n\\tif pos == -1:\\n\\t\\tprint 0\\n\\telse:\\n\\t\\twhile pos > 1:\\n\\t\\t\\tpos -= 1\\n\\t\\t\\tif inp[pos] == inp[pos+1]:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tif pos!= -1:\\n\\t\\t\\t\\tpos = pos-1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tif pos == -1:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpos = pos+1\\n\\t\\t\\tif pos!= -1:\\n\\t\\t\\t\\tpos = pos-1\\n\\t\\tif pos == -1:\\n\\t\\t\\tprint(pos)", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "4", "task_id": "74", "completion": "for _ in range(input()):\\n    a,b=map(int,raw_input().split())\\n    ans=[]\\n    if a==0 and b==0:\\n        ans.append(\"1\")\\n    elif a>0:\\n        ans.append(\"2\")\\n        a+=1\\n    elif b>0:\\n        ans.append(\"1\")\\n        b+=1\\n    else:\\n        ans.append(\"0\")\\n    print len(ans)\\n    print \" \".join(map(str, ans))", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "4", "task_id": "75", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    l = [int(x) for x in input().split()]\\n    l.sort()\\n    a = [l[0]]\\n    ans = []\\n    for i in range(n):\\n        ans.append([l[i]-1,l[i+1]-l[i+1]])\\n    ans.sort()\\n    print(min(ans))\\n", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "4", "task_id": "76", "completion": "n,m=map(int,raw_input().split())\\nprint pow(m,n-1,m-1)", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "4", "task_id": "77", "completion": "n, m = map(int, raw_input().split())\\n\\ndef factorial(n):\\n    while n > 1:\\n        n /= 2\\n    return n\\n\\ndef factorial(n):\\n    return (n * factorial(n) + factorial(n)) % m\\n\\n\\nprint factorial(n)", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "4", "task_id": "78", "completion": "t=input()\\nfor _ in xrange(t):\\n    a,b=map(int,raw_input().split())\\n    ans=b/(a+1)\\n    if(a-2>b):\\n        print a%b\\n    elif(a==b):\\n        print b%b\\n    else:\\n        print 0\\n", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "4", "task_id": "79", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\n\\ndef solve(N, k):\\n    x = []\\n    for i in xrange(1, N):\\n        x.append(0)\\n    for i in xrange(k):\\n        x.append(N[i])\\n    for i in xrange(1, N):\\n        if x[i] == 0:\\n            return 1\\n    return len(set(x)) - len(set(x)) - 1\\n\\nT = input()\\nfor _ in range(T):\\n    k = rints()\\n    n = rints()\\n    primes = []\\n    if k == 1:\\n        for i in xrange(1, n):\\n            primes.append(n[i])\\n        primes.append(n[i])\\n    print len(primes)\\n    for i in xrange(len(primes)):\\n        if n[i] == 0:\\n            print primes[i]\\n            continue\\n        primes[i] = 1\\n    print '\\n'.join", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "4", "task_id": "80", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    l=[0]*(n+1)\\n    r=[0]*(n+1)\\n    c=0\\n    for i in range(1,n+1):\\n        l[i]=s[i-1]\\n        if s[i-1]!=s[i]:\\n            r[i]=s[i-1]\\n            r[i-1]=s[i-1]+1\\n        else:\\n            c+=1\\n        if s[i-1]!=s[i]:\\n            l[i]=s[i-1]\\n            r[i]=s[i-1]\\n    for i in range(1,n+1):\\n        if s[i-1]!=s[i]:\\n            r[i]=s[i-1]\\n            break\\n        if s[i-1]!=s[i]:\\n            l[i]=s[i-1]\\n            r[i]=s[i-1", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "4", "task_id": "81", "completion": "import sys\\nfrom collections import deque\\n\\ninp = sys.stdin.read().splitlines()\\ninp = [int(x) for x in inp[0].split()]\\nout = []\\nfor _ in range(inp[1]):\\n    n,q = inp[0]\\n    s = inp[1]\\n    inp2 = inp[2]\\n    s1 = list(inp)\\n    s2.sort()\\n    d = defaultdict(list)\\n    ans = 0\\n    for i in range(n):\\n        if s[i] == '+':\\n            d[i] = 0\\n        elif s[i] == '-':\\n            d[i] += 1\\n        else:\\n            d[i] += 1\\n        d[i] = 0\\n    if sum(d) == n:\\n        out.append(1)\\n    else:\\n        out.append(2)\\n\\nprint('\\n'.join(map(str,out)))\\n", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "4", "task_id": "84", "completion": "from __future__ import division, print_function\\nfrom sys import stdin, stdout\\nfrom collections import *\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nrstr_2d = lambda n: [rints() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\\nceil1, out = lambda a, b: (a + b - 1) // b, [0] * (n + 1) // b\\nout = []\\n\\ndef solve():\\n    n, s = rints()\\n    out.append(solve())\\n\\nfor _ in range(int(input())):", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "4", "task_id": "85", "completion": "from __future__ import division\\nfrom sys import stdin, stdout\\nfrom collections import *\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nrstr_2d = lambda n: [rints() for _ in range(n)]\\nrint_2d = lambda n: [rint() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\\nout = []\\n\\nfor _ in range(int(input())):\\n    s, ans = rstr(), 0\\n    for i in range(len(s)):\\n        ans += max(min(i, s[i] - s[i + 1]) for i in range(len(s) - 1))\\n\\n    print", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "4", "task_id": "86", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    a=[[] for _ in range(n)]\\n    for x in s:\\n        a[x]+=[0]\\n    for x in range(1,n):\\n        a[x]=[0]\\n    x=raw_input()\\n    ans=0\\n    for i in a:\\n        ans+=a[i-1][0]\\n    if n==1:\\n        ans+=2**(n-1)\\n    else:\\n        ans+=1**n\\n    print ans", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "4", "task_id": "87", "completion": "for _ in xrange(input()):\\n    n,m=[int(i) for i in raw_input().split()]\\n    A=[int(i) for i in raw_input().split()]\\n    A.sort()\\n    B=[0]*(m+1)\\n    c=0\\n    for i in xrange(1,m+1):\\n        c+=A[i]\\n        B[i]=0\\n    for i in xrange(1,n+1):\\n        if B[i-1]>A[i]:\\n            C[i]=C[i-1]+A[i-1]\\n            C[i]=0\\n            c+=1\\n    print C[n-1]+sum(A[:n-1])\\n", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "4", "task_id": "88", "completion": "import atexit, io, sys\\nbuffer = io.BytesIO() \\nsys.stdout = buffer\\n@atexit.register \\ndef write(): sys.__stdout__.write(buffer.getvalue())   \\nfor _ in range(input()):\\n    n,m=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    a.sort()\\n    if a[n-1]==a[m]:\\n        print 0\\n    elif a[0]==a[n-1]:\\n        print 0\\n    else:\\n        m=-1\\n        for i in range(n):\\n            if a[i]!=a[i+1]:\\n                if a[i]<a[i+m-1]:\\n                    m=i+m-1\\n                    else:\\n                        print 0\\n                    continue\\n        print m\\n", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "4", "task_id": "93", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nfor _ in range(ii):\\n    a,b = inp[ii]; ii += 1\\n    t = [a^b,0]\\n    s = [0] * (2**b-1)\\n    for i in range(len(t)):\\n        if s[i]==0:\\n            t[i] = 1\\n        elif s[i]==1:\\n            t[i] = 1\\n    print (t[0]*(2**t[1]-1))", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "4", "task_id": "94", "completion": "def gcd(a, b):\\n    if b == 0:\\n        return a\\n    return gcd(b, a % b)\\n\\n\\nt = int(raw_input())\\nfor _ in range(t):\\n    n = int(raw_input())\\n    ans = gcd(n, 2)\\n    if n % 2!= 0:\\n        ans = (n / 2) + 1\\n    print ans", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "4", "task_id": "95", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    s, n = [int(x) for x in input().split()]\\n    f = 0\\n    for i in range(n):\\n        f = f | (s % 10)\\n        if i == 1:\\n            f = 1\\n    print(' '.join([str(i) for i in f]))", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "4", "task_id": "98", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nfor _ in range(ii):\\n    n = inp[ii]; ii += 1\\n    s = inp[ii: ii + n]; ii += n\\n    if 'a' not in s or 'b' not in s:\\n        print -1, -1\\n        sys.exit(0)\\n    a = s[ii: ii + n]; ii += n\\n    b = s[ii: ii + n]; ii += n\\n    print a + 1, b + 1\\n", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "4", "task_id": "99", "completion": "for _ in xrange(input()):\\n    n = input()\\n    s = raw_input()\\n    if s[0] == 1:\\n        print \"NO\"\\n        continue\\n    l = []\\n    for i in xrange(n):\\n        if s[i] == 1:\\n            l.append(s[i])\\n        else:\\n            l.append(s[i])\\n    for i in xrange(n):\\n        if s[i] == -1:\\n            l.append(s[i])\\n        else:\\n            print \"YES\"\\n            print \"\\n\".join(l)\\n            for j in xrange(n):\\n                print \"+\"\\n                print \"-\"\\n        print \"-\"", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "4", "task_id": "100", "completion": "from __future__ import division, print_function\\nimport sys\\n\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRA = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\ndef solve():\\n    n = RN()\\n    A = RI()\\n    res = [0]\\n    for i in xrange(n):\\n        res[i] += A[i]\\n    res[n-1] %= 998244353\\n    ans = 0\\n    for i in xrange(n-1, -1, -1):\\n        ans += (A[i]*(A[i])%998244353)", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "4", "task_id": "101", "completion": "for _ in xrange(int(raw_input())):\\n    n, m, k = map(int, raw_input().split())\\n    x = map(int, raw_input().split())\\n    y = map(int, raw_input().split())\\n    #x = [x[i], x[i+1] for i in xrange(n)]\\n    #y = [x[i], y[i+1] for i in xrange(m)]\\n    ans = 0\\n    for i in xrange(k):\\n        x, y = map(int, raw_input().split())\\n        ans += abs(x-x[i])*(y-y[i])\\n    print ans\\n", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "4", "task_id": "109", "completion": "from collections import Counter\\nt = int(raw_input())\\nfor _ in xrange(t):\\n    n = int(raw_input())\\n    s = raw_input()\\n    count = 0\\n    for i in xrange(n):\\n        if s[i]!= \"0\":\\n            if i!= n-1:\\n                count += 1\\n            else:\\n                count -= 1\\n            if s[i]!= \"0\":\\n                count += 1\\n    print count", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "4", "task_id": "110", "completion": "# cook your code here\\nt = int(raw_input())\\nfor _ in range(t):\\n\\tn = int(raw_input())\\n\\td = {}\\n\\tfor i in range(n):\\n\\t\\ts = int(raw_input())\\n\\t\\tl = map(int, raw_input().split())\\n\\t\\td[s] = 1\\n\\ta = []\\n\\tfor i in d:\\n\\t\\td[i] = 1\\n\\t\\tfor j in d[i]:\\n\\t\\t\\td[j] += 1\\n\\tc = 0\\n\\tfor i in d.values():\\n\\t\\tif c>1:\\n\\t\\t\\tprint -1\\n\\t\\t\\tcontinue\\n\\t\\tfor j in d.keys():\\n\\t\\t\\tc += d[j]\\n\\tif c==1:\\n\\t\\tprint n-2\\n\\telse:\\n\\t\\tprint n-2", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "4", "task_id": "111", "completion": "for _ in range(input()):\\n    n = input()\\n    if n == 1:\\n        for i in range(n):\\n            print '('\\n            print ')'\\n        else:\\n            for i in range(n):\\n                print '(' + '(' * (2 * (i + 1)) + ')'\\n            print ')' * (2 * (i + 1)) + ')'\\n", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "4", "task_id": "112", "completion": "t = int(raw_input())\\nfor _ in xrange(t):\\n    a, b, c, m = map(int, raw_input().split())\\n    if m == 0:\\n        if a == 'A':\\n            if b == 'B':\\n                print \"NO\"\\n            elif c == 'C':\\n                print \"NO\"\\n            elif a == 'A':\\n                print \"NO\"\\n            else:\\n                print \"YES\"\\n    elif b == 'B':\\n        if c == 'C':\\n            if a!= 'A':\\n                print \"YES\"\\n            else:\\n                print \"NO\"", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "4", "task_id": "113", "completion": "n = int(raw_input())\\na = map(int, raw_input().split())\\na.sort()\\nm = int(raw_input())\\nfor i in xrange(m):\\n\\ta[i] -= a[i]\\n\\tx, y = map(int, raw_input().split())\\n\\tb = a[0]\\n\\tc = a[1] - x\\n\\twhile b > 0:\\n\\t\\tif a[b] >= y:\\n\\t\\t\\tb -= 1\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\tprint c", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "4", "task_id": "114", "completion": "from sys import stdin,stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = stdin.readline\\npr = stdout.write\\nmod=10**9+7\\n\\n\\ndef ni():\\n    return int(raw_input())\\n\\n\\ndef li():\\n    return list(raw_input())\\n\\n\\ndef pn(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\ndef pa(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers\\n    # Use Ctrl+D to flush stdin.\\n    return map(int,stdin.read().split())\\n\\nrange = xrange # not for python 3.0+\\n\\n# main code\\n\\n# main code\\n\\n\\nn=ni()\\na=[0]*n\\nb=[0]*n\\nfor _ in xrange(n):\\n    a[i]=li()\\n    b[i]=li()\\nm=ni()\\nfor i in range(", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "5", "task_id": "4", "completion": "for _ in range(input()):\\n\\tn = input()\\n\\tprint n,n//2-n%2", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "5", "task_id": "5", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    a=s.count('1')\\n    b=s.count('0')\\n    d=0\\n    for i in range(n):\\n        if i==0:\\n            d+=1\\n        else:\\n            d+=1\\n    print min(d,max(a[i],b[i]))", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "5", "task_id": "6", "completion": "import sys\\n\\nn, m = [int(x) for x in sys.stdin.readline().split()]\\n\\nd = [0] * n\\np = [0] * n\\nfor i in xrange(m):\\n    u, v = [int(x) for x in sys.stdin.readline().split()]\\n    d[u - 1] += 1\\n    p[v - 1] -= 1\\n\\nQ = int(sys.stdin.readline())\\nfor _ in xrange(Q):\\n    u, v = [int(x) for x in sys.stdin.readline().split()]\\n    u -= 1\\n    v -= 1\\n    d[u - 1] += v\\n    if d[v - 1] > d[u - 1]:\\n        p[v - 1] -= d[u - 1]\\n    else:\\n        p[u - 1] += d[v - 1]\\n    for i in xrange(n):\\n        if d[i] > d[i]:\\n            d[i] -= d[i]\\n            p[i] -= d[i]\\n", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "5", "task_id": "7", "completion": "from __future__ import division\\nfrom sys import stdin, stdout\\nfrom fractions import gcd\\nfrom math import factorial, ceil, sqrt, atan2, log, pi, e, asin,acos, cos, sin, floor\\nfrom itertools import *\\nfrom fractions import Fraction\\nimport string\\nimport copy\\nimport random\\nimport bisect\\nfrom decimal import *\\nfrom collections import deque\\nfrom sys import *\\ndigs = string.digits + string.digits + string.ascii_letters\\n\\ndef id_generator(size=20, chars=string.digits):\\n    stdout.write(str(size)+'\\n')\\n    return ''.join(str(size) for _ in range(size))\\n \\ninput = stdin.readline\\npr = stdout.write\\n\\n\\nfor _ in range(int(input())):\\n    n=int(input())\\n    a=list(map(int,input().split()))\\n    c=Counter(a)\\n    print(c.most_common())[1]\\n", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "5", "task_id": "8", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n = int(stdin.readline())\\n    b = n/2\\n    ans = []\\n    c1 = n//2\\n    ans.append(b)\\n    ans.append(c1)\\n    c2 = n//2\\n    for i in range(c1):\\n        ans.append(c1)\\n        if i+1 < c2:\\n            ans.append(i+1)\\n    print(' '.join([str(x) for x in ans]))\\n", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "5", "task_id": "9", "completion": "from collections import Counter\\n\\nT = input()\\nfor t in range(T) :\\n\\ts = raw_input()\\n\\tc = Counter(s)\\n\\tprint max(c.values())", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "5", "task_id": "10", "completion": "t = int(raw_input())\\n\\nfor _ in range(t):\\n    n, k = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n    a = [0]\\n    max1 = -1\\n    ans = []\\n    for i in a:\\n        # print i\\n        if max1 < i:\\n            max1 = i\\n            ans.append(i)\\n        else:\\n            if k % 2 == 0:\\n                ans.append(1)\\n                k = k / 2\\n            else:\\n                ans.append(i)\\n    print \" \".join(map(str, ans))", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "5", "task_id": "11", "completion": "from __future__ import division,print_function\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor _ in range(int(le.pop())):\\n    n = int(le.pop())\\n    a = []\\n    for i in range(n):\\n        a.append(le.pop())\\n    ans = 0\\n    for i in range(n):\\n        c = 0\\n        for x in a:\\n            if (x == x):\\n                c += 1\\n                ans = max(ans, i - len(x))\\n    print(ans)\\n", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "5", "task_id": "12", "completion": "for _ in range(input()):\\n    n,m,k=[int(i) for i in raw_input().split()]\\n    if k==0 or (n*m-1)%2==0:\\n        print 'YES'\\n    else:\\n        print 'NO'", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "5", "task_id": "16", "completion": "t=input()\\nfor i in range(t):\\n    n=input()\\n    s=raw_input()\\n    c=sorted(s)\\n    m=0\\n    for j in range(n):\\n        if s[j]!=c[j]:\\n            m+=1\\n            c[j]=0\\n    print(m)", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "5", "task_id": "17", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nt = inp[ii]; ii += 1\\nfor _ in range(t):\\n    n = inp[ii]; ii += 1\\n    ls = [None] * 5\\n    for i in range(n):\\n        ls[i] = inp[ii]\\n\\n    s = set()\\n    for i in range(n):\\n        s.add(list(ls[i]))\\n\\n    for i in range(n):\\n        s.add(list(ls[i]))\\n\\n    res = [0] * n\\n    for i in range(n):\\n        for j in range(n):\\n            if l[i][j] <= i * 5:\\n                res[i] = j\\n                res[i] = n - i * 5\\n                break\\n        res[i] = n\\n    if len(res) == 3:\\n        print -1\\n        continue\\n    print res[n-1]\\n", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "5", "task_id": "18", "completion": "import atexit\\nimport io\\nimport sys\\n\\nbuff = io.BytesIO()\\nsys.stdout = buff\\n\\n\\n@atexit.register\\ndef write():\\n    sys.__stdout__.write(buff.getvalue())\\n\\nfor _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    ans=0\\n    for i in range(k):\\n        x,y=map(int,raw_input().split())\\n        for i in range(n):\\n            x-=1\\n            y-=1\\n    for i in range(k):\\n        ans+=min(i,2*n-i)\\n    print ans", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "5", "task_id": "19", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = [int(x) for x in input().split()]\\n    A.sort()\\n    if sum(A) == n:\\n        print 'YES'\\n        continue\\n    last = None\\n    for i in range(n):\\n        if A[i] < last:\\n            last = A[i]\\n            last = A[i]\\n    print 'NO'\\n\\n", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "5", "task_id": "20", "completion": "from sys import stdin, stdout\\nfrom itertools import repeat\\ndef main():\\n    n, k = map(int, stdin.readline().split())\\n    c = map(int, stdin.readline().split(), repeat(10, n))\\n    c.sort()\\n    t = [0] * k\\n    for i in xrange(1, k):\\n        for j in xrange(i, k + 1):\\n            t[j] = i\\n    for i in xrange(n, k + 1):\\n        if c[i] == c[j]:\\n            print i, j\\n            exit()\\n", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "5", "task_id": "21", "completion": "n = input()\\na = [[0] * (n + 1)]\\nfor i in range(n):\\n    x, y, s = map(int, raw_input().split())\\n    a[x][y] = s\\n    a[x + 1][y] = 1\\nfor x in range(n):\\n    s += a[x][y]\\ns = 1\\nt = 0\\nfor x in range(n):\\n    if a[x][y] == 1:\\n        t += a[x][y] - t\\n        t %= 998244353\\nprint t", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "5", "task_id": "24", "completion": "for _ in range(input()):\\n\\tn=input()\\n\\tl=len(str(n))\\n\\tprint l-len(str(n))\\n", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "5", "task_id": "25", "completion": "from __future__ import division,print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor u in range(int(le.pop())):\\n    a = list(le.pop())\\n    b = list(le.pop())\\n    if a[0] == b[0]:\\n        af.append(\"YES\")\\n    else:\\n        af.append(\"NO\")\\nfor u in range(int(le.pop())):\\n    if len(a) == len(b) and a.count(a[-1]) > 1:\\n        print(\"NO\")\\n    else:\\n        print(\"YES\")", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "5", "task_id": "26", "completion": "for _ in range(input()):\\n    n=raw_input()\\n    for i in n:\\n        a=s.count('?')\\n        if a>0:\\n            print i+(len(s)-1)*10\\n            continue\\n        a=s.count('?')\\n        if a>0:\\n            print i+(len(s)-1)*10\\n            continue\\n        a=s.count('?')\\n        print i+(len(s)-1)*10", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "5", "task_id": "27", "completion": "q = input()\\nfor i in range(q):\\n    s = raw_input().strip()\\n    t = raw_input().strip()\\n    b = ''.join(s)\\n    t_pos = 0\\n    for j in range(len(t)):\\n        if s[j]!= t[j]:\\n            b += s[j]\\n        else:\\n            t_pos = j\\n    flag = False\\n    if s == t_pos:\\n        print \"YES\"\\n    else:\\n        print \"NO\"\\n\\n", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "5", "task_id": "28", "completion": "# http://codeforces.com/problemset/problem/591/A\\n\\ndef solve(N, M):\\n    if (N-1) < M:\\n        if N > 1:\\n            return 1, N-1\\n    else:\\n        return 0\\n\\nif __name__ == '__main__':\\n    t = int(raw_input())\\n    for _ in range(0, t):\\n        N, M = map(int, raw_input().split())\\n        P = map(int, raw_input().split())\\n        res = []\\n        for i in range(N):\\n            for j in range(M):\\n                if p[j] == P[i]:\\n                    res.append(str(i))\\n                    continue\\n                res.append(str(N-j))\\n                res.append(str(N-j))\\n        print(len(res))\\n        for _ in range(0, T):\\n            solve(N, M)\\n\\n", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "5", "task_id": "33", "completion": "t = int(raw_input())\\n\\nfor _ in range(t):\\n\\tn = int(raw_input())\\n\\ta = map(int, raw_input().split())\\n\\tl = []\\n\\tfor i in range(n):\\n\\t\\tl.append(a[i])\\n\\t\\n\\tfor i in range(n):\\n\\t\\tl.append(max(l[-1], a[i] + a[i]))\\n\\tprint l[-1]", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "5", "task_id": "34", "completion": "from __future__ import division, print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor _ in range(int(le.pop())):\\n    n,k = map(int,le.pop().split())\\n    a = map(int,le.pop().split())\\n    mx = [0]*n\\n    for i in a:\\n        if i&1:\\n            mx[0] += 1\\n            mx[1] += 1\\n        else:\\n            mx[0] += 1\\n    for i in a:\\n        mx[i] += 1\\n    for i in mx:\\n        print(i)", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "5", "task_id": "35", "completion": "for _ in range(input()):\\n\\tn, m = map(int, raw_input().split())\\n\\tif n < m:\\n\\t\\tprint m\\n\\telse:\\n\\t\\tl = n\\n\\t\\tr = m - n\\n\\t\\ti = 1\\n\\t\\tj = m - 1\\n\\t\\twhile i < l:\\n\\t\\t\\tif j == 0:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tr -= i\\n\\t\\tprint r\\n", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "5", "task_id": "36", "completion": "def solve():\\n    n = input()\\n    for _ in xrange(n):\\n        s = ''\\n        s += chr(ord('a') + 32)\\n        s += s[::-1]\\n    print s\\n\\nt = input()\\nfor _ in xrange(t):\\n    solve()", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "5", "task_id": "38", "completion": "from __future__ import division, print_function\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor k in range(int(le.pop())):\\n    n = int(le.pop())\\n    if n < 3:\\n        af.append(n * 5)\\n    else:\\n        af.append(n * 2)\\n    af.sort()\\n\\nfor i in range(int(le.pop())):\\n    print(min(n - 3 * sum(map(int,le.pop().split())))", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "5", "task_id": "39", "completion": "for _ in range(input()):\\n    W, H = map(int, raw_input().split())\\n    x1, y1, x2, y2 = map(int, raw_input().split())\\n    w, h = map(int, raw_input().split())\\n    a = abs(x2 - x1)\\n    b = abs(y2 - y1)\\n    if (w, h) == (w, h):\\n        print -1\\n    else:\\n        print a * h\\n", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "5", "task_id": "40", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\n\\n\\nfor _ in xrange(RN()):\\n    m = RN()\\n    a = [RI() for _ in xrange(m)]\\n\\n    a.sort()\\n    c = 0\\n    for i in xrange(len(a)):\\n        c += a[i][1]\\n    if c>2:\\n        print c\\n    else:\\n        print max(c,c)\\n", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "5", "task_id": "41", "completion": "n,m=map(int,raw_input().split())\\ns=raw_input()\\ni=0\\nwhile(i<n):\\n    l=len(s)\\n    r=len(s)-1\\n    while(r>=2):\\n        s=s[l:r]\\n        if(r==l):\\n            l-=1\\n            r-=1\\n        i+=1\\n    print i", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "5", "task_id": "44", "completion": "from sys import stdin, stdout\\nfrom collections import *\\nfrom operator import mul\\nfrom functools import reduce\\nfrom copy import copy\\nfrom bisect import *\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nrstr_2d = lambda n: [rstr() for _ in range(n)]\\nrint_2d = lambda n: [rint() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\\nout = []\\nfor _ in range(int(input())):\\n    c, d = rints()\\n    ans = 0\\n    c -= min(c, d)\\n    if d == 0:\\n        if a == 0:\\n            print 0\\n        else:\\n", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "5", "task_id": "45", "completion": "for _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    print n-max(a)+min(a)%2-min(a)%2", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "5", "task_id": "46", "completion": "from sys import stdin\\nn = int(stdin.readline())\\na = [int(x) for x in stdin.readline().split()]\\n\\ns = 0\\np = 0\\nfor i in a:\\n    if i%2 == 0:\\n        s += 1\\n    else:\\n        s -= 1\\n    if s%2 == 0:\\n        p += 1\\n\\nprint s\\n", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "5", "task_id": "52", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n = RN()\\n    a = RI()\\n    m = sum(a)\\n\\n    ans = -float(\"inf\")\\n    for i in xrange(n-1):\\n        m = (m+i)/2\\n        ans = max(ans,m*a[i])\\n        m = min(m,a[i+1])\\n    print \"%.6f\" % ans", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "5", "task_id": "53", "completion": "t = int(input())\\n\\nwhile(t):\\n\\tt-=1\\n\\tn, k = map(int, raw_input().split())\\n\\tl = list(map(int, raw_input().split()))\\n\\ta = l[::-1]\\n\\tb = []\\n\\tfor i in range(n):\\n\\t\\tif l[i]<0:\\n\\t\\t\\tb.append(i)\\n\\t\\n\\tflag = True\\n\\tfor i in range(k-1):\\n\\t\\tif b[i]>0:\\n\\t\\t\\tflag = False\\n\\t\\t\\tbreak\\n\\tif(flag==False):\\n\\t\\tprint(\"NO\")\\n\\telse:\\n\\t\\tprint(\"YES\")", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "5", "task_id": "54", "completion": "from sys import stdin,stdout,setrecursionlimit,maxint,exit\\n#setrecursionlimit(2*10**5)\\ndef listInput():\\n return map(long,stdin.readline().split())\\ndef printBS(li):\\n for i in xrange(len(li)-1):\\n  stdout.write(\"%d \"%li[i])\\n stdout.write(\"%d\\n\"%li[-1])\\ndef sin():\\n return stdin.readline().rstrip()\\ndef sin():\\n return stdin.readline().rstrip()\\ndef se(li):\\n for i in xrange(len(li)-1):\\n  stdout.write(\"%d\\n\"%li[-1])\\n stdout.write(\"%d\\n\"%li[-1])\\nt=input()\\nfor _ in xrange(t):\\n n,k=li()\\n print (2**k+1)%1000000007\\n", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "5", "task_id": "60", "completion": "for _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    a.sort()\\n    i=0\\n    if a[0]!=1:\\n        print 0\\n        continue\\n    for j in range(n):\\n        if a[j]&1==a[j+1]:\\n            print j-i\\n            continue\\n        else:\\n            print a[j]\\n            break\\n", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "5", "task_id": "61", "completion": "t = input()\\nfor _ in xrange(t):\\n    n = input()\\n    s = raw_input()\\n    ans = 0\\n    for i in xrange(n):\\n        if s[i] == '?':\\n            if s[i] == '?':\\n                ans += 1\\n            elif s[i] == 'R':\\n                ans += 1\\n            elif s[i] == 'B':\\n                ans += 1\\n    for i in xrange(n):\\n        if s[i] == '?' or s[i] == '?':\\n            if s[i] == 'B':\\n                ans += 1\\n            else:\\n                ans += 1\\n    print ans", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "5", "task_id": "62", "completion": "for _ in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    a = map(int,raw_input().split())\\n    a.append(n)\\n    s = [0]\\n    for i in xrange(1,n+1):\\n        if a[i] == 1:\\n            s.append(i)\\n            s.append(i)\\n    if len(s) == 0:\\n        print -1\\n    else:\\n        l = [0]\\n        i = 0\\n        while l[-1] == 0:\\n            l.append(i)\\n            i = i+1\\n            l.append(n-1)\\n        print \" \".join(map(str,l))\\n\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "5", "task_id": "66", "completion": "t=input()\\nwhile t>0:\\n    t-=1\\n    n=input()\\n    a=\"\"\\n    for i in range(1,n):\\n        a+=str(int(raw_input())%3)\\n    print a[n-1]", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "5", "task_id": "67", "completion": "for _ in range(input()):\\n    a,b,c=map(int,raw_input().split())\\n    if a<=c and b<=c:\\n        print -1\\n        continue\\n    if a==c and b>=c:\\n        print b+1\\n        continue\\n    if c==b and c>=a:\\n        print -1\\n        continue\\n    if c%b!=0 and b<=c:\\n        print -1\\n    else:\\n        print b", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "5", "task_id": "68", "completion": "for _ in range(input()):\\n    n = input()\\n    r = 1\\n    c = 1\\n    while r <= n:\\n        r *= 2\\n        c += 1\\n    print \" \".join(str(r) + \" \" + str(c))\\n    c += 1", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "5", "task_id": "69", "completion": "import sys\\n\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    ans = 0\\n    for i in range(0,10):\\n        l = int(input())\\n        l = l - 1\\n        if l == 0:\\n            continue\\n        for j in range(0,10):\\n            if l%2 == 0:\\n                ans += 2\\n                l = 0\\n            else:\\n                l = 2**(l/2)\\n        ans += 1\\n    print ans", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "5", "task_id": "70", "completion": "#!/usr/bin/python2.7\\n\\nfrom collections import deque\\n\\nif __name__ == '__main__':\\n    T = int(raw_input())\\n\\n    for t in range(T):\\n        s = list(raw_input())\\n        idx = deque()\\n        for c in s:\\n            if idx[0] == 'a':\\n                idx.append(c)\\n                idx.append(c)\\n            else:\\n                idx.append(c)\\n            idx.append(c)\\n        idx.append(len(idx))\\n\\n        s.reverse()\\n        for i in range(len(s)):\\n            print -1,\\n            print\\n        print ''.join(s)\\n", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "5", "task_id": "71", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n, k = map(int, stdin.readline().split())\\n    if k==1:\\n        print n\\n        continue\\n    for i in xrange(k-1):\\n        num = str(n%10)\\n        if num[0:k]=='1':\\n            num[0:k]='0'\\n        else:\\n            num[0:k]='0'\\n            num[1:k]='1'\\n        n=num[k:]\\n    print n", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "5", "task_id": "72", "completion": "from sys import stdin\\nimport math\\nt = int(stdin.readline())\\nfor i in range(t):\\n    n, k = [int(x) for x in stdin.readline().split()]\\n    print(''.join(['%d' % i for i in str(n)]) + n % 10 for i in range(k)])", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "5", "task_id": "73", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n = int(stdin.readline())\\n    a = map(int, stdin.readline().split())\\n    a.append(0)\\n    p = n - 1\\n    c = 0\\n    while True:\\n        if a[p] > a[p-1]:\\n            c += 1\\n            p = 0\\n            break\\n        else:\\n            p += 1\\n    print c", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "5", "task_id": "74", "completion": "from __future__ import division\\nimport os\\nimport sys\\nfrom atexit import register\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nout = []\\nfor _ in range(int(input())):\\n    a,b = [int(x) for x in input().split(' ')]\\n    ans = []\\n    for i in range(min(a,b),max(a,b)):\\n        ans.append(i)\\n    out.append(' '.join(map(str,ans)))\\nprint('\\n'.join(out))", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "5", "task_id": "75", "completion": "T = input()\\nfor t in range(T) :\\n    N = input()\\n    arr = []\\n    for n in range(N) :\\n        l = map(int, raw_input().split())\\n        arr.append(l[0])\\n    arr.sort()\\n    ans = 0\\n    for n in range(N) :\\n        ans = max(ans, arr[n])\\n    print ans", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "5", "task_id": "76", "completion": "from __future__ import division\\nfrom sys import stdin, stdout\\nfrom math import factorial, ceil, sqrt\\n# reads a line of input and converts into a list of ints\\n# 1 1 3 => [1, 1, 3]\\ndef rl():\\n    return [int(i) for i in stdin.readline().split()]\\n\\n# reads n lines of input (if n defined) and returns a list of strings\\n# where each element is a line in the input\\n# abc\\n# abcdef\\n# => ['abc', 'abcdef']\\n# if n not defined, read first line to get number of lines\\n# 2\\n# abc\\n# abcdef\\n# => ['abc', 'abcdef']\\ndef rm(n=None):\\n    if n is None:\\n        n = input()\\n    return [stdin.readline() for i in range(n)]\\n\\n# same as rm, except converts each line to a list of ints like rl\\ndef rlm(n=None):\\n    if n is None:\\n        n = input()\\n    return [rl() for i in range(n)]\\n\\n# same as rm, except converts each line", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "5", "task_id": "77", "completion": "n,m=map(int,raw_input().split())\\nprint n-(n-1)/2\\n", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "5", "task_id": "78", "completion": "for _ in range(input()):\\n    l,r=map(int,raw_input().split())\\n    print r/(l-1)", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "5", "task_id": "79", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    k = int(input())\\n    n = input()\\n    arr = [1]*k\\n    for x in range(1,k):\\n        if arr[x] == 0:\\n            arr[x-1] = 0\\n            arr[x] = 0\\n    s = input()\\n    while len(arr) > 0:\\n        for x in range(len(arr)-1,-1,-1):\\n            if arr[x] == 0:\\n                s -= 1\\n                break\\n        else:\\n            s += 1\\n    print s\\n    print '\\n'.join(map(str, arr))", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "5", "task_id": "80", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    a=[]\\n    for i in range(n):\\n        a.append(int(s[i]))\\n    for i in range(n):\\n        b=a.pop()\\n        for j in range(i,n):\\n            if s[j]=='1':\\n                print a[i],b[j],a[j]\\n                break\\n    if a[-1]==0:\\n        for i in range(n):\\n            print a[i],b[i],a[j]\\n            break", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "5", "task_id": "81", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n,q = RI()\\n    s = RI()\\n    ans = 0\\n    sum_1 = 0\\n    for i in xrange(q):\\n        l,r = RI()\\n        if s[r] == '+':\\n            ans+=1\\n        else:\\n            if s[r] == '-':\\n                l-=1\\n            else:\\n                r-=1\\n    print ans", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "5", "task_id": "84", "completion": "from sys import stdin, stdout  \\n  \\ndef main(): \\n    t = int(stdin.readline()) \\n    for _ in xrange(t): \\n        n, s = map(int, stdin.readline().split()) \\n        for i in xrange(n/2): \\n            if n%i==0: \\n                if s-n%i>=0: \\n                    print i\\n                    continue \\n            else: \\n                stdout.write(str(s-n%i))\\n                else: \\n                    stdout.write(str(s-n%i))", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "5", "task_id": "85", "completion": "import atexit\\nimport io\\nimport sys\\nimport math\\nfrom collections import defaultdict\\n\\n_INPUT_LINES = sys.stdin.read().splitlines()\\nraw_input = iter(_INPUT_LINES).next\\n_OUTPUT_BUFFER = io.BytesIO()\\nsys.stdout = _OUTPUT_BUFFER\\n\\n@atexit.register\\ndef write():\\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\\n\\ndef f(x):\\n    x = int(x)\\n    if x % 2:\\n        print 0\\n    else:\\n        x = int(x / 2)\\n        print 1\\n\\n\\nT = int(raw_input())\\n\\nfor t in range(T):\\n    f(raw_input())", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "5", "task_id": "86", "completion": "from __future__ import print_function, division\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\nimport random\\n\\n# sys.stdin = open('input')\\n\\ndef solve():\\n    n = int(stdin.readline())\\n    for i in xrange(n):\\n        a = stdin.readline().strip()\\n        b = stdin.readline().strip()\\n        #print(a)\\n        #print(b)\\n        s = 1\\n        for j in xrange(n-1):\\n            s *= 2\\n            #print(s)\\n            if a[j] == '0':\\n                s *= 2\\n        s /= 2\\n        s /= 2\\n    return s\\n\\n\\nfor _ in xrange(int(input())):\\n    ans = solve()\\n    print(ans)", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "5", "task_id": "87", "completion": "for _ in range(input()):\\n    n,m = map(int,raw_input().split())\\n    a = map(int,raw_input().split())\\n    a.sort()\\n    ans = 0\\n    i = 0\\n    while i<m:\\n        if a[i] < a[i-1]:\\n            ans+=i\\n            i+=1\\n            ans+=1\\n            break\\n        i+=1\\n    print ans\\n", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "5", "task_id": "88", "completion": "T = input()\\n\\nfor _ in range(T):\\n    n, m = map(int, raw_input().split())\\n    A = map(int, raw_input().split())\\n\\n    ans = [0] * n\\n    for i in range(1, n + 1):\\n        for j in range(m + 1):\\n            if A[i - 1] < A[i]:\\n                ans[j] = 0\\n                break\\n        for i in range(1, m + 1):\\n            ans[i - 1] += A[i - 1]\\n\\n    print min(ans)", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "5", "task_id": "93", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef solve(a, b):\\n    return 2 ** (b - a)\\ndef main():\\n    for _ in range(int(input())):\\n        a, b = map(int, stdin.readline().split())\\n        print(solve(a, b))\\n\\nmain()", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "5", "task_id": "94", "completion": "for _ in range(input()):\\n    n=input()\\n    f=[0]\\n    i=0\\n    while f[i]<=n:\\n        f.append(f[-1]-i)\\n        i+=1\\n    print sum([1+i*(n-i)/(i+1)*(i+1)*(n-i)for i in range(len(f)-1)])", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "5", "task_id": "95", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(a, b):\\n   while(b):\\n       a, b = b, a%b\\n   return a\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    kase = inp()\\n    for _ in range(kase):\\n        s, n = inp()\\n        if n > 10:\\n            print '1 '+str(s)\\n            continue\\n        if n == 1:\\n            print '1 '+str(s)\\n            continue\\n        print\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "5", "task_id": "98", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    l,r=[],[]\\n    for i in range(n):\\n        if s[i]=='a':\\n            l.append(i+1)\\n        else:\\n            r.append(i+1)\\n    for i in range(1,n):\\n        if s[i]=='b':\\n            l.append(i)\\n    if len(l)==0:\\n        print -1,-1\\n    else:\\n        print l[0],r[0]", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "5", "task_id": "99", "completion": "n=input()\\nfor i in range(n):\\n\\ta=input()\\n\\tb=raw_input()\\n\\ta=set(a)\\n\\tif a==2:\\n\\t\\tprint \"YES\"\\n\\t\\tfor j in range(a):\\n\\t\\t\\tif b.count('X')==a.count('+'):\\n\\t\\t\\t\\tprint \"++\"\\n\\t\\t\\t\\tfor k in range(a.count('X')):\\n\\t\\t\\t\\t\\tprint \"-\"\\n\\t\\t\\t\\t\\tprint \"-\"\\n\\t\\t\\t\\tprint \"\"\\n\\t\\t\\t\\tprint \"+\"\\n\\t\\tfor j in range(a.count('X')):\\n\\t\\t\\tif b.count('='):\\n\\t\\t\\t\\tprint \"-\"\\n\\t\\t\\t\\tprint \"-\"\\n\\t\\t\\t\\tprint \"=\"\\n\\t\\telse:\\n\\t\\t\\tprint \"NO\"", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "5", "task_id": "100", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n# n, k = map(int, raw_input().split())\\n# da = map(int, raw_input().split())\\n# db = map(int, raw_input().split())\\n# db = map(int, raw_input().split())\\n\\ndef my_sort(arr):\\n    k = max(arr)\\n    m = 0\\n    res = [0 for _ in xrange(k)]\\n    for i in xrange(k):\\n        if arr[i]!= i:\\n            res[i] += 1\\n            m += 1\\n        else:\\n            break\\n    return res\\n\\n\\ndef my_sort(arr):\\n    arr = []\\n    for i in xrange(k):\\n        arr.append(arr[i])\\n    arr.sort(reverse = True)\\n    res = [0]\\n    for i in xrange(k):\\n        res.append(res[-i - 1] + arr[i])\\n    for i", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "5", "task_id": "101", "completion": "t = int(raw_input())\\nfor i in xrange(t):\\n    n,m,k = map(int,raw_input().split())\\n    x = map(int,raw_input().split())\\n    y = map(int,raw_input().split())\\n    dx = [-1] * n\\n    dy = [-1] * m\\n    for j in xrange(k):\\n        x[j],y[j] = map(int,raw_input().split())\\n        dx[j] = x[j]\\n    ans = 0\\n    for i in xrange(m):\\n        for j in xrange(n):\\n            x[i] = (x[i],y[j])\\n            ans += dx[j]\\n            dx[j] = (y[j],x[i])\\n    print ans", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "5", "task_id": "109", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    n-=1\\n    if s.count('0')>n:\\n        print n\\n    else:\\n        if s.count('0')==n:\\n            print n\\n        else:\\n            print n-(n-1)\\n", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "5", "task_id": "110", "completion": "for _ in range(input()):\\n    n = input()\\n    l = [map(int, raw_input().split()) for _ in range(n)]\\n    a = [1] * n\\n    a[0] = 0\\n    for _ in range(n-1):\\n        l[0] += 1\\n        a[1] += 1\\n    s = 0\\n    for i in range(n-1,-1,-1):\\n        s += l[i]\\n        if a[i] > 1:\\n            break\\n        a[i] = -1\\n    print a.index(min(s)) + 1", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "5", "task_id": "111", "completion": "def sol(n):\\n    r = []\\n    for i in range(n):\\n        r.append(r[-1])\\n    r.reverse()\\n    return r\\n\\nt = int(raw_input())\\nfor _ in xrange(t):\\n    n = int(raw_input())\\n    ans = []\\n    for i in xrange(n):\\n        ans.append(sol(n))\\n    for i in ans:\\n        print i\\n", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "5", "task_id": "112", "completion": "t = input()\\nfor _ in range(t):\\n    a, b, c, m = map(int, raw_input().split())\\n    if m == 0:\\n        print 'YES'\\n    elif m == 1:\\n        print 'YES'\\n    elif m > a:\\n        if b < m - 1:\\n            print 'YES'\\n        elif c < m - 1:\\n            print 'NO'\\n        elif a >= m - 1 and b >= m - 1:\\n            print 'NO'\\n        else:\\n            print 'YES'", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "5", "task_id": "113", "completion": "n = int(raw_input())\\na = map(int, raw_input().split())\\n\\nfor i in xrange(n):\\n    x, y = map(int, raw_input().split())\\n    a.sort()\\n    t = 0\\n    for i in xrange(n):\\n        t += (x * a[i] - y) / i\\n    print t\\n", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "5", "task_id": "114", "completion": "from collections import Counter\\n\\nn = int(raw_input())\\n\\narr = []\\nfor _ in xrange(n):\\n    c = map(int, raw_input().split())\\n    arr.append([c[0], c[1]])\\n\\nm = int(raw_input())\\nb = [map(int, raw_input().split()) for _ in xrange(m)]\\n\\nb = sorted(b, key = lambda x: -x[1])\\n\\nans = [0] * m\\nans[0] = ans[0]\\nans[1] = ans[1]\\n\\nfor a in arr:\\n    if a[0] == 0:\\n        ans[1] = ans[0] + 1\\n    else:\\n        ans[2] = ans[2] + 1\\n\\nfor i in xrange(m):\\n    if b[i]:\\n        ans[i] = ans[i] - 1\\n        break\\n\\nif ans[0] == 0:\\n    print \" \".join(map(str, ans[1]))\\nelse:\\n    for i in xrange(m):\\n        print ans", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "6", "task_id": "4", "completion": "import sys\\ninput = sys.stdin.readline\\n\\ndef gcd(a, b):\\n\\tif b == 0:\\n\\t\\treturn a\\n\\telse:\\n\\t\\treturn gcd(b, a % b)\\n\\ndef main():\\n\\tt = int(input())\\n\\twhile t>0:\\n\\t\\tt-=1\\n\\t\\tn = int(input())\\n\\t\\tprint(str(n)+\" \"+str(n-2))+\" \"+str(n-2))\\n\\n\\n\\n\\nmain()\\n", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "6", "task_id": "5", "completion": "from collections import deque\\nfrom bisect import *\\nfrom heapq import *\\nfrom math import *\\nfrom random import *\\nfrom itertools import *\\nfrom fractions import *\\n\\n\\ng   = lambda : [int(x) for x in raw_input().split()]\\ngcl = lambda : [int(x) for x in raw_input().split()]\\ngcl2 = lambda : list(g())\\ngcl = lambda : [float(x) for x in raw_input().split()]\\ngcl2 = lambda : [float(x) for x in raw_input().split()]\\nmod = 1000000007\\n\\nt = int(raw_input())\\nfor _ in range(t):\\n    n = g()\\n    s = list(g())\\n    ans = 0\\n    for i in range(n):\\n        ans += 1 if s[i] == '1' else 0\\n    print(ans)\\n\\n", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "6", "task_id": "6", "completion": "import os\\nimport sys\\nfrom atexit import register\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\n\\nn,m = [int(x) for x in input().split()]\\narr = [[0 for x in range(n+1)] for x in input().split()] for _ in range(m)]\\n\\nq = int(input())\\nfor _ in range(q):\\n    a,b = [int(x) for x in input().split()]\\n    while a!=b:\\n        a,b = [int(x) for x in input().split()]\\n        arr[a-1][b-1] = b\\n\\n    u = a-1\\n    v = a-1\\n    ans = 0\\n    while u>0 and v>0:\\n        ans += 1\\n        if ans == n:\\n           ", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "6", "task_id": "7", "completion": "t = int(raw_input())\\nfor i in xrange(t):\\n    n = int(raw_input())\\n    nums = list(map(int, raw_input().split()))\\n    a = {}\\n    for j in nums:\\n        a[j] = a.get(j, 0) + 1\\n    a[nums.index(0)] = 1\\n    a[nums.index(1)] = 1\\n    if len(a) > 1:\\n        print n\\n        continue\\n    for j in a:\\n        j = j + 1\\n        a[nums[j]] = a[nums[j]] + 1\\n    print n\\n", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "6", "task_id": "8", "completion": "T = int(raw_input())\\nfor t in range(T):\\n    n = int(raw_input())\\n    if n % 2 == 0:\\n        print n / 2, n / 2\\n        continue\\n    print n / 2, n / 2 - n\\n", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "6", "task_id": "9", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    S = input()\\n    C = {}\\n    for c in S:\\n        C[c] = 1\\n    L = 0\\n    for c in S:\\n        if C[c]!= 0:\\n            L += 1\\n    L = L\\n    ans = L\\n    if L < 2:\\n        ans = L\\n    else:\\n        ans = L + 1\\n    print ans", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "6", "task_id": "10", "completion": "for _ in range(input()):\\n    n, k = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n    max_d = [0] * (n + 1)\\n    color = [0] * (k + 1)\\n    #print max_d\\n    for i in range(k):\\n        if a[i] >= a[max_d[i]] + a[i]:\\n            max_d[i] = max_d[i]\\n            color[max_d[i]] = 0\\n    print''.join(map(str, color))\\n", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "6", "task_id": "11", "completion": "import atexit, io, sys \\n\\n  \\n# A stream implementation using an in-memory bytes  \\n# buffer. It inherits BufferedIOBase. \\n\\nbuffer = io.BytesIO() \\n\\nsys.stdout = buffer\\n  \\n# print via here \\n\\n@atexit.register \\n\\ndef write(): \\n\\n    sys.__stdout__.write(buffer.getvalue()) \\n\\n\\n\\ndef f(s):\\n\\tfor c in s:\\n\\t\\tif len(s)>0:\\n\\t\\t\\treturn 0\\n\\treturn 1\\n\\nfor _ in range(input()):\\n\\tn = input()\\n\\tlst = []\\n\\tfor _ in range(n):\\n\\t\\ts = raw_input()\\n\\t\\tlst.append(s)\\n\\tlst = sorted(lst)\\n\\tmaxi = 0\\n\\tfor i in range(n):\\n\\t\\tc = 0\\n\\t\\tfor j in lst:\\n\\t\\t\\tif i==j:\\n\\t\\t\\t\\tc+=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmaxi = max(maxi,maxi-i+1)\\n\\t\\t\\tmaxi = max(maxi,maxi-", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "6", "task_id": "12", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nfor _ in range(int(input())):\\n    n, m, k = rints()\\n    if (n % 2)!= 0 and (m % 2)!= 0:\\n        print 'NO'\\n    else:\\n        ans = 'YES'\\n        print ans\\n", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "6", "task_id": "16", "completion": "for _ in range(input()):\\n    n = input()\\n    s = raw_input()\\n    print min(n, len(set(s)))\\n", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "6", "task_id": "17", "completion": "t = int(raw_input())\\nfor _ in xrange(t):\\n\\tn = int(raw_input())\\n\\tvisited = [False]*n\\n\\t\\n\\tfor i in xrange(n):\\n\\t\\tr = map(int, raw_input().split())\\n\\t\\tvisited[r[i]] = True\\n\\t\\n\\tif visited[n-1]:\\n\\t\\tprint -1\\n\\t\\tcontinue\\n\\t\\n\\ti = 0\\n\\tfor j in xrange(n):\\n\\t\\tif visited[j] == True:\\n\\t\\t\\ti += 1\\n\\t\\n\\tif i >= n:\\n\\t\\tprint n\\n\\t\\tcontinue\\n\\t\\n\\tprint i", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "6", "task_id": "18", "completion": "from sys import stdin\\nfrom collections import *\\nfrom itertools import *\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\nfor _ in range(int(input())):\\n    n, k = rints()\\n    ans, j = 0, k\\n    c = Counter(rints())\\n    ans = max(0, c[j])\\n    for _ in range(k):\\n        x, y = rints()\\n        if x < 2*n:\\n            ans -= 1\\n            c[x] -= 1\\n            c[y] += 1\\n        else:\\n            break\\n    out.append(ans)\\n\\nprint('\\n'.join(map(str, out)))\\n", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "6", "task_id": "19", "completion": "t = int(raw_input())\\nfor _ in xrange(t):\\n    n = int(raw_input())\\n    arr = map(int, raw_input().split())\\n    s = set()\\n    for i in xrange(n):\\n        s.add(arr[i] - arr[i-1])\\n    s = set()\\n    for i in xrange(n):\\n        s.add(arr[i])\\n    if len(s) > n - 1 and s[-1] == 0:\\n        print 'YES'\\n    else:\\n        print 'NO'\\n\\n\\n\\n\\n", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "6", "task_id": "20", "completion": "from sys import stdin\\n\\nn,k = map(int,stdin.readline().split())\\na = map(int,stdin.readline().split())\\n\\ndp = [0 for i in xrange(n+k)]\\nd = {}\\ndp[0] = 1\\nfor i in xrange(1,n+k):\\n    for j in xrange(k):\\n        if a[i][j] in d:\\n            d[a[i][j]] = j\\n            d[a[i][j]] = i\\n            break\\nfor i in xrange(n-1,-1,-1):\\n    x = a[i-1][j]\\n    for j in xrange(x+1,n+1):\\n        if a[j] in d:\\n            d[a[j]] = j\\n            continue\\n    if i == n:\\n        break\\n    dp[i] = i\\nfor i in xrange(n):\\n    print dp[i] + 1,dp[i][x-1]\\n", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "6", "task_id": "21", "completion": "MOD = 998244353\\n\\nn = int(raw_input())\\n\\ng = {}\\n\\ndef cal(x):\\n    global g\\n    return g[x]\\n\\nfor _ in xrange(n):\\n    x, y, s = map(int, raw_input().split())\\n    g[y] = x\\n    g[x] = g[y] + s\\n    g[x] = g[x] + s\\n    g[y] = s\\n\\ntotal = 0\\nfor i in xrange(n - 1):\\n    total += (g[i + 1] - g[i]) * (g[i + 1] - g[i]) % MOD\\n\\nprint total % MOD\\n", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "6", "task_id": "24", "completion": "for _ in xrange(input()):\\n    n = input()\\n    print n-9", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "6", "task_id": "25", "completion": "from __future__ import division\\nfrom sys import stdin, stdout\\nfrom collections import *\\nfrom operator import itemgetter, mul\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrstr_2d = lambda n: [rstr() for _ in range(n)]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nrstr_2d = lambda n: [rstr() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\\nceil1, out = lambda a, b: (a + b) // 2\\nout = []\\n\\nfor _ in range(int(input())):\\n    s, t = rstr(), rstr()\\n    ans = 'YES'\\n    for i in range(len(s)):\\n       ", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "6", "task_id": "26", "completion": "for _ in range(input()):\\n    s=raw_input()\\n    x=0\\n    i=0\\n    t=0\\n    while i<10:\\n        if s[i]=='?':\\n            x+=1\\n            t+=1\\n            i+=1\\n            if i<10:\\n                break\\n        elif s[i]=='1':\\n            x+=1\\n            t-=1\\n        else:\\n            break\\n    print t+1", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "6", "task_id": "27", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n\\n# sys.stdin = open('input')\\n# n, k = map(int, raw_input().split())\\n# da = map(int, raw_input().split())\\n# db = map(int, raw_input().split())\\n\\ndef main():\\n    q = map(int, raw_input().split())[0]\\n    for _ in xrange(q):\\n        s = raw_input()\\n        t = raw_input()\\n        ans = 1\\n        i = 0\\n        j = 0\\n        while j < len(t):\\n            if t[i]!= s[j]:\\n                j += 1\\n            else:\\n                ans = 0\\n            break\\n        if j < len(t):\\n            if t[i] == t[j]:\\n                ans = 0\\n                break\\n        i += 1\\n        j += 1\\n        if ans:\\n            print \"YES\"\\n        else:\\n            print \"NO\"\\n\\n\\nmain()\\n", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "6", "task_id": "28", "completion": "for _ in xrange(int(raw_input())):\\n    n,m = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n    print n/2\\n    for i in xrange(n):\\n        if a[i]>m:\\n            print 0,\\n            print a[i],\\n    print\\n\\n", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "6", "task_id": "33", "completion": "t = input()\\n\\nfor _ in xrange(t):\\n    n = input()\\n    arr = map(int, raw_input().split())\\n    arr.sort()\\n\\n    m = 0\\n    for i in xrange(n-1, -1, -1):\\n        if arr[i]!= m:\\n            m = max(m, arr[i])\\n    print m", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "6", "task_id": "34", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nt = inp[ii]; ii += 1\\nfor _ in range(t):\\n    n, k = inp[ii]; ii += 1\\n    a = inp[ii + k: ii + n]; ii += n\\n    dp = [-1]*n\\n    for x in a:\\n        dp[x] = 0\\n    for x in range(n):\\n        for y in range(n):\\n            if a[x] & (x - y)!= 0:\\n                dp[x] = max(dp[x], dp[x - y] + (x - y) % x)\\n    ans = max(dp[n] + (k - 1) * dp[n + 1] + (n - 1) * dp[n + 1] + (k - 1) * dp[n + 1] + (n - 1) * dp[n + 1] + (n - 1) * dp[n + 1] + (k - 1) * dp[", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "6", "task_id": "35", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n,m = [int(x) for x in input().split()]\\n    if n == 0:\\n        print 0\\n    elif n < m:\\n        print m\\n    else:\\n        ans = m - (n ^ m)\\n        print ans\\n", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "6", "task_id": "36", "completion": "t=input()\\nfor _ in range(t):\\n    n=input()\\n    for i in range(n):\\n        print 'a'*i+'b'*(n/2)", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "6", "task_id": "38", "completion": "for _ in range(int(input())):\\n    n = int(input())\\n    print(15*6 + 8*n + 20*n - 8*n)\\n", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "6", "task_id": "39", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nt = inp[ii]; ii += 1\\n\\ndef solve(W, H, X1, Y1, X2, Y2):\\n    # A.x = W - X1\\n    # B.x = H - Y1\\n    x, y = X2 - X1\\n    y = Y2 - Y1\\n    if (x == 0 or y == H):\\n        print -1\\n    elif (x == W):\\n        print 0\\n    elif (y == H):\\n        print (x - x2)\\n    elif (y == H):\\n        print (y - y2)\\n    elif (x == W):\\n        print (y - y1)\\n    else:\\n        print abs(x - x1) + abs(y - y1)\\n\\nfor _ in range(int(input())):\\n    w, h = inp[ii: ii + 2]\\n    x1, y1, x2, y2 = inp", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "6", "task_id": "40", "completion": "T = input()\\n\\nfor t in range(T) :\\n    n = input()\\n    A = []\\n    for i in range(1, m + 1) :\\n        A.append(map(int, raw_input().split()))\\n    \\n    x = 0\\n    y = 0\\n    while x < n :\\n        x += A[x][y]\\n        y += 1\\n    print max(x, y)", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "6", "task_id": "41", "completion": "n, m = map(int, raw_input().split())\\ns = raw_input()\\n\\nans = [0 for i in range(n)]\\nfor i in range(m):\\n    a, b = map(int, raw_input().split())\\n    ans[a] += b - a + 1\\n\\nfor i in range(n):\\n    c = s[i] - s[i - 1]\\n    ans[a - 1] += c\\n    ans[b - 1] += c - s[i]\\n\\nfor _ in range(m):\\n    l, r = map(int, raw_input().split())\\n    print ans[r - 1] - ans[l - 1]", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "6", "task_id": "44", "completion": "from sys import stdin, stdout\\n\\nfor _ in range(int(input())):\\n    c, d = map(int, stdin.readline().split())\\n    d1 = c - d\\n    d2 = d - d\\n    if (d1 > 0 and d2 > 0):\\n        stdout.write('-1\\n')\\n    elif (c == d1):\\n        stdout.write('0\\n')\\n    else:\\n        stdout.write('\\n')\\n", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "6", "task_id": "45", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = [int(x) for x in input().split()]\\n    ans = 0\\n    cur = 0\\n    ans_pos = 0\\n    for i in range(n):\\n        if A[i] == A[i-1]:\\n            cur += 1\\n            ans_pos += 1\\n            ans_pos += 1\\n            ans_pos = 0\\n    if cur > 2:\\n        print -1\\n    else:\\n        print ans_pos", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "6", "task_id": "46", "completion": "#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\n\\nn = int(raw_input())\\n\\nc = [int(x) for x in raw_input().split()]\\n\\nsum = 0\\ncount = 0\\n\\nif n % 2 == 1:\\n    s = 0\\n    for i in range(n):\\n        if c[i] % 2 == 1:\\n            s += 1\\n        elif c[i] % 2 == 1:\\n            s += 1\\n    else:\\n        s += 1\\n\\n    print s\\n\\nelse:\\n    ans = 0\\n    count = 0\\n    for i in range(n):\\n        if c[i] % 2 == 1:\\n            count += count\\n            ans += count\\n            count = 0\\n        elif c[i] % 2 == 0:\\n            count += count\\n            count += count\\n    print ans", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "6", "task_id": "52", "completion": "from collections import defaultdict\\ndef solve():\\n    n = int(raw_input())\\n    arr = map(int, raw_input().split())\\n    return sum([0 for i in xrange(n)])\\n\\nfor _ in xrange(n):\\n    print solve()", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "6", "task_id": "53", "completion": "for _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    s=map(int,raw_input().split())\\n    c=sorted(s)[k-1:]\\n    print ['No','Yes'][c>0]", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "6", "task_id": "54", "completion": "t = int(raw_input())\\nfor _ in range(t):\\n    n, k = map(int, raw_input().split())\\n    a = k\\n    ans = pow(a, n, 1000000007) * pow(a, n, 1000000007)\\n    print ans % 1000000007\\n", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "6", "task_id": "60", "completion": "from __future__ import division, print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf=[]\\ndef f(n):\\n    return reduce(lambda x,y:x&y, le.pop().split())\\nfor u in range(int(le.pop())):\\n    n=int(le.pop())\\n    l=list(map(int,le.pop().split()))\\n    l1=[]\\n    for i in range(n):\\n        l1.append(l[i]&l[i])\\n    if n==1:\\n        print(0)\\n    else:\\n        l=[0]\\n        for i in range(n):\\n            if l[i]&l1[i]==0:\\n                l[i]=1\\n                l1.append(l[i])\\n        print(max(l))\\n", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "6", "task_id": "61", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = stdin.readline\\npr = stdout.write\\nmod=10**9+7\\n\\ndef ni():\\n    return int(raw_input())\\n\\n\\n\\ndef li():\\n    return map(int,raw_input().split())\\n\\n\\ndef pn(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\ndef pa(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers\\n    # Use Ctrl+D to flush stdin.\\n    return map(int,stdin.read().split())\\n\\nrange = xrange # not for python 3.0+\\n\\n# main code\\n\\nfor t in range(ni()):\\n    n=ni()\\n    s=stdin.readline()\\n    d={}\\n    d['B']=1\\n    d['R']=1\\n    d['B']=1\\n    d['", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "6", "task_id": "62", "completion": "import os\\nimport sys\\nfrom atexit import register\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    a = [int(x) for x in input().split()]\\n    cur = [i for i in range(n) if a[i]]\\n    print''.join(map(str, cur))\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "6", "task_id": "66", "completion": "t = input()\\nfor i in range(t):\\n\\tk = input()\\n\\ts = \"\"\\n\\twhile k>1:\\n\\t\\ts += \"1\"\\n\\t\\tk -= 1\\n\\tprint s", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "6", "task_id": "67", "completion": "from sys import stdin\\nfrom fractions import gcd\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    a, b, c = map(int, stdin.readline().split())\\n    l = min(a, c)\\n    if l == b:\\n        if c % 2 == 0:\\n            print b\\n        else:\\n            print -1\\n        continue\\n    print c\\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "6", "task_id": "68", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\nout = []\\n\\nfor _ in range(ii):\\n    k = inp[ii]; ii += 1\\n\\n    k = k >> 1; ii += 1\\n    x = k & (k - 1)\\n    out.append(str(x + 1))\\n\\nprint '\\n'.join(out)\\n", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "6", "task_id": "69", "completion": "for _ in range(input()):\\n    n=input()\\n    n=str(n)\\n    i=1\\n    while i<len(n)-1:\\n        if n[i]=='0':\\n            n=n[:i]+str(2**i)\\n            break\\n        else:\\n            i+=1\\n    print n-i", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "6", "task_id": "70", "completion": "for _ in range(input()):\\n    s = raw_input().strip()\\n    n = len(s)\\n    s = list(s)\\n    flag = 0\\n    for i in range(n):\\n        if s[i]!= s[n-i-1]:\\n            flag = 1\\n        if s[i] == s[n-i-1]:\\n            s[i] = s[n-i-1]\\n        else:\\n            s[i] = s[i]\\n    for i in range(n):\\n        if s[i]!= s[i-1]:\\n            print -1\\n            break\\n        s[i] = s[i]\\n    print ''.join(s)", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "6", "task_id": "71", "completion": "for _ in range(input()):\\n\\ta,b=map(int,raw_input().split())\\n\\tif a==1:\\n\\t\\tprint a\\n\\telse:\\n\\t\\tprint a*b+str(a)+\"0\"*(b-1)", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "6", "task_id": "72", "completion": "for _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    i=1\\n    l=len(str(n))\\n    if i>l:\\n        print(n)\\n    else:\\n        if i==l:\\n            l-=1\\n            l-=1\\n        if i<l:\\n            l=0\\n        for j in range(l):\\n            if l%10==0:\\n                l+=1\\n            else:\\n                l-=1\\n        print(str(n))", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "6", "task_id": "73", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n = RN()\\n    A = RI()\\n\\n    if A[0]<A[1]:\\n        A = A[1:]\\n    else:\\n        A = A[:-1] + A[1:]\\n        A.append(A)\\n\\nprint('\\n'.join(map(str,A)))", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "6", "task_id": "74", "completion": "def solve(A, B):\\n    return min(A, B)\\n\\nT = int(raw_input())\\nfor _ in xrange(T):\\n    a, b = map(int, raw_input().split())\\n    print (2 + a - 1) / 2\\n    print \" \".join([str(i) for i in xrange(2 + b - a)])\\n", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "6", "task_id": "75", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef main():\\n    n = int(stdin.readline())\\n    for _ in xrange(n):\\n        n, ans = int(stdin.readline()), [0] * n\\n        l = [map(int, stdin.readline().split()) for _ in xrange(n)]\\n        for _ in xrange(n):\\n            d = [0] * n\\n            for x in l:\\n                d[x] += 1\\n            if l[0] > 0:\\n                ans += d[0] - 1\\n            else:\\n                ans += d[1] - 1\\n                d[0] = 0\\n        print ans\\nmain()\\n", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "6", "task_id": "76", "completion": "n, m = map(int, raw_input().split())\\nprint pow(2, m - 1, m) * (n - 1) % m\\n", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "6", "task_id": "77", "completion": "n, m = map(int, raw_input().split())\\n\\nprint pow(2, n - 1, m) * (m - 1) % m\\n", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "6", "task_id": "78", "completion": "for _ in range(int(input())):\\n    l, r = map(int, raw_input().split())\\n    print (r - l + 1) / 2\\n", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "6", "task_id": "79", "completion": "from collections import Counter\\nimport os, sys\\nfrom itertools import permutations as perm\\nfrom random import randint as R\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    k = int(input())\\n    s = input()\\n    cnt = 0\\n    for i in s:\\n        if i == '3' and s[2:]:\\n            cnt += 1\\n    print(cnt)\\n    print(n)\\n", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "6", "task_id": "80", "completion": "def solve():\\n    n = input()\\n    s = map(int, raw_input())\\n    s.sort(reverse=True)\\n    n1 = s[0]\\n    n2 = s[1]\\n    for i in xrange(n):\\n        if s[i] == '1':\\n            print 1, 2, i, n1\\n            break\\n    print n1, n2, n1, n2\\nt = input()\\nfor _ in xrange(t):\\n    solve()\\n", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "6", "task_id": "81", "completion": "for _ in range(input()):\\n    n,q=map(int,raw_input().split())\\n    s=raw_input()\\n    l,r=0,n\\n    for i in s:\\n        if i=='+':\\n            l+=1\\n        elif i=='-':\\n            r-=1\\n    ans=0\\n    for i in range(n):\\n        if s[i]!=s[i]:\\n            ans+=1\\n    print ans\\n\\n", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "6", "task_id": "84", "completion": "import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n,s = map(int,input().split())\\n    if n%2==0:\\n        print(n/2)\\n    else:\\n        print(n-1)\\n", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "6", "task_id": "85", "completion": "for _ in range(input()):\\n\\ts=raw_input()\\n\\ta=s.count('1')\\n\\tb=s.count('0')\\n\\tc=0\\n\\tfor i in range(1,a+1):\\n\\t\\tif s[i]=='1':\\n\\t\\t\\tc=c+1\\n\\t\\telse:\\n\\t\\t\\tb=b-1\\n\\tprint c", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "6", "task_id": "86", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    s = input()\\n    ans = 0\\n    for i in range(n):\\n        k = input()\\n        ans = max(ans, k*2 + s[k*2:k*2 + s[k*2]])\\n    print ans", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "6", "task_id": "87", "completion": "#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\nfrom collections import defaultdict\\nfrom math import factorial as f\\nfrom fractions import gcd as g\\n\\nT = int (raw_input ())\\nfor _ in range (T):\\n    n, m = [int (i) for i in raw_input ().split ()]\\n    l = [int (i) for i in raw_input ().split ()]\\n    l.sort ()\\n\\n    ans = 0\\n    for i in range (n):\\n        ans += l[i] * l[i]\\n    print ans", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "6", "task_id": "88", "completion": "for _ in range(input()):\\n    n, m = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n    a.sort()\\n    ans = 0\\n    while a[0] > 0:\\n        for i in range(1, m + 1):\\n            ans += a[i] - a[i-1]\\n            a[i] = 0\\n    print ans", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "6", "task_id": "93", "completion": "t = int(raw_input())\\nfor i in range(t):\\n    a,b = map(int, raw_input().split())\\n    print (a+b)\\n", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "6", "task_id": "94", "completion": "t = input()\\nfor _ in xrange(t):\\n\\tn = input()\\n\\ti = 1\\n\\ta = n / (2 * (n - 1))\\n\\tif i == 1:\\n\\t\\tprint a\\n\\telse:\\n\\t\\tprint (n - (n + 1)) * (n + 1)", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "6", "task_id": "95", "completion": "def base(x):\\n    a=[]\\n    while x>0:\\n        a.append(x%10)\\n        x/=10\\n    return a\\n\\nfor _ in range(input()):\\n    s,n=map(int,raw_input().split())\\n    if n==1:\\n        print s\\n        continue\\n    i=1\\n    while s>0:\\n        print s,\\n        s/=10\\n        i+=1\\n    if n>0:\\n        print s,\\n    else:\\n        i=n-1", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "6", "task_id": "98", "completion": "for _ in range(input()):\\n    n = input()\\n    s = list(raw_input())\\n    a = [0] * (n + 1)\\n    b = [0] * (n + 1)\\n    for i in range(1, n):\\n        if s[i - 1] == 'a':\\n            a[i - 1] += 1\\n            b[i] += 1\\n    c = [0] * (n + 1)\\n    for i in range(1, n + 1):\\n        c[i] += b[i - 1]\\n    for i in range(1, n + 1):\\n        if s[i - 1] == 'b':\\n            c[i] += 1\\n            break\\n    a[0] = c[0]\\n    b[0] = c[1]\\n    for i in range(1, n + 1):\\n        if s[i - 1] == 'b':\\n            b[i] += 1\\n        else:\\n            a[i] += 1\\n            break\\n    a[n - 1] = 1\\n    for i in", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "6", "task_id": "99", "completion": "from sys import stdin, stdout\\n\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, s = rint(), rints()\\n\\n    if s == 1:\\n        print('YES')\\n        for i in range(n):\\n            stdout.write('X')\\n            stdout.write('-')\\n            stdout.write('\\n')\\n        for i in range(n):\\n            stdout.write('+')\\n            stdout.write('\\n')\\n    else:\\n        for i in range(n):\\n            stdout.write('=')\\n            stdout.write('+')\\n            stdout.write('-')\\n            stdout.write('\\n')\\n        stdout.write('\\n')", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "6", "task_id": "100", "completion": "from collections import defaultdict\\nfrom __future__ import print_function, division\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\n\\n\\n# n, k = map(int, stdin.readline().split())\\n# da = map(int, stdin.read().split(), repeat(10, 3 * 3 * 5 * 6))\\n\\nrstr = lambda: stdin.readline().strip()\\n\\n\\ndef count_len(n):\\n    cnt = [0] * (n + 1)\\n    for i in xrange(n - 1, -1, -1):\\n        cnt[i] = cnt[i] + cnt[i - 1]\\n    return cnt\\n\\nmod = 998244353\\n\\nmod_sum = 10**9 + 3\\n\\nfor _ in range(int(input())):\\n    n = int(stdin.readline())\\n    a = map(int, stdin.readline().split())\\n\\n    ans = 0\\n    for i in xrange(1, n):\\n        ans += count_len(a[i])\\n    ans %= mod\\n    ans += count_len(a[i])", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "6", "task_id": "101", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n,m,k = map(int,stdin.readline().split())\\n    x = map(int,stdin.readline().split())\\n    y = map(int,stdin.readline().split())\\n    x.sort()\\n    y.sort()\\n    count = 0\\n    for i in xrange(k):\\n        a,b = map(int,stdin.readline().split())\\n        if a >= x[i] and b >= y[i]:\\n            count += 1\\n    print count\\n", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "6", "task_id": "109", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    if n==1:\\n        print 0\\n        continue\\n    c=0\\n    for i in s:\\n        if i==0:\\n            c+=1\\n        elif i>9:\\n            c-=1\\n        else:\\n            c+=1\\n    print min(c,n-c)", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "6", "task_id": "110", "completion": "def solve(n, a):\\n    m = [0] * n\\n    for i in xrange(1, n):\\n        for j in xrange(i, n):\\n            m[i] = m[j] + a[i-1] + 1\\n    for i in xrange(n):\\n        for j in xrange(i, n):\\n            if j!= i:\\n                m[j] = m[j] + 1\\n    return m\\nfor _ in xrange(input()):\\n    n = input()\\n    a = [map(int, raw_input().split()) for _ in xrange(n)]\\n    a.sort(reverse = True)\\n    print \"1\" if solve(n, a) else -1", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "6", "task_id": "111", "completion": "from collections import Counter\\n\\ndef main():\\n    t = int(raw_input())\\n    for _ in xrange(t):\\n        n = int(raw_input())\\n        l = []\\n        for i in xrange(2*n):\\n            if (i % 2 == 0):\\n                l.append('(')\\n            else:\\n                l.append('(')\\n                l.append(')')\\n            for i in xrange(n):\\n                l.append('(')\\n            for i in xrange(2*n):\\n                print(')')\\n            print(l[-1])\\n\\nif __name__ == '__main__':\\n    main()\\n", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "6", "task_id": "112", "completion": "for _ in range(input()):\\n    a,b,c,m=map(int,raw_input().split())\\n    if a==b and c==0:\\n        print \"YES\"\\n    elif a==b and c==0:\\n        print \"NO\"\\n    elif a==0 and b==0:\\n        if m!=0:\\n            if m%2==1:\\n                if m%2==1:\\n                    print \"YES\"\\n            elif m%2==1:\\n                if m%2!=1:\\n                    if m%2!=1:\\n                    print \"NO\"\\n                    else:\\n                        print \"NO\"\\n                        break\\n            elif m%2==0:\\n                if m%2==1:\\n                    if m%2!=1:\\n                        print \"NO\"\\n                        continue\\n                if m%2!=1:\\n                    if m%2!=1:\\n                        print \"NO\"\\n                        else:\\n                        print \"NO\"\\n                        continue\\n                    if m%2!=1:\\n                        print \"NO\"\\n                        continue\\n                if m%2", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "6", "task_id": "113", "completion": "n = input()\\narr = list(map(int,raw_input().split()))\\nm = input()\\narr.sort()\\n\\nfor i in range(m):\\n    a,b = map(int,raw_input().split())\\n    if a>=b:\\n        arr[i]-=b\\n    else:\\n        arr[i]+=b\\n\\nfor i in range(m):\\n    x,y= map(int,raw_input().split())\\n    ans=0\\n    for j in range(n):\\n        if arr[j]<=y:\\n            ans+=arr[j]-x\\n        else:\\n            ans+=arr[j]\\n    print ans", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "6", "task_id": "114", "completion": "import sys\\n\\nn = int(sys.stdin.readline())\\n\\nmax_s = 0\\nmax_l = 0\\nfor i in xrange(n):\\n    a = map(int, sys.stdin.readline().split())\\n    l = [0] * (c+1)\\n    l[a[0]] += 1\\n    max_l = max(max_l, l[a[0]] + c)\\n    l[a[0]] += c\\n\\n    for j in xrange(c-1, -1, -1):\\n        if l[j] < max_l:\\n            max_l = l[j]\\n\\n    if max_l < l[0]:\\n        max_l = l[0]\\n    max_l = 0\\n    max_s = 0\\n    for j in xrange(c-1, -1, -1):\\n        if l[j] < max_l:\\n            max_s = l[j]\\n        if l[j] == max_l:\\n            max_s = l[j]\\n    max_l = max(max_", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "7", "task_id": "4", "completion": "import math\\nfor _ in range(input()):\\n    n=input()\\n    a=1\\n    b=2\\n    while a*a<=n:\\n        print a,b\\n        a*=2\\n    if a!=2:\\n        print b,a", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "7", "task_id": "5", "completion": "t = input()\\nfor _ in range(t):\\n\\tn = input()\\n\\ta = list(raw_input())\\n\\tb = list(raw_input())\\n\\t#print a,b\\n\\t#print b\\n\\ti = 0\\n\\tcount = 0\\n\\tc = 0\\n\\twhile i<n:\\n\\t\\ti += 1\\n\\t\\tj = n -1\\n\\t\\twhile j>=0 and a[j]==b[i]:\\n\\t\\t\\tj-=1\\n\\t\\t\\tcount+=1\\n\\t\\t\\tc+=1\\n\\t\\t\\tif i>=0:\\n\\t\\t\\t\\ti-=1\\n\\t\\tprint count", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "7", "task_id": "6", "completion": "def check(n, k):\\n    ans = 0\\n    for x in xrange(n):\\n        if k!= x and k not in ans:\\n            ans += n-k\\n            continue\\n        if k!= x and k not in ans:\\n            ans -= n\\n            continue\\n    return ans\\n\\nn, m = map(int, raw_input().split())\\ng = [[] for i in xrange(n+1)]\\nfor i in xrange(m):\\n    u, v = map(int, raw_input().split())\\n    g[u].append(v)\\n    g[v].append(u)\\nq = int(raw_input())\\nfor i in xrange(q):\\n    u, v = map(int, raw_input().split())\\n    if u == 1:\\n        u -= 1\\n        v -= 1\\n    if v == 1:\\n        g[u].append(v)\\n    else:\\n        u -= 1\\n        v -= 1\\n        g[v].append(u)\\n    if v == 1:\\n        u -= 1\\n        v -= 1\\n        g[u", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "7", "task_id": "7", "completion": "from sys import stdin\\nimport math\\n\\ndef nCr(n,r):\\n    if r==0:\\n        return 0\\n    else:\\n        return nCr(n,r%r)\\n\\ndef rint():\\n    return int(stdin.readline())\\n\\ndef rints():\\n    return map(int,stdin.readline().split())\\n\\n\\nt=rint()\\nfor _ in xrange(t):\\n    n=rint()\\n    l=rints()\\n    m=max(l)\\n    for i in xrange(n-1,-1,-1):\\n        if m%l[i]==1:\\n            m+=1\\n    ans=0\\n    for i in xrange(n):\\n        if m%l[i]==0:\\n            ans+=1\\n        else:\\n            break\\n    print ans\\n    \\n\\n", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "7", "task_id": "8", "completion": "from collections import defaultdict as ddic, deque, Counter, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nMOD = 10**9 + 7\\n\\ndef my_main():\\n    kase = inp()\\n    ans = []\\n    for _ in range(kase):\\n        n = inp()\\n        ans.append((n/2)%2)\\n    print''.join(map(str, ans))\\n\\nmy_main()\\n", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "7", "task_id": "9", "completion": "def solve():\\n    s = list(raw_input())\\n    max_c = 0\\n    ans = 0\\n    for c in s:\\n        if c in max_c:\\n            ans += 1\\n        else:\\n            max_c += 1\\n        max_c = max(max_c, max_c)\\n    print ans\\n\\nT = int(raw_input())\\nfor t in xrange(T):\\n    solve()\\n", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "7", "task_id": "10", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n \\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n,k = RI()\\n    A = RI()\\n    cur = []\\n    b = [0]*(n+1)\\n    for i in A:\\n        if i==0:\\n            cur.append(i)\\n            cur.append(0)\\n        else:\\n            cur.append(i)\\n    b.sort()\\n    dp = [[0]*(k+1) for i in xrange(k+1)]\\n    for", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "7", "task_id": "11", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\n\\ndef my_main():\\n    t = inp()\\n    for _ in range(t):\\n        n = inp()\\n        da = []\\n        for i in range(n):\\n            a = inp()\\n            da.append(set(a))\\n        ans = 0\\n        for i in da:\\n            ans = max(ans, i)\\n    print ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "7", "task_id": "12", "completion": "from sys import stdin, stdout  \\n  \\ndef solve(n, m, k):\\n   if k <= (n*m) / 2:\\n      return \"YES\"\\n   for i in xrange(k):\\n      if i >= (n*m) - (k - i) or (k - i) < 0:\\n         return \"NO\"\\n   return \"YES\"\\n\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n   n, m, k = map(int, stdin.readline().split())\\n   print solve(n, m, k)\\n", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "7", "task_id": "16", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef solve():\\n    n = int(stdin.readline())\\n    s = stdin.readline().strip()\\n    ans = n\\n    for i in range(n):\\n        if s[i] >= s[i+1]:\\n            ans = min(ans, i-1)\\n    print ans\\nT = int(stdin.readline())\\nfor t in range(T):\\n    solve()", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "7", "task_id": "17", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    kase = inp()\\n    for _ in range(kase):\\n        n = inp()\\n        l = []\\n        for i in range(n):\\n            l.append(inp())\\n        d = defaultdict(list)\\n        for i in range(n):\\n            k = sorted(l[i])\\n            d[k[i]].append(i)\\n\\n        ans = 0\\n        for i in range(n):\\n            ans += 1\\n            if ans >= 3:\\n               ", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "7", "task_id": "18", "completion": "def solve():\\n    n, k = map(int, raw_input().split())\\n    f = [[0 for i in range(n)] for j in range(n)]\\n    for i in range(k):\\n        x, y = map(int, raw_input().split())\\n        f[x][y] = f[x][y] = 1\\n    ans = 0\\n    for i in range(k):\\n        a, b = map(int, raw_input().split())\\n        for j in range(1, a+1):\\n            ans += max(0, f[i-1][j] - f[i][j])\\n    print ans\\n\\nT = int(raw_input())\\nfor t in range(T):\\n    solve()", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "7", "task_id": "19", "completion": "for _ in range(input()):\\n    n=input()\\n    l=map(int,raw_input().split())\\n    for i in range(n):\\n        if l[i]>0:\\n            l[i]-=l[i]\\n    for i in range(n):\\n        if l[i]<0:\\n            print \"NO\"\\n            continue\\n        if l[i]>0:\\n            print \"NO\"\\n            continue\\n        l[i]-=l[i]\\n        if l[i]==0:\\n            print \"NO\"", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "7", "task_id": "20", "completion": "n, k = map(int, raw_input().split())\\nc = map(int, raw_input().split())\\n\\n\\na = [0] * (n + 1)\\nfor i in xrange(n):\\n\\ta[c[i]] = i + 1\\n\\nfor i in xrange(1, n + 1):\\n\\tfor j in xrange(k):\\n\\t\\tif c[j] == i:\\n\\t\\t\\ta[c[j] - 1] = a[c[j] - 1]\\n\\nl = len(a)\\nr = len(a)\\n\\n\\nl1 = [max(a) for a in a]\\nl2 = [max(a) for a in a]\\n\\nl = sorted(l, key = lambda x: x[1])\\n\\nl2 = [a[0] - 1]\\nl1.append(a[1])\\nl1.reverse()\\nl2.reverse()\\n\\nr = min(l1)\\nans = [l1[i], l2[i] - 1]\\n\\nfor i in xrange(n):\\n\\tif l2[", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "7", "task_id": "21", "completion": "from sys import stdin\\ndef main():\\n    n = int(stdin.readline())\\n    D = [0] * (n + 1)\\n    D[0] = 1\\n    D[1] = 1\\n    S = [0] * (n + 1)\\n    for _ in xrange(n):\\n        x, y, s = map(int, stdin.readline().split())\\n        D[y] = max(S[y], 1)\\n    for i in xrange(1, n + 1):\\n        D[i] = (D[i - 1] + D[i - 1]) % 998244353\\n    ans = 0\\n    for i in xrange(n):\\n        ans += D[i][y]\\n    print ans\\nmain()", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "7", "task_id": "24", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n \\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\ndef solve(n):\\n    while n>9:\\n        dig = 0\\n        for i in range(1,10):\\n            dig = dig+int(str(i))\\n        dig = dig*10\\n    return dig\\n\\nfor _ in xrange(RN()):\\n    n = RN()\\n    print solve(n)\\n", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "7", "task_id": "25", "completion": "for _ in range(input()):\\n    s=list(raw_input())\\n    t=list(raw_input())\\n    d=0\\n    d1=0\\n    for i in s:\\n        if i!=t[0]:\\n            d=d+1\\n        else:\\n            d1=d-1\\n    if d1>=2:\\n        if d1%2==0:\\n            print 'YES'\\n        else:\\n            print 'NO'\\n    else:\\n        if d1==0:\\n            print 'YES'\\n        else:\\n            print 'NO'", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "7", "task_id": "26", "completion": "T = int(raw_input())\\n\\nfor _ in xrange(T):\\n    S = list(raw_input())\\n    cnt = 0\\n    count = 0\\n    a = S[0]\\n    for i in xrange(1, len(S)):\\n        if S[i] == \"?\":\\n            a = A[i-1]\\n            cnt += 1\\n        elif S[i] == \"?\":\\n            a = A[i-1]\\n            a = A[i]\\n            cnt -= 1\\n    if a!= 0:\\n        print count + a + 1\\n    else:\\n        print count + a - cnt\\n", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "7", "task_id": "27", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\n\\nfor _ in xrange(RN()):\\n    s = list(RS())\\n    t = list(RS())\\n\\n    ans = 0\\n    for i in xrange(len(s)-1,-1,-1):\\n        if s[i]!=t[i]:\\n            ans+=1\\n    if ans>0:\\n        print \"NO\"\\n    else:\\n        print \"YES\"\\n", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "7", "task_id": "28", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nt = inp[ii]; ii += 1\\nfor _ in range(t):\\n    n, m = inp[ii]; ii += 1\\n    A = inp[ii: ii + n]; ii += n\\n\\n    k = [A[i:i + n] for i in range(n)]\\n\\n    k.sort()\\n\\n    p = 1\\n    for i in range(1, n):\\n        if k[i - 1] > 0:\\n            p = i\\n            k[i - 1] = 1\\n            k[i - 1] = 1\\n\\n    for i in range(n):\\n        if k[i] > m:\\n            break\\n        p = i\\n\\n    print len(p)\\n    for x in p:\\n        print x,\\n\\n", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "7", "task_id": "33", "completion": "t = input()\\nfor _ in xrange(t):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    for i in xrange(n):\\n        a[i] = max(a[i], a[i+1])\\n    print a[n-1]", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "7", "task_id": "34", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\nfor _ in range(int(input())):\\n    n, k = rints()\\n    a, ans, i = rints(), 0, -1\\n    for i in range(n):\\n        x = i ^ a[i]\\n        while x:\\n            x /= 2\\n            ans += max(ans, (i + 1) * x + (i + 1) * x)\\n            x /= 2\\n    out.append(ans)\\n\\nprint('\\n'.join(map(str, out)))\\n", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "7", "task_id": "35", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n, m = map(int, stdin.readline().split())\\n    if n == 0:\\n        print m\\n        continue\\n    elif m == 0:\\n        print m\\n        continue\\n    s = m\\n    n -= s\\n    if n & (s << 1) == 0:\\n        print (n ^ s)\\n    else:\\n        print m ^ (s << 1)\\n", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "7", "task_id": "36", "completion": "for _ in range(input()):\\n    n = input()\\n    s=\"\"\\n    for i in range(n):\\n        if i % 2 == 0:\\n            s+=chr(ord('a')+i)\\n        else:\\n            s+=chr(ord('a')+i)\\n    print s", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "7", "task_id": "38", "completion": "n = input()\\nfor t in range(n):\\n    n = input()\\n    if n < 6:\\n        print 15 * n\\n    elif n < 8:\\n        print 15 * n\\n    elif n < 10:\\n        print 15 * n\\n    else:\\n        print 30 * n - 750 * 16\\n", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "7", "task_id": "39", "completion": "from sys import stdin, stdout\\ndef solve():\\n    w,h = map(int,stdin.readline().split())\\n    x1,y1,x2,y2 = map(int,stdin.readline().split())\\n    x1,y1,x2,y2 = map(int,stdin.readline().split())\\n    x2,y2 = x2,y2\\n    dx = abs(x1-x2)\\n    dy = abs(y1-y2)\\n    if dx>0 or dy<0:\\n        print \"-1\"\\n    elif dx<0:\\n        print (dx-1)*(dx-1)\\n    elif dy<0:\\n        print (dy-1)*(dx-1)\\n    else:\\n        print 2*dx*(-1)\\n\\nT = int(stdin.readline())\\nfor _ in xrange(T):\\n    solve()\\n", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "7", "task_id": "40", "completion": "from collections import deque\\n\\nt = int(raw_input())\\nfor _ in range(t):\\n    n = int(raw_input())\\n    m = []\\n    for i in range(n):\\n        m.append(list(map(int, raw_input().split())))\\n    m.sort()\\n    c = deque(m)\\n    i = 0\\n    j = 0\\n    while i < len(m):\\n        if m[i][j] <= m[i][j]:\\n            c.appendleft(m[i][j])\\n            j += 1\\n        else:\\n            j += 1\\n    m.popleft()\\n    print max(m)\\n", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "7", "task_id": "41", "completion": "#!/usr/bin/env python\\n#-*- coding: utf-8 -*-\\n\\nfrom collections import defaultdict\\nfrom math import factorial as f\\nfrom fractions import gcd as g\\n\\nn, m = [int (i) for i in raw_input ().split ()]\\ns = raw_input ()\\n\\nfor i in range (m):\\n    l, r = [int (i) for i in raw_input ().split ()]\\n    if l > 1 and r < 1:\\n        print 0\\n    else:\\n        print 1\\n", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "7", "task_id": "44", "completion": "for _ in range(input()):\\n    a,b=map(int,raw_input().split())\\n    if a==0 and b==0:\\n        print 0\\n        continue\\n    if a==b:\\n        print 1\\n    elif b==a:\\n        print -1\\n    elif a+b==c:\\n        print 1\\n    else:\\n        if (c-b)%2==1:\\n            print 2\\n        else:\\n            print -1", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "7", "task_id": "45", "completion": "def solve():\\n    n = int(raw_input())\\n    a = map(int, raw_input().split())\\n    s = 0\\n    for i in xrange(n):\\n        if a[i] % 2 == 0:\\n            s += 1\\n        if a[i] % 2!= 0:\\n            s -= 1\\n            a[i] /= 2\\n        if a[i] % 2!= 0:\\n            s += 1\\n    if s < 0:\\n        print -1\\n    else:\\n        print s\\n\\nT = int(raw_input())\\nfor t in xrange(T):\\n    solve()\\n", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "7", "task_id": "46", "completion": "n = input()\\nl = map(int, raw_input().split())\\nans = 0\\ncount = 0\\nb = 0\\nfor i in l:\\n    if i & 1:\\n        count += 1\\n    else:\\n        if b == 0:\\n            ans += count\\n            b = 0\\n            count = 0\\n            b = 0\\n        else:\\n            b += 1\\n            count = 0\\n    if count % 2 == 0:\\n        ans += count / 2\\n    else:\\n        ans += count / 2 + count / 2 + count / 2\\n        count = 0\\nprint ans\\n", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "7", "task_id": "52", "completion": "for _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    a.sort()\\n    s=sum(a)\\n    ans=0.0\\n    for i in range(n-1):\\n        ans+=a[i+1]\\n        s-=a[i]\\n    print '%.12f' %ans\\n", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "7", "task_id": "53", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef solve():\\n    n,k = map(int,stdin.readline().split())\\n    a = map(int,stdin.readline().split(), repeat(10,n))\\n    c = []\\n    for x in a:\\n        if x < 0:\\n            c.append(x)\\n    if k == 1:\\n        print \"YES\"\\n    else:\\n        if k == 1:\\n            print \"NO\"\\n        else:\\n            print \"YES\"\\n\\n\\n\\nfor t in range(int(stdin.readline())):\\n    solve()\\n", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "7", "task_id": "54", "completion": "from __future__ import division, print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\n\\nfor zorg in range(int(le.pop())):\\n    n, k = map(int, le.pop().split())\\n    b = pow(2, n - k, 1000000007)\\n    print(b * (2 ** k) + (n - 1) * b) % 1000000007)", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "7", "task_id": "60", "completion": "for _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    ma=a[0]\\n    for i in range(1,n):\\n        if a[i]&a[i-1]:\\n            ma=max(ma,a[i]&a[i-1])\\n    print ma\\n", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "7", "task_id": "61", "completion": "from collections import defaultdict\\ndef solve():\\n    n = int(raw_input())\\n    a = raw_input()\\n    ans = []\\n    for i in range(n):\\n        l = int(raw_input())\\n        s = raw_input()\\n        for j in range(n):\\n            if s[j] == 'B' and s[j] == '?' or s[j] == '?' or s[j] == 'R':\\n                if s[j] == 'B':\\n                    ans.append('B')\\n                elif s[j] == 'R':\\n                    ans.append('R')\\n                elif s[j] == '?' and s[j] == 'B':\\n                    ans.append('B')\\n                elif s[j] == 'R':\\n                    ans.append('R')\\n            elif s[j] == '?':\\n                if s[j] == '?' and s[j] == '?':\\n                    ans.append('B')\\n                else:\\n                    ans.append('B')\\n    ans.sort()\\n    for i in ans:\\n        print i\\n\\nT = int(", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "7", "task_id": "62", "completion": "\\nfrom sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, a, ans, mem, for i in sorted(rints()):\\n        if a[i]:\\n            ans += 1\\n            mem[i] = -1\\n            ans += 1\\n    out.append(str(ans))\\n    print(' '.join(out))\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "7", "task_id": "66", "completion": "import math\\ndef f(k):\\n    n = int(math.floor(math.log(k,3)))\\n    if k == 1:\\n        return 1\\n    return 1 + f(k-1)\\n\\nfor _ in range(input()):\\n    k = input()\\n    ans = 1\\n    print(f(k))\\n", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "7", "task_id": "67", "completion": "for _ in range(input()):\\n    a,b,c=map(int,raw_input().split())\\n    if(b in a or c in a):\\n        print -1\\n    else:\\n        if(b-a in a):\\n            print a+1\\n        else:\\n            print -1\\n    \\n        \\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "7", "task_id": "68", "completion": "#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\nimport sys\\nfrom math import *\\nfrom collections import defaultdict\\nfrom math import ceil, log, factorial, sqrt\\nfrom Queue import *\\ngetcontext().prec = 100\\nsys.setrecursionlimit(10 ** 6)\\nMOD = 10 ** 9 + 7\\nINF = float('+inf')\\n\\nT = int (raw_input ())\\nfor i in xrange (T):\\n    k = int (raw_input ())\\n    ans = (1, 2)\\n    while k > 1:\\n        ans *= 2\\n        k -= 1\\n    print ans, k", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "7", "task_id": "69", "completion": "for _ in range(input()):\\n    n = input()\\n    c = 0\\n    i = 1\\n    while n > 0:\\n        if n%2 == 1:\\n            c+=1\\n            n = n/2\\n            i+=1\\n        else:\\n            break\\n    print c", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "7", "task_id": "70", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef solve():\\n    T = int(stdin.readline())\\n    for _ in xrange(T):\\n        t = stdin.readline().strip()\\n        ans = [x for x in t]\\n        if len(ans) == 0:\\n            return -1\\n        for i in xrange(len(t)):\\n            if t[i]!= t[i+1]:\\n                if s[i] == t[i+1]:\\n                    ans[i] = t[i+1]\\n                    ans[i] = t[i+1]\\n                    break\\n        else:\\n            ans[-1] = t[i]\\n            ans.append(t)\\n        ans.append(ans[-1])\\n    print \" \".join(map(str, ans))\\n\\nT -= 1\\nfor _ in xrange(T):\\n    solve()\\n", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "7", "task_id": "71", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\ndef solve():\\n    n,k = RI()\\n    d = 10**k\\n    def calc(n):\\n        ans = int(''.join(list(str(n)))+10**(k-1))\\n        if ans==d:\\n            return str(n)\\n        else:\\n            return n\\n\\n    for i in xrange(10):\\n        if n%i==0:\\n            k-=1\\n            ans = min(ans,calc(i+1))\\n        else:\\n", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "7", "task_id": "72", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n    n,k = [int(x) for x in input().split()]\\n\\n    s = str(n)\\n\\n    if k==1:\\n        print s\\n        continue\\n\\n    s = '0' + s[::-1]\\n\\n    #print s\\n    for i in range(1,k):\\n        s += '0'\\n        if i*10 >= n:\\n            s = s + '1'\\n            break\\n\\n    print s", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "7", "task_id": "73", "completion": "import os\\nimport sys\\nfrom atexit import register\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nfor _ in xrange(int(input())):\\n    n = int(input())\\n    arr = map(int,input().split())\\n    ans = []\\n    i = 0\\n    while i < n:\\n        if arr[i] > arr[i+1]:\\n            ans.append(i+1)\\n            i += 2\\n        i += 1\\n    print(len(ans))\\n", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "7", "task_id": "74", "completion": "for _ in range(input()):\\n    a, b = map(int, raw_input().split())\\n    n, m = min(a, b), max(a, b)\\n    print n\\n    print (n + m) / 2, n + 1\\n    for i in xrange(n):\\n        print 0, i,\\n    print", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "7", "task_id": "75", "completion": "for _ in range(input()):\\n    n=input()\\n    a=[[] for i in range(n)]\\n    for i in range(n):\\n        a[i]=map(int,raw_input().split())\\n        a[0]=a[0][0]\\n        a[0][1]=a[0][1]\\n    ans=max(a)\\n    for i in range(n):\\n        b=[i for i in range(n)]\\n        for j in range(1,b[i][0]):\\n            ans=max(ans,a[j][1]+a[j][0])\\n    print ans", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "7", "task_id": "76", "completion": "n,m=map(int,raw_input().split())\\n\\nf=2\\nfor i in xrange(1,n+1):\\n    if i%2==0:\\n        f=f*i%m\\nprint f\\n", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "7", "task_id": "77", "completion": "n, m = map(int, raw_input().split())\\nprint n - max(2 * n - 1, m) % m", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "7", "task_id": "78", "completion": "t = input()\\nfor _ in xrange(t):\\n    l,r = map(int,raw_input().split())\\n    print r-r+1\\n", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "7", "task_id": "79", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nMOD = 10 ** 9 + 7\\n\\n\\ndef my_main():\\n    kase = inp()\\n    ans = []\\n    for _ in range(kase):\\n        kase -= 1\\n        n = inp()\\n        ans.append(n)\\n    ans.sort(reverse=True)\\n\\n    ans.reverse()\\n    ans.reverse()\\n\\n    ans.reverse()\\n    print len(ans)\\n    print \" \".join(map(str, ans))\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "7", "task_id": "80", "completion": "from __future__ import division, print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor zorg in range(int(le.pop())):\\n    n = int(le.pop())\\n    s = list(le.pop())\\n    st = []\\n    for i in xrange(n):\\n        if s[i] == \"0\":\\n            st.append(i)\\n        else:\\n            st.append(i)\\n    for i in st:\\n        if i!= \"1\":\\n            print(i)\\n            print(len(st), i),\\n            print(len(st), i)\\n", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "7", "task_id": "81", "completion": "for _ in xrange(input()):\\n    n,q=map(int,raw_input().split())\\n    s=raw_input()\\n    d={}\\n    for i in s:\\n        d[i]=1\\n        d[i]=0\\n    ans=0\\n    s=raw_input()\\n    ans1=0\\n    for i in s:\\n        if i=='+':\\n            ans1+=1\\n        else:\\n            ans1-=1\\n            if ans1==0:\\n                if d[i]!=0:\\n                    ans=2\\n                    ans1=1\\n                    break\\n            else:\\n                if d[i]!=0:\\n                    ans1+=1\\n                    ans1=0\\n                    break\\n                else:\\n                    if d[i]!=0:\\n                        ans1+=1\\n                d[i]=1\\n        ans=min(ans, ans1)\\n    print ans\\n\\n\\n", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "7", "task_id": "84", "completion": "from __future__ import division,print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf=[]\\nfor zorg in range(int(le.pop())):\\n    n,s=list(map(int,le.pop().split()))\\n    d=n%2\\n    if d<=s:\\n        af.append(d)\\n    else:\\n        af.append(n/d)\\nfor u in af:\\n    print(u)", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "7", "task_id": "85", "completion": "for _ in range(input()):\\n    s = raw_input().strip()\\n    a = set([])\\n    for x in s:\\n        if x=='1':\\n            a.add(0)\\n        else:\\n            a.add(1)\\n    print min(a)*2", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "7", "task_id": "86", "completion": "# cook your code here\\nt=int(raw_input())\\nfor i in range(t):\\n    n=int(raw_input())\\n    a=[]\\n    b=[]\\n    s=raw_input()\\n    for i in range(n):\\n        a.append(int(raw_input()))\\n    for i in range(n):\\n        b.append(int(raw_input()))\\n    m=0\\n    for i in range(n):\\n        x=0\\n        if b[i]=='1':\\n            x=x+1\\n        if b[i]=='0':\\n            y=y+1\\n        if a[i]=='0':\\n            y=y+1\\n        if a[i]=='1':\\n            x=y+1\\n        if a[i]=='0':\\n            y=y-1\\n    ans=0\\n    for i in range(n):\\n        if a[i]=='0':\\n            ans=max(ans,x)\\n    print ans", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "7", "task_id": "87", "completion": "def solve():\\n    n,m = map(int, raw_input().split())\\n    arr = map(int, raw_input().split())\\n    ans = 0\\n    arr.sort()\\n    for i in range(m):\\n        if i==0:\\n            break\\n        ans += arr[i]\\n    i = 1\\n    ans += arr[n-1]\\n    while i<n-1:\\n        if arr[i] < arr[i-1]:\\n            ans += arr[i]\\n            i+=1\\n        else:\\n            break\\n    print ans\\n\\n\\nfor _ in range(input()):\\n    solve()", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "7", "task_id": "88", "completion": "from sys import stdin,stdout\\nI = lambda : map(int,stdin.readline().split())\\nt = input()\\nfor _ in range(t):\\n\\tn,m = I()\\n\\ta = I()\\n\\tc = [0]\\n\\tfor i in range(m):\\n\\t\\tc.append(a[i]+a[i-1])\\n\\tfor i in range(1,n):\\n\\t\\tc[i] = c[i-1]+a[i]\\n\\tfor i in c:\\n\\t\\tans = 0\\n\\t\\tfor j in range(1,m):\\n\\t\\t\\tif a[i]>c[j-1]:\\n\\t\\t\\t\\tans += c[j-1]\\n\\t\\t\\t\\tc[j-1] = max(c[j],c[j-1]+1)\\n\\t\\tans += c[n]\\n\\tprint ans\\n", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "7", "task_id": "93", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    a,b = [int(x) for x in input().split()]\\n    if a == b:\\n        print 1\\n    else:\\n        print 2\\n", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "7", "task_id": "94", "completion": "import math\\nt = int(raw_input())\\nfor _ in range(t):\\n    n = int(raw_input())\\n    res = math.ceil(n/2.0)\\n    if res % 2 == 1:\\n        res = n / 2\\n    else:\\n        res = int(math.ceil(n/2.0))\\n    print(res)\\n    ", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "7", "task_id": "95", "completion": "def func(a,base,s,n):\\n    if n==1:\\n        return str(a)\\n    if s>10:\\n        return str(a+1)+\" \"+str(a*s-10)\\n    if n==2:\\n        return str(a*10)+\" \"+str(a*n)\\n    else:\\n        return str(a*10)+\" \"+str(a*n)\\n\\nfor _ in range(input()):\\n    a=map(int,raw_input().split())\\n    print func(a,base,n)\\n", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "7", "task_id": "98", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    s = input()\\n    A, B = 0, 0\\n    for c in s:\\n        if c == 'a': A += 1\\n        else: B += 1\\n\\n    if A > B:\\n        print A, B\\n    else:\\n        print -1, -1\\n", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "7", "task_id": "99", "completion": "for _ in range(input()):\\n    n=input()\\n    a=list(raw_input())\\n    cnt=0\\n    if a.count('1')!=n or a.count('2')!=n:\\n        print \"NO\"\\n        continue\\n    for i in range(n):\\n        if a[i]=='X':\\n            cnt+=1\\n        elif a[i]=='-':\\n            cnt-=1\\n        elif a[i]=='X':\\n            cnt+=1\\n    if cnt==n or cnt==0:\\n        print \"YES\"\\n        for i in range(n):\\n            print \"-\"\\n        for i in range(n):\\n            print \"-\"\\n        for i in range(n):\\n            print \"+\"\\n    else:\\n        print \"NO\"\\n", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "7", "task_id": "100", "completion": "for _ in xrange(input()):\\n    n=input()\\n    arr=map(int,raw_input().split())\\n    s=[0]*n\\n    for i in xrange(n):\\n        s[i]=(s[i]+s[n-i-1])%998244353\\n    s[n]=s[n-i-1]+s[n-i-1]%998244353\\n    print (s[n])%998244353", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "7", "task_id": "101", "completion": "#!/usr/bin/python\\n\\nfrom __future__ import division, print_function\\nfrom sys import stdin, exit\\n\\n\\ndef main():\\n    [t] = map(int, stdin.readline().split())\\n    for _ in xrange(t):\\n        [n, m, k] = map(int, stdin.readline().split())\\n        x = map(int, stdin.readline().split())\\n        y = map(int, stdin.readline().split())\\n        x.sort()\\n        y.sort()\\n\\n        l = [0] * (n + m + 1)\\n        for i in xrange(k):\\n            x1, y1 = map(int, stdin.readline().split())\\n            l[i] = max(l[i], x1)\\n            l[i + 1] = min(l[i], y1)\\n\\n        ans = 0\\n        for i in xrange(1, n + 1):\\n            if l[i] > x1:\\n                ans += 1\\n        print(ans)\\n\\n\\nif __name__ == '__main__':\\n", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "7", "task_id": "109", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n = RN()\\n    s = RI()\\n\\n    ans = 10**n-1\\n    ans += min(abs(s[i]-s[i-1]),abs(s[i]-s[i-1]))\\n\\n    print ans", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "7", "task_id": "110", "completion": "from sys import stdin\\nfrom collections import *\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, a = int(input()), rints()\\n    ans = 2\\n    for _ in range(n):\\n        l, r = rints(), [0] * k\\n        for i, x in enumerate(a):\\n            if l == x:\\n                ans += 1\\n                break\\n    if ans == n:\\n        out.append(-1)\\n    else:\\n        out.append(1)\\n\\nprint('\\n'.join(map(str, out)))\\n", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "7", "task_id": "111", "completion": "\\n\\n\\nfor _ in range(input()):\\n    n = input()\\n    d = {1: '('}\\n    for i in range(n):\\n        d[i] = d[i-1]\\n        print '\\n'.join(d[i+1] for i in range(n))\\n", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "7", "task_id": "112", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    t = inp()\\n    for _ in range(t):\\n        a, b, c, m = inp()\\n        if a == 0:\\n            break\\n        if b == 0:\\n            b = 0\\n        c = 0\\n        if c == 0:\\n            c = 0\\n        if a == 0:\\n            a = 1\\n        elif b == 0:\\n            b = 0\\n        elif c == 0:\\n            c = 0\\n        elif c == 0", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "7", "task_id": "113", "completion": "from sys import stdin, stdout\\nfrom collections import *\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nrstr_2d = lambda n: [rstr() for _ in range(n)]\\nrint_2d = lambda n: [rint() for _ in range(n)]\\nout = []\\n\\nfor _ in range(int(input())):\\n    x, y = rints()\\n    if x > y:\\n        out.append(y - x)\\n    else:\\n        out.append(x)\\n\\n\\nfor _ in range(int(input())):\\n    a, b = rints()\\n    d = {}\\n    for i in range(1, n):\\n        if d.get(i, 0) == None:\\n            d[i] = 0\\n        else:\\n            d[i] = a\\n    a = a + d[i]\\n    if d.get(a, 0) == None:\\n        d[a] = 0\\n    else:\\n        d[a] = d[a] + 1\\n", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "7", "task_id": "114", "completion": "from collections import defaultdict\\nfrom collections import deque\\nimport itertools as ite\\nimport sys\\nimport math\\n\\nsys.setrecursionlimit(1000000)\\n\\nINF = 10 ** 18\\nMOD = 10 ** 9 + 7\\n\\nn = input()\\na = []\\nfor i in range(n):\\n    c = map(int, raw_input().split())\\n    a.append(c)\\n    a.append(c)\\n\\nm = input()\\nb = []\\nfor i in range(m):\\n    b.append(map(int, raw_input().split()))\\n\\nans = []\\nfor i in b:\\n    ans.append(i)\\nans.sort()\\n\\nfor i in ans:\\n    print i[0],\\n", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "8", "task_id": "4", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    print n/2,n%2", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "8", "task_id": "5", "completion": "import sys,os,math\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = sys.stdin.readline\\npr = stdout.write\\nmod=10**9+7\\n\\n\\ndef ni():\\n    return int(raw_input())\\n\\n\\n\\n\\ndef li():\\n    return map(int,raw_input().split())\\n\\n\\ndef pn(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\n\\ndef pa(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers\\n    # Use Ctrl+D to flush stdin.\\n    return map(int,stdin.read().split())\\n\\nrange = xrange # not for python 3.0+\\n\\n\\n# main code\\n\\nfor t in range(ni()):\\n    n=ni()\\n    s=li()\\n    ans=0\\n    c1=1\\n    c2=1\\n    for i in range(n):\\n        if", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "8", "task_id": "6", "completion": "from collections import defaultdict\\nn, m = map(int, raw_input().split())\\nc = defaultdict(list)\\nwhile m > 0:\\n    u, v = map(int, raw_input().split())\\n    u -= 1\\n    v -= 1\\n    c[u].append(v)\\n    m -= 1\\nq = input()\\nfor _ in xrange(q):\\n    u, v = map(int, raw_input().split())\\n    c[u].append(v)\\n    c[v].append(u)\\n    c[u].append(u)\\nans = 0\\n\\n\\ndef test():\\n    for _ in xrange(q):\\n        q, u, v = map(int, raw_input().split())\\n        if q == 1:\\n            ans += n\\n        elif q == 2:\\n            ans -= n\\n        else:\\n            ans -= 1\\n    return ans\\n\\nfor k in xrange(n):\\n    if test():\\n        print n\\n    else:\\n        print test()\\n", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "8", "task_id": "7", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, a, ans, ans, mem = rints(), [0] * (n + 1), rints(), [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\\n\\n    for i in range(1, n + 1):\\n        mem[i] = mem[i - 1] + mem[i - 1]\\n\\n    for i in range(n, 0, -1):\\n        for j in range(i + 1, n + 1):\\n            ans[j] += 1\\n\\n    out.append(ans[n // 2])\\n\\nprint('\\n'.join(map(str, out)))\\n", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "8", "task_id": "8", "completion": "t=input()\\nfor _ in range(t):\\n    n=input()\\n    if n%2==0:\\n        print n/2,n/2\\n    else:\\n        print n/2-1,n/2\\n    print n/2,n/2\\n    \\n", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "8", "task_id": "9", "completion": "# inp.readline()\\n# int(inp.readline())\\n# out.write()\\n# raw_input()\\n# map(int,raw_input().split())\\n# map(int,inp.readline().split())\\n# map(int,inp.readline().split())\\n# for _ in xrange(input()):\\n# print \"Case #\"+str(_+1)+\": \"+ \\nfor _ in xrange(input()):\\n    a=raw_input()\\n    c=sorted(a)\\n    cnt=0\\n    for i in xrange(len(c)):\\n        if c[i]==c[i+1]:\\n            cnt+=1\\n    print cnt", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "8", "task_id": "10", "completion": "t = int(raw_input())\\n\\nfor _ in xrange(t):\\n    n, k = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n\\n    l = [[0 for i in xrange(k)] for j in xrange(n)]\\n    ans = []\\n    ans.append(k - 1)\\n    for i in xrange(n):\\n        ans.append(a[i + 1] - a[i])\\n\\n    for i in xrange(k - 1, -1, -1):\\n        if ans[i]!= 0:\\n            ans[i] -= 1\\n        else:\\n            ans[i] += 1\\n    ans.append(k - 1)\\n    for i in ans:\\n        print i,\\n    print\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "8", "task_id": "11", "completion": "t = input()\\n\\nfor i in range(t):\\n    n = input()\\n\\n    a = []\\n    for j in range(n):\\n        x = raw_input()\\n        a.append(x)\\n\\n    arr = sorted(a)\\n    s = len(set(arr))\\n\\n    l = len(s)\\n\\n    ans = 0\\n    for i in range(0, l):\\n        x = s.count(a[i])\\n        ans += 1\\n        if ans >= l:\\n            break\\n\\n    print ans\\n", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "8", "task_id": "12", "completion": "import sys\\n\\nt = int(sys.stdin.readline())\\n\\nfor i in range(t):\\n    n,m,k = [int(x) for x in sys.stdin.readline().split()]\\n    x = min(n,m-k)\\n    if x < m/2:\\n        print \"NO\"\\n    else:\\n        if k % 2 == 0:\\n            x = min(n,m-k)\\n        else:\\n            print \"YES\"\\n\\n", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "8", "task_id": "16", "completion": "# coding: utf-8\\n\\nn = int(raw_input())\\nfor _ in xrange(n):\\n\\tn = int(raw_input())\\n\\ts = raw_input()\\n\\ta = list(s)\\n\\ts.sort()\\n\\tif n == 1:\\n\\t\\tprint 0\\n\\t\\tcontinue\\n\\tj = 0\\n\\tfor i in xrange(n - 1, -1, -1):\\n\\t\\tif s[i] > s[j]:\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tj += 1\\n\\tprint j", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "8", "task_id": "17", "completion": "def superior(i, j):\\n    global n\\n    # print 'b', i, j\\n    superior(i, j)\\n    # print'superior %s' % superior\\n\\ndef check(b, n, i, j):\\n    if i in superior(i):\\n        return True\\n    if n == 1:\\n        return False\\n\\n    if i == 1:\\n        return True\\n\\n    if n == 2:\\n        return True\\n\\n    if i == 3:\\n        return True\\n\\n    i = n - 1\\n    j = n - 2\\n\\n    return superior(i, j + 1, i + 1, j)\\n\\n\\ndef check(n, l, p):\\n    m = n\\n    while m >= 0 and p <= 4:\\n        if check(l, n, m, p):\\n            return m\\n        m -= 1\\n\\n\\n\\nfor _ in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    l = []\\n    for i in xrange(n):\\n        l.append(map(int, raw", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "8", "task_id": "18", "completion": "for _ in range(input()):\\n    n, k = map(int, raw_input().split())\\n    a = []\\n    for _ in range(k):\\n        x, y = map(int, raw_input().split())\\n        a.append((x, y))\\n    ans = 0\\n    for i in range(k):\\n        x, y = map(int, raw_input().split())\\n        ans += min(a[i][0] - 1, a[i][1] - 1)\\n    print ans", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "8", "task_id": "19", "completion": "t=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    arr=[int(i) for i in raw_input().split()]\\n    ans='NO'\\n    for i in range(n):\\n        if arr[i]>0:\\n            ans+=arr[i]-arr[i-1]\\n        else:\\n            ans+=arr[i]\\n    print ans\\n", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "8", "task_id": "20", "completion": "from sys import stdin,stdout,setrecursionlimit,maxint,exit\\n#setrecursionlimit(2*10**5)\\ndef listInput():\\n return map(long,stdin.readline().split())\\ndef printBS(li):\\n for i in xrange(len(li)-1):\\n  stdout.write(\"%d \"%li[i])\\n stdout.write(\"%d\\n\"%li[-1])\\ndef sin():\\n return stdin.readline().rstrip()\\nn,k=listInput()\\nli=listInput()\\ndic={}\\nfor i in xrange(n):\\n for j in xrange(k):\\n  if not dic.has_key(li[i]):\\n   dic[li[i]]=1\\nfor i in xrange(n):\\n i=i+1\\n j=n-1\\n while j>=k:\\n  if dic.has_key(li[j]):\\n   dic[li[j]]-=1\\n   j-=1\\n  if dic[li[j]]==-1:\\n   j-=1\\n   dic[li[j]]-=1\\nprint li[-1],", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "8", "task_id": "21", "completion": "n = input()\\n\\ndp = [0 for i in range(n)]\\n\\nfor i in range(n):\\n    x, y, s = map(int, raw_input().split())\\n    dp[x] = (y, s)\\n\\ndp[y] = (x, s)\\n\\ndp[y-1] = (y, s)\\n\\nfor i in range(n-1):\\n    dp[i] = (dp[i+1]+dp[i] * (dp[i+2] - 1))) % 998244353\\n\\nprint dp[n-1]", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "8", "task_id": "24", "completion": "def f(x):\\n\\tif x==0:\\n\\t\\treturn 1\\n\\tc=0\\n\\twhile x>9:\\n\\t\\tc=c+x%10\\n\\t\\tx=x/10\\n\\treturn c\\n\\nt=int(input())\\nfor i in range(t):\\n\\tx=int(input())\\n\\tans=0\\n\\twhile (x>9):\\n\\t\\tans=ans+f(x)\\n\\t\\tx=x-1\\n\\tprint ans\\n", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "8", "task_id": "25", "completion": "q = int(raw_input())\\nfor _ in range(q):\\n    a = raw_input()\\n    b = raw_input()\\n    blen = len(a)\\n    if blen%2!= 0:\\n        print 'NO'\\n        continue\\n    i = 0\\n    while i<blen:\\n        if a[i]!= b[i]:\\n            i += 1\\n        else:\\n            i += 1\\n    if i == blen:\\n        print 'YES'\\n    else:\\n        print 'NO'\\n\\n", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "8", "task_id": "26", "completion": "for _ in xrange(input()):\\n    s = raw_input()\\n    a, b, c = s.count('1'), s.count('0'), s.count('1', s.count('1'))\\n    if a > b:\\n        print a\\n    elif a < b:\\n        print a + b + c + 1\\n    elif c < b:\\n        print a + (b - a)\\n", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "8", "task_id": "27", "completion": "from sys import stdin, stdout\\nraw_input = stdin.readline\\nfor _ in xrange(int(raw_input())):\\n    s = raw_input()\\n    t = raw_input()\\n    s1 = [0 for _ in xrange(26)]\\n    t1[0] = 1\\n    for i in xrange(26):\\n        s1[ord(s[i]) - 97] = 1\\n    for i in xrange(26):\\n        t1[ord(t[i]) - 97] = 1\\n    if s1 and t1:\\n        stdout.write(\"YES\\n\")\\n    else:\\n        stdout.write(\"NO\\n\")", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "8", "task_id": "28", "completion": "# cook your code here\\nfrom sys import stdin, stdout\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n, m = map(int, stdin.readline().split())\\n    p = map(int, stdin.readline().split(), repeat(10, n))\\n    ans = []\\n    for i in xrange(n):\\n        if p[i] == i + 1:\\n            break\\n        if p[i] == i + 1:\\n            ans.append(i + 1)\\n    print n - m\\n    for i in xrange(n - m):\\n        if p[i] == i + 1:\\n            break\\n        else:\\n            ans.append(i + 1)\\n    stdout.write(' '.join(map(str, ans)))", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "8", "task_id": "33", "completion": "import atexit, io, sys \\n\\n  \\n# A stream implementation using an in-memory bytes  \\n# buffer. It inherits BufferedIOBase. \\n\\nbuffer = io.BytesIO() \\n\\nsys.stdout = buffer\\n\\n  \\n# print via here \\n\\n@atexit.register \\n\\ndef write(): \\n\\n    sys.__stdout__.write(buffer.getvalue()) \\n\\nfor _ in range(input()):\\n    n=input()\\n    l=map(int,raw_input().split())\\n    f=[0]*n\\n    for i in range(n-1,-1,-1):\\n        f[i]=max(f[i-1],l[i])\\n    #print f\\n    f.sort(reverse=True)\\n    print f[n-1]\\n", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "8", "task_id": "34", "completion": "from __future__ import division,print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf=[]\\nfor zorg in range(int(le.pop())):\\n    n,k=list(map(int,le.pop().split()))\\n    l=list(map(int,le.pop().split()))\\n    p=1\\n    for i in l:\\n        if i&k:\\n            p=max(p,i+1)\\n    af.append(p)\\nfor k in af:\\n    print(k)\\n\\n", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "8", "task_id": "35", "completion": "for _ in range(input()):\\n    n, m = map(int, raw_input().split())\\n    if n == m:\\n        print n\\n    else:\\n        print (m - n) & n\\n", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "8", "task_id": "36", "completion": "for _ in range(input()):\\n    n=input()\\n    if n%2==0:\\n        print \"a\"*n\\n    else:\\n        print \"b\"*(n/2)+\"a\"", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "8", "task_id": "38", "completion": "for _ in range(input()):\\n    n=input()\\n    if n>=6:\\n        print (n/6)*16+(n/6)*16\\n    elif n>=15:\\n        print (n/6)*20+(n/15)*25\\n    else:\\n        print 2*15", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "8", "task_id": "39", "completion": "t = input()\\nfor i in range(t):\\n\\tw, h = map(int, raw_input().split())\\n\\ta, b, c, d = map(int, raw_input().split())\\n\\tx = min(c - a, 0)\\n\\ty = min(d - b, 0)\\n\\tif x > 0:\\n\\t\\tprint abs(x - a)\\n\\telse:\\n\\t\\tprint -1", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "8", "task_id": "40", "completion": "for _ in range(input()):\\n    n=input()\\n    a=[[0 for x in range(n)]for x in range(2)]\\n    for x in range(2):\\n        a[x]=map(int,raw_input().split())\\n    a.sort()\\n    c=0\\n    for i in range(n-2):\\n        a[i][n-1-i]=0\\n    for i in range(n-2):\\n        c+=a[i][n-1-i]\\n    print c\\n", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "8", "task_id": "41", "completion": "def solve():\\n    n, m = map(int, raw_input().split())\\n    s = raw_input()\\n    for i in range(m):\\n        x, y = map(int, raw_input().split())\\n        if x!= y:\\n            print 0\\n        else:\\n            print abs(x-y)\\n\\nif __name__ == '__main__':\\n    solve()", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "8", "task_id": "44", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    a,b = map(int,stdin.readline().split())\\n    ans = 0\\n    if a == b:\\n        ans += 1\\n        continue\\n    if a > b:\\n        ans += 2\\n        if a + b > d:\\n            ans += 1\\n        else:\\n            ans -= 1\\n    print ans\\n", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "8", "task_id": "45", "completion": "t = input()\\n\\n\\nfor _ in xrange(t):\\n    n = input()\\n    a = map(int, raw_input().split())\\n\\n    if n == 1:\\n        print 0\\n        continue\\n\\n    c1, c2 = 0, 0\\n\\n    for i in xrange(n - 1):\\n        if a[i] == 1:\\n            c1 += 1\\n        if a[i] == 2:\\n            c2 += 1\\n\\n        if a[i] > 2:\\n            c1 += 1\\n\\n        if a[i] < 2:\\n            c2 += 1\\n\\n        if a[i] == 2:\\n            c1 += 1\\n\\n        if a[i] > 2:\\n            c2 += 1\\n\\n        if a[i] > 2:\\n            c1 -= 1\\n\\n        if a[i] == 2:\\n            c2 += 1\\n\\n    if c1 > c2:\\n        print c1\\n    else:\\n        print -1\\n", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "8", "task_id": "46", "completion": "n = int(raw_input())\\nc = map(int,raw_input().split())\\n\\nd = {}\\n\\nfor i in c:\\n    if i % 2 == 0:\\n        d[i] = 0\\n    else:\\n        d[i] = 1\\n\\nresult = 0\\nfor i in d:\\n    if d[i] % 2 == 0:\\n        result += d[i]\\n    else:\\n        result += d[i]\\n\\nprint result", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "8", "task_id": "52", "completion": "t = int(raw_input())\\nfor _ in range(t):\\n    n = int(raw_input())\\n    a = map(int, raw_input().split())\\n    a.sort()\\n    s = sum(a)\\n    t = sum(a)\\n    s /= 2.0\\n    print float(s)/t\\n", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "8", "task_id": "53", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n \\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\n\\ndef solve(N,K,A):\\n\\n    res=[]\\n    for i in range(0,N-1):\\n        if A[i]>=A[i+1]:\\n            res.append('YES')\\n        else:\\n            res.append('NO')\\n    return res\\n\\n\\nif __name__ == \"__main__\":\\n    T = RN()\\n    for _ in xrange(T):\\n        N,K = RI()\\n        A = RI()\\n       ", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "8", "task_id": "54", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nmod = 10**9+7\\n\\nt = int(input())\\nfor _ in range(t):\\n    n,k = [int(x) for x in input().split()]\\n    if k == 0:\\n        print 0\\n    else:\\n        print ((2**(n-1) + 1) * k) % mod\\n", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "8", "task_id": "60", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef main():\\n    n = int(stdin.readline())\\n    for _ in range(n):\\n        a = int(stdin.readline())\\n        b = map(int, stdin.readline().split(), repeat(10, n))\\n        r = [0] * n\\n        for i in b:\\n            r[i & 1] += 1\\n        print max(r)\\n\\nif __name__ == '__main__':\\n    main()\\n", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "8", "task_id": "61", "completion": "t = int(raw_input())\\nfor i in range(t):\\n\\tn = int(raw_input())\\n\\ts = raw_input()\\n\\tcount = 0\\n\\tfor j in range(n):\\n\\t\\tif s[j] == s[j + 1] and s[j]!= '?':\\n\\t\\t\\tcount += 1\\n\\t\\tif s[j] == '?':\\n\\t\\t\\tcount += 1\\n\\tif count < n - 1:\\n\\t\\tif s[j] == s[j + 1] and s[j] == '?':\\n\\t\\t\\tcount += 1\\n\\tprint count", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "8", "task_id": "62", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = [int(x) for x in input().split()]\\n    A.insert(0,0)\\n    flag = 0\\n    for i in range(n):\\n        if A[i] == 1:\\n            flag = 1\\n            break\\n    if flag == 1:\\n        print -1\\n        continue\\n    for i in range(n-1):\\n        print A[i],\\n    print ''\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "8", "task_id": "66", "completion": "def f(n):\\n    print 1 if n >= 3 else n\\nt = int(raw_input())\\nfor i in range(t):\\n    n = int(raw_input())\\n    while n > 1:\\n        print f(n)\\n        n = n - 1", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "8", "task_id": "67", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    a,b,c = [int(x) for x in input().split()]\\n    if a == b:\\n        print 1\\n    elif c == a:\\n        print -1\\n    else:\\n        print b - a%2 + 1\\n\\n\\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "8", "task_id": "68", "completion": "for _ in range(int(raw_input())):\\n    k=int(raw_input())\\n    s=\"\"\\n    r=1\\n    c=1\\n    while k%2!=0:\\n        s+=str(r)+\" \"+str(c)\\n        r+=1\\n    print s[:-1],s[1:]", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "8", "task_id": "69", "completion": "for _ in xrange(input()):\\n    n=raw_input()\\n    k=int(n[-1])\\n    i=1\\n    p=0\\n    while i<=len(n):\\n        p+=1\\n        i+=1\\n    i=n[::-1]\\n    ans=0\\n    while i<len(n):\\n        if n[i]=='1':\\n            i+=1\\n        else:\\n            if i-p<len(n)-1:\\n                ans+=1\\n                i-=p\\n        p=0\\n    print ans\\n", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "8", "task_id": "70", "completion": "from __future__ import division, print_function\\nfrom sys import stdin\\nfrom collections import *\\nfrom operator import itemgetter\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    t, a = rstr(), []\\n    for i, c in enumerate(t):\\n        if c == 'a':\\n            a.append(i)\\n        else:\\n            a.append(i)\\n    out.append(a)\\n    out.sort()\\n    a, b = [], []\\n    for x in a:\\n        if b:\\n            continue\\n        if x == b[1]:\\n            a.append(x)\\n        else:\\n            b.append(x)\\n    print(' '.join(map(str, a)))\\n", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "8", "task_id": "71", "completion": "for _ in xrange(int(raw_input())):\\n    n,k = map(int,raw_input().split())\\n    print int(''.join(map(str,[n-1,str(k),str(n-1),str(n)]))[k-1]", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "8", "task_id": "72", "completion": "import math\\n\\ninput = raw_input\\n\\ndef solve(n, k):\\n\\n\\tp = 0\\n\\tif k == 1:\\n\\t\\treturn n\\n\\tp = int(math.floor((10**(k-1) + 1) / 10))\\n\\treturn int(''.join(p), 2) + '9' * ((k-1) / 10 - (10**(k-1)))\\n\\nfor _ in xrange(int(input())):\\n\\tn, k = [int(i) for i in input().split()]\\n\\tprint solve(n, k)", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "8", "task_id": "73", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = [int(x) for x in input().split()]\\n    L = []\\n    for i in range(n):\\n        if A[i] > A[i+1]:\\n            L.append(i+1)\\n    if len(L) % 2:\\n        print 0\\n    else:\\n        for i in range(len(L)-1):\\n            if A[i] > A[i+1]:\\n                print i+1\\n                break\\n        else:\\n            print 0\\n\\n\\n\\n", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "8", "task_id": "74", "completion": "def solve(a,b):\\n    if a==0:\\n        return 1\\n    if b==0:\\n        return 2\\n    if a<b:\\n        return 1\\n    return 2*a-(a+b)\\n\\ndef main():\\n    t = int(raw_input())\\n    for _ in range(t):\\n        a,b = map(int, raw_input().split())\\n        print solve(a,b)\\n        print solve(a,b)\\n        return\\n\\nmain()\\n", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "8", "task_id": "75", "completion": "for _ in range(int(input())):\\n    n = int(input())\\n    a = [0]*n\\n    for i in range(n):\\n        a[i] = map(int, raw_input().split())\\n    a.sort()\\n    ans = a[0][0]\\n    for i in range(1, n):\\n        if a[i][0] > a[i-1][0]:\\n            ans += 1\\n            ans += a[i-1][1]\\n    print ans\\n\\n", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "8", "task_id": "76", "completion": "# -*- coding: utf-8 -*-\\nimport sys,copy,math,heapq,itertools as it,fractions,re,bisect,collections as coll\\n\\nn, m = map(int, raw_input().split())\\n\\ndef f(x):\\n    return m if x % m == 0 else f(x) - f(x / m) % m\\n\\nprint f(n - 1) % m", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "8", "task_id": "77", "completion": "def f(n,m):\\n    if n==1:\\n        return 1\\n    elif n==2:\\n        return n\\n    if n%2==0:\\n        return (f(n-2,m)%m)\\n    else:\\n        return f(n-1,m-1)%m\\nn,m=map(int,raw_input().split())\\nprint f(n-1,m)", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "8", "task_id": "78", "completion": "for _ in xrange(input()):\\n    l,r=map(int,raw_input().split())\\n    print l-r//2", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "8", "task_id": "79", "completion": "def primes(n):\\n    m = list(n)\\n    i = 2\\n    res = []\\n    while i * i <= n:\\n        if n[i*i]!= '1':\\n            res.append(i)\\n            for j in range(i):\\n                res.append(n[j*i+1])\\n            i += 2\\n    return res\\n\\ndef primes(n, k):\\n    if k == 1:\\n        return [True]\\n    return [not primes(n), primes(n)]\\n\\n\\n\\ndef get_primes(n, k):\\n    if n == 0:\\n        return [False] * n\\n    if n % 2 == 0:\\n        if k > n/2:\\n            return [False] * n\\n        else:\\n            return [True] * n\\n    else:\\n        return [True] * n\\n\\nfor t in xrange(input()):\\n    k = input()\\n    n = input()\\n    a, b = raw_input(), raw_input()\\n\\n    print len(a)\\n    print ''.join(", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "8", "task_id": "80", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = stdin.readline\\npr = stdout.write\\nmod=10**9+7\\n\\ndef ni():\\n    return int(raw_input())\\n\\n\\ndef li():\\n    return map(int,raw_input().split())\\n\\n\\ndef pn(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\ndef pa(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers\\n    # Use Ctrl+D to flush stdin.\\n    return map(int,stdin.read().split())\\n\\nrange = xrange # not for python 3.0+\\n\\n# main code\\n\\nfor t in range(ni()):\\n    n=ni()\\n    s=stdin.readline()\\n    d=dict()\\n    d[0]=1\\n    d[1]=2\\n    for i in range(n):\\n       ", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "8", "task_id": "81", "completion": "\\nimport sys\\n\\nsys.setrecursionlimit(100000)\\n\\nfor _ in range(int(raw_input())):\\n    n, q = map(int, raw_input().split())\\n    s = raw_input()\\n    l = [0] * (n + 1)\\n    for i, x in enumerate(s):\\n        l[i] += 1\\n\\n    for i in range(q):\\n        l[i], r[i] = map(int, raw_input().split())\\n\\n    ans = 0\\n    for i in range(n):\\n        if s[i]!= '+' and s[i]!= '-':\\n            ans += 1\\n        else:\\n            ans -= 1\\n    print ans\\n", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "8", "task_id": "84", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nfor _ in range(int(input())):\\n    n, s = rints()\\n    m = max(n - 1, s)\\n    if m % 2!= 0:\\n        print(n)\\n    else:\\n        print(n // 2)\\n", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "8", "task_id": "85", "completion": "for _ in range(input()):\\n    s=raw_input()\\n    ans=0\\n    p=0\\n    for i in s:\\n        if i=='1':\\n            p+=1\\n        elif i=='0':\\n            p-=1\\n        else:\\n            ans+=1\\n    print min(ans,p)", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "8", "task_id": "86", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = [int(x) for x in input()]\\n    b = [int(x) for x in input()]\\n    ans = 0\\n    prev = []\\n    for i in range(n):\\n        if prev[i] == '1':\\n            prev = [i]\\n        else:\\n            prev = [i]\\n    ans = ans + prev[0]\\n    ans = ans + prev[1]\\n    prev = [a[i] for i in range(n)]\\n    for i in range(n):\\n        if prev[i] == '0':\\n            if prev[i] == '1':\\n                ans = ans + prev[i]\\n                prev[i] = '0'\\n                prev[i] = '1'\\n                prev = [i]\\n        else:\\n            if prev[i] == '1':\\n                ans = ans + prev[i]\\n                prev = [i]\\n    prev =", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "8", "task_id": "87", "completion": "from collections import Counter\\nfrom sys import stdin, stdout\\nfrom bisect import bisect_left\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    t = inp()\\n    for _ in xrange(t):\\n        n, m = inp()\\n        da = inp(True)\\n        ans = 0\\n        a = [0] * (m+1)\\n        for i in xrange(n):\\n            da[i] = da[i-1] + 1\\n            ans += da[i]\\n        print ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmy_main()\\n", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "8", "task_id": "88", "completion": "from __future__ import print_function, division\\nfrom sys import stdin, stdout\\nfrom collections import *\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, m = rints()\\n    a, ans = rints(), [0] * m\\n    prev, curr = [0] * m, [0] * n\\n    while prev < len(a):\\n        curr[prev] = a.pop(prev)\\n        ans[prev] += 1\\n        prev += 1\\n    for i in range(1, n):\\n        if prev[i - 1] >= a[i]:\\n            ans[i] -= 1\\n            prev = a[i]\\n    print(ans[n - 1] - ans[n - 1])\\n\\n", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "8", "task_id": "93", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    a,b = [int(x) for x in input().split()]\\n    if a > b:\\n        a,b = b,a\\n    if a == b:\\n        print 1\\n    elif b == a:\\n        print 2\\n    else:\\n        print 3", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "8", "task_id": "94", "completion": "t = input()\\nfor _ in xrange(t):\\n    n = input()\\n    ans = 0\\n    for i in xrange(1,n+1):\\n        ans += (n-i) / i\\n    print ans\\n", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "8", "task_id": "95", "completion": "for _ in range(input()):\\n    s, n = map(int, raw_input().split())\\n    if n == 1:\\n        print s\\n    else:\\n        print''.join(map(str, range(1, n + 1))[::-1])\\n\\n", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "8", "task_id": "98", "completion": "t=input()\\nfor i in range(t):\\n    n=input()\\n    s=raw_input()\\n    if n==1:\\n        print 1,1\\n    elif 'a' in s:\\n        print 1,1\\n    else:\\n        print -1,-1\\n", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "8", "task_id": "99", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    ans=\"\"\\n    a=list(s)\\n    if a.count('1')>1:\\n        for i in range(len(a)):\\n            if a[i]=='1':\\n                if a[i]=='1':\\n                    ans=ans+\"+\"\\n                else:\\n                    ans=ans+\"-\"\\n                a[i]=str(ans)\\n                a.remove('-')\\n                if a[i]=='X':\\n                    ans=ans+\"=\"\\n                else:\\n                    ans=ans+\"=\"\\n                a.remove('X')\\n        else:\\n            if a.count('X')>1:\\n                if a[i]=='1':\\n                    ans=ans+\"-\"\\n                a.remove('=')\\n            else:\\n                a.remove('-')\\n                if a[i]=='2':\\n                    ans=ans+\"+\"\\n                else:\\n                    ans=ans+\"=\"\\n                a.remove('X')\\n                if a[i]=='1':\\n                    a", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "8", "task_id": "100", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n = int(stdin.readline())\\n    a = map(int,stdin.readline().split())\\n    if n==2:\\n        print 0\\n        continue\\n    s = [0]\\n    p = [0]\\n    for i in a:\\n        s.append(p[i]+1)\\n    dp = [1]\\n    p.append(1)\\n    for i in range(2,n+1):\\n        dp[i] = (dp[i-1]+s[i-2])%998244353\\n    dp = [1]\\n    for i in range(n):\\n        for j in range(i+1,n+1):\\n            dp.append(dp[j]+dp[i-1])%998244353\\n    for i in range(n+1,n+1):\\n        dp.append(dp[i])\\n    print dp[n]\\n    ", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "8", "task_id": "101", "completion": "import atexit, io, sys \\n\\n  \\n# A stream implementation using an in-memory bytes  \\n# buffer. It inherits BufferedIOBase. \\n\\nbuffer = io.BytesIO() \\n\\nsys.stdout = buffer\\n\\n  \\n# print via here \\n\\n@atexit.register \\n\\ndef write(): \\n\\n    sys.__stdout__.write(buffer.getvalue())\\n\\nfor _ in range(input()):\\n    n,m,k = map(int,raw_input().split())\\n    x = map(int,raw_input().split())\\n    y = map(int,raw_input().split())\\n\\n    c1 = [[] for _ in range(n+1)]\\n    c2 = [[] for _ in range(m+1)]\\n\\n    for i in range(k):\\n        x,y = map(int,raw_input().split())\\n        c1[x].append(y)\\n        c2[y].append(x)\\n\\n    # print c1\\n    ans = 0\\n    for i in range(n):\\n        x.sort()\\n        y.sort()\\n       ", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "8", "task_id": "109", "completion": "for _ in range(input()):\\n    n=input()\\n    a=raw_input()\\n    b=[0]*100\\n    for i in a:\\n        b[int(i)]=b[int(i)]+1\\n    print min(abs(b[n-1]-b[n]),abs(b[n-1])+max(b[n-1]-b[n])-(n-1)*2,0)", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "8", "task_id": "110", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n = int(stdin.readline())\\n    a = [map(int,stdin.readline().split()) for _ in xrange(n)]\\n    f = 0\\n    for _ in xrange(n):\\n        for i in xrange(n):\\n            if a[i][0]!= f:\\n                f = 1\\n            if a[i][1]!= f:\\n                f = 1\\n    if f:\\n        print '1'\\n    else:\\n        print -1", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "8", "task_id": "111", "completion": "# cook your code here\\nimport os\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\\n\\nfor _ in xrange(int(input())):\\n    n = int(input())\\n    ans = []\\n    for i in xrange(2*n):\\n        if ans[i] == '(':\\n            ans[i-1] = '('\\n            ans[i-1] = ')'\\n            ans[i] = ')'\\n            ans[i] = ')'\\n            ans[i] = ')'\\n            ans[i-1] = '('\\n        elif ans[i] == ')':\\n            ans[i-1] = ')'\\n            ans[i-1] = ')'\\n    print('\\n'.join(ans))", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "8", "task_id": "112", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    kase = inp()\\n    for _ in range(kase):\\n        a, b, c, m = inp()\\n        print \"YES\" if all(c.values()) + any(a.values()) <= m else \"NO\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "8", "task_id": "113", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nn, a, m, m = int(input()), rints(), rints(), 0\\n\\nfor i in range(m):\\n    x, y = rints()\\n    a.sort(reverse = True)\\n    d = sum(a)\\n    i = 0\\n    while i < n and a[i] <= x:\\n        i += 1\\n    while a[i] > x:\\n        i += 1\\n\\n    if i == n - 1:\\n        while i < n - 1:\\n            a[i] -= a[i+1]\\n            i += 1\\n\\n    print(i)\\n", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "8", "task_id": "114", "completion": "import bisect\\nn=input()\\nc=[]\\na=[0]*(10**6)\\nfor _ in range(n):\\n    a[0]=map(int,raw_input().split())\\n    a[1]=map(int,raw_input().split())\\nfor _ in range(input()):\\n    b=[0]*(10**6+1)\\n    for i in range(n):\\n        if a[i][1]==0:\\n            a[i]=b[i][1]\\n        else:\\n            a[i]=b[i][0]\\nfor i in range(n):\\n    if a[i][1]==0:\\n        for j in range(i,i+1):\\n            if a[j][0]==j:\\n                a[j]=a[j][1]\\n                a[j]=a[j][1]\\n                break\\nfor i in range(len(a)):\\n    if a[i]==0:\\n        for j in range(i,i+1):\\n            if a[i]==0:", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "9", "task_id": "4", "completion": "n = input()\\nfor i in range(n):\\n\\tp = input()\\n\\tprint p, p/2+1\\n", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "9", "task_id": "5", "completion": "# cook your code here\\nt = int(raw_input())\\nfor i in xrange(t):\\n    n = int(raw_input())\\n    a = raw_input()\\n    b = raw_input()\\n    b1 = b1 = b[::]\\n    c = 0\\n    for j in xrange(n):\\n        if b[j]!= b[j-1]:\\n            c += 1\\n        else:\\n            c = 0\\n    print min(n-c,n-c+1)\\n", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "9", "task_id": "6", "completion": "from collections import defaultdict\\nn, m = map(int, raw_input().split())\\na = defaultdict(lambda: 0)\\nfor _ in range(m):\\n\\tu, v = map(int, raw_input().split())\\n\\ta[u].append(v)\\n\\ta[v].append(u)\\np = []\\nfor _ in range(m):\\n\\tu, v = map(int, raw_input().split())\\n\\tu = u - 1\\n\\tv = v - 1\\n\\tif a[u][v] > a[v][u]:\\n\\t\\tp.append(a[u][v])\\n\\telif a[u][v] > a[v][u]:\\n\\t\\tp.append(a[u][v])\\n\\nq = int(raw_input())\\nfor _ in range(q):\\n\\tu, v = map(int, raw_input().split())\\n\\tprint p[u]", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "9", "task_id": "7", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n = int(stdin.readline())\\n    a = map(int,stdin.readline().split())\\n    k = [0]*(n+2)\\n    for i in xrange(n-1,-1,-1):\\n        k[i+1] = (k[i] + k[i+1])/2\\n    ans = 1\\n    for i in xrange(1,n+1):\\n        if k[i]%k[i-1]!=1:\\n            ans+=1\\n    print ans\\n", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "9", "task_id": "8", "completion": "from __future__ import division\\nfrom sys import stdin, stdout\\nfrom fractions import gcd\\n# from math import *\\nfrom collections import *\\nfrom operator import mul\\nfrom functools import reduce\\nfrom copy import copy\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\narr_2d = lambda n: [rints() for i in range(n)]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n = rint()\\n    ans1, ans2 = 0, 0\\n\\n    while n % 2:\\n        ans1 += n // 2\\n        n //= 2\\n        ans2 += n // 2\\n\\n        n //= 2\\n\\n    print('%d %d' % (ans1, ans2))", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "9", "task_id": "9", "completion": "import math\\n\\ndef solve(s):\\n  c = [0]\\n  for i in range(len(s)):\\n    c.append(ord(s[i]) - 97)\\n  return len(c)\\n\\ndef main():\\n  T = int(raw_input())\\n  for _ in range(T):\\n    s = raw_input()\\n    print solve(s)\\n\\nif __name__ == \"__main__\":\\n  main()\\n", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "9", "task_id": "10", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n \\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n,k = RI()\\n    arr = RI()\\n    d = {}\\n    for i in xrange(n):\\n        d[arr[i]] = 0\\n    for i in xrange(n):\\n        d[arr[i]] += 1\\n    ans = []\\n    for i in xrange(n):\\n        if i>=k:\\n            ans.append(i)\\n        else:\\n            ans.append(k)\\n    for i in", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "9", "task_id": "11", "completion": "from __future__ import division\\nfrom sys import stdin, stdout\\nfrom collections import *\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, a = rint(), [rstr() for _ in range(n)]\\n    ans = [0] * 26\\n    cur = Counter()\\n    for c in a:\\n        cur[c] += 1\\n    cur['a'] = 1\\n    for c in 'abc':\\n        cur['b'] += 1\\n        cur['c'] += 1\\n    for c in 'abc':\\n        cur['d'] += 1\\n        cur['e'] += 1\\n    out.append(len(cur['a']))\\n\\nstdout.write('\\n'.join(str(x) for x in out))\\n", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "9", "task_id": "12", "completion": "from sys import stdin, stdout  \\n  \\ndef main(): \\n\\tN = int(stdin.readline().strip())\\n\\tfor ti in range(N): \\n\\t\\tarr = map(int, stdin.readline().strip().split())\\n\\t\\tn = arr[0]\\n\\t\\tm = arr[1]\\n\\t\\tk = arr[2]\\n\\t\\tif k%2==1:\\n\\t\\t\\tstdout.write(\"NO\\n\")\\n\\t\\t\\tcontinue \\n\\t\\tn = n%2\\n\\t\\tm = m%2\\n\\t\\tif m%2==1:\\n\\t\\t\\tif n%2==0:\\n\\t\\t\\t\\tstdout.write(\"YES\\n\")\\n\\t\\t\\t\\tcontinue \\n\\t\\t\\telse:\\n\\t\\t\\t\\tif m%2==0:\\n\\t\\t\\t\\t\\tstdout.write(\"YES\\n\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif k<(n//2):\\n\\t\\t\\t\\t\\tstdout.write(\"NO\\n\")\\n\\t\\t\\t\\tcontinue \\n\\t\\telse:\\n\\t\\t\\tif k>(n//2)+m:\\n\\t\\t\\t\\tstdout.write(\"NO\\n\")\\n\\t\\t\\t\\tcontinue \\n\\t\\t\\tstdout.write(\"NO\\n\")\\n\\nmain()", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "9", "task_id": "16", "completion": "t = int(raw_input())\\n\\nfor i in range(t):\\n    n = int(raw_input())\\n    s = raw_input()\\n    c = 0\\n    for i in range(n):\\n        if s[i] < s[i-1]:\\n            c += 1\\n\\n    print min(c, n-c)\\n", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "9", "task_id": "17", "completion": "t = input()\\nfor _ in range(t):\\n    n = input()\\n    p = [0]*5\\n    for i in range(n):\\n        p[raw_input()] = [0]*5\\n    m = set()\\n    for i in range(n):\\n        p[i] = map(int,i+1)\\n    for i in p:\\n        m.add(i)\\n    for i in range(n):\\n        if m[i] > i+1:\\n            print i+1\\n            break\\n    if m:\\n        print -1", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "9", "task_id": "18", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    n, k = map(int, stdin.readline().split())\\n    ans = 0\\n    p = [[] for _ in range(n)]\\n    for _ in range(k):\\n        x, y = map(int, stdin.readline().split())\\n        p[x].append(y)\\n        p[y].append(x)\\n    ans += n - 1\\n    p = sorted(p, key=lambda x: x[0])\\n    for x, y in p:\\n        ans += (n - k) * x - (y[1] + 1) * x\\n    print(ans)", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "9", "task_id": "19", "completion": "for _ in range(input()):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    ans = 'NO'\\n    b = []\\n    for i in range(n):\\n        if a[i] < 0:\\n            b.append(a[i])\\n        elif a[i] < 0:\\n            b.append(a[i])\\n    if len(b) % n == 0:\\n        ans = 'YES'\\n    print ans\\n", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "9", "task_id": "20", "completion": "n, k = map(int, raw_input().split())\\na = [0] * n\\nfor i in xrange(n):\\n    a[i] = map(int, raw_input().split())\\n\\nans = [0] * k\\nidx = [0] * n\\nfor i in xrange(k):\\n    idx[a[i] - 1] = i\\nfor i in xrange(n):\\n    if idx[a[i]] > 1:\\n        idx[a[i]] -= 1\\n        idx[a[i]] -= 1\\n    else:\\n        idx[a[i]] = i\\n\\nfor i in xrange(n):\\n    print idx[i], idx[a[i]]", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "9", "task_id": "21", "completion": "n = int(raw_input())\\n\\narr = [map(int, raw_input().split()) for _ in range(n)]\\n\\ndp = [0] * n\\nfor i in range(n):\\n    dp[i][0] = arr[i][1]\\n\\nfor i in range(n):\\n    for j in range(i + 1, n):\\n        if arr[i][j] == 0:\\n            continue\\n        elif arr[i][j] == arr[i - 1][0]:\\n            dp[i][j] = dp[i - 1][j - 1] + arr[i][j - 1] + (dp[i - 1][j - 1] - arr[i][j]) % 998244353\\n        else:\\n            dp[i][j] = (dp[i - 1][j] + arr[i][j - 1]) % 998244353\\nprint dp[n]", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "9", "task_id": "24", "completion": "n=int(raw_input())\\nfor i in xrange(n):\\n    d=int(raw_input())\\n    c=0\\n    while d!=0:\\n        d=str(d)\\n        if len(d)==1:\\n            print 0\\n        elif len(d)==2:\\n            print 1\\n        elif len(d)==3:\\n            print 1\\n        elif len(d)==4:\\n            print 1\\n        elif len(d)==5:\\n            print 1\\n        else:\\n            print 2\\n", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "9", "task_id": "25", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nq = inp[ii]; ii += 1\\n\\nout = []\\n\\nfor _ in range(q):\\n    s = inp[ii]; ii += 1\\n    t = inp[ii]; ii += 1\\n\\n    r = -1\\n    l = -1\\n    l = -1\\n    i = 0\\n    for c in s:\\n        if c == 'a':\\n            l = i\\n            break\\n        i += 1\\n\\n    for c in t:\\n        if c == 'b':\\n            r = i\\n            break\\n\\n    if l == -1:\\n        out.append('YES')\\n    else:\\n        out.append('NO')\\n\\nprint '\\n'.join(out)\\n", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "9", "task_id": "26", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nt = inp[ii]; ii += 1\\nfor _ in range(t):\\n    s = inp[ii]; ii += 1\\n    ans = 0\\n    for c in s:\\n        if c == '?':\\n            ans += 1\\n        else:\\n            if ans < 0:\\n                ans += 1\\n            else:\\n                ans += 1\\n    print ans", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "9", "task_id": "27", "completion": "t = int(raw_input())\\nfor _ in xrange(t):\\n    s = list(raw_input())\\n    t = list(raw_input())\\n    i = 0\\n    s = []\\n    while i < len(s) and s[i] == t[i-1]:\\n        i += 1\\n    j = 0\\n    while j < len(t):\\n        if s[j] == t[i]:\\n            j += 1\\n        else:\\n            s.append(t[j])\\n            j += 1\\n    if s == t:\\n        print \"YES\"\\n    else:\\n        print \"NO\"", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "9", "task_id": "28", "completion": "for _ in range(input()):\\n    n, m = map(int, raw_input().split())\\n    p = map(int, raw_input().split())\\n\\n    p.reverse()\\n    l = n/2 - 1\\n    while l >= 0:\\n        p = p[:l] + p[:l] + p[:l+1]\\n        l -= 1\\n\\n    print m + n\\n    for i in range(n):\\n        print p[i],\\n", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "9", "task_id": "33", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    A = [int(x) for x in input().split()]\\n    A.sort()\\n    print A[-1] * min(A)", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "9", "task_id": "34", "completion": "for _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    r=[0]*n\\n    for i in range(n):\\n        j=i\\n        while j:\\n            r[j]^=a[j]\\n            j-=1\\n            r[j]=r[j+1]+1\\n    r.sort()\\n    r.reverse()\\n    a=r[::-1]\\n    for i in range(k):\\n        for j in range(n):\\n            r[j]+=a[i]\\n    b=a[k-1]\\n    c=0\\n    for i in range(n):\\n        for j in range(n):\\n            if j&(k-1):\\n                c+=2\\n            if b:\\n                c+=2\\n            else:\\n                c-=1\\n        b=c\\n    if c:\\n        print r[n-1]\\n    else:\\n        print -1", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "9", "task_id": "35", "completion": "for _ in xrange(input()):\\n    n,m=map(int,raw_input().split())\\n    if n<m:\\n        print n\\n    else:\\n        r=n\\n        while m>0:\\n            r/=2\\n            if r%2==1:\\n                n-=1\\n            else:\\n                n+=1\\n        print m-n\\n\\n\\n", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "9", "task_id": "36", "completion": "for _ in range(input()):\\n    n=input()\\n    s=''\\n    for i in range(n):\\n        if i%2==0:\\n            s+=chr(i)\\n        else:\\n            s+=chr(i+1)\\n    print s", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "9", "task_id": "38", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n = int(stdin.readline())\\n    print (3 * n - 7) * 60 + (n - 6) * 15", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "9", "task_id": "39", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in range(t):\\n    w, h = map(int, stdin.readline().split())\\n    a, b, c, d = map(int, stdin.readline().split())\\n    x, y = map(int, stdin.readline().split())\\n    if w > c:\\n        w -= 1\\n        if y > d:\\n            h -= 1\\n        if x < d:\\n            h += 1\\n    print(max(0, abs(x - c) + abs(y - d)), min(w, h))", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "9", "task_id": "40", "completion": "for _ in range(input()):\\n    n=input()\\n    a=[]\\n    for _ in range(n):\\n        a.append(map(int,raw_input().split()))\\n    p=0\\n    for i in range(2):\\n        b=[]\\n        for j in range(2):\\n            b.append(a[i][j]-a[j-1][j-1])\\n        p+=b[-1][-1]\\n    print(p)\\n    \\n        \\n", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "9", "task_id": "41", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\\n\\nn = inp[ii]; ii += 1\\nm = inp[ii]; ii += 1\\n\\nS = inp[ii: ii + n]; ii += n\\n\\ndp = [[0 for i in range(n + 3)] for j in range(n + 3)]\\n\\nfor i in range(m):\\n    l,r = inp[ii]; ii += 1\\n    print (max(dp[l - 1][r - 1] - 1, dp[r - 1][l - 1]) - min(dp[l - 1][l - 1]) + 1)\\n", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "9", "task_id": "44", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    kase = inp()\\n    for _ in range(kase):\\n        c, d = inp()\\n        if c == 0 and d == 0:\\n            print 0\\n            continue\\n        c_cnt = 0\\n        c_cnt += 1\\n        c_cnt -= 1\\n        c_cnt = 0\\n        for i in range(3):\\n            if c_cnt == 0:\\n                break\\n            if c_cnt == 0:\\n                c_cnt += 1", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "9", "task_id": "45", "completion": "t=int(raw_input())\\nfor i in range(t):\\n    n=int(raw_input())\\n    arr=map(int,raw_input().split())\\n    ans=0\\n    ans+=1\\n    d=[]\\n    for j in range(n):\\n        if arr[j]==1:\\n            if arr[j]>2:\\n                ans+=1\\n                d.append(j-i)\\n                d.append(j-i)\\n            elif arr[j]==1:\\n                ans+=2\\n                d.append(j-i)\\n        if arr.count(0)==1:\\n            if arr.count(1)==2:\\n                ans+=1\\n                d.append(j-i)\\n                d.append(j-i)\\n    if ans<2:\\n        ans-=2\\n    print ans", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "9", "task_id": "46", "completion": "n = int(raw_input())\\nc = map(int, raw_input().split())\\n\\ndp = [0] * (n + 1)\\n\\ndp[0] = 0\\n\\nfor x in c:\\n\\tif x % 2 == 1:\\n\\t\\tdp[1] += 1\\n\\telse:\\n\\t\\tdp[1] -= 1\\n\\t\\tif dp[1] % 2 == 1:\\n\\t\\t\\tdp[2] += 1\\n\\n#print dp\\n\\n\\n\\ndp[0] = 0\\n\\nfor i in range(1, n + 1):\\n\\tif dp[i - 1] >= 1:\\n\\t\\tdp[i] += dp[i - 1]\\n\\nprint dp[n]", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "9", "task_id": "52", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = stdin.readline\\npr = stdout.write\\n\\n\\ndef in_arr():\\n    return map(int,raw_input().split())\\n\\n\\ndef pr_num(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\ndef pr_arr(arr):\\n    pr(' '.join(map(str,arr)))\\n\\n\\ndef pr_arr(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers\\n    # Use Ctrl+D to flush stdin.\\n    return(stdin.readline().rstrip())\\n\\nrange = xrange # not for python 3.0+\\n\\n# main code\\n\\nt=input()\\nfor _ in range(t):\\n    n=input()\\n    arr=in_arr()\\n    ans=0\\n    for i in range(n):\\n        ans+=arr[i]*arr", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "9", "task_id": "53", "completion": "from __future__ import division, print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor zorg in range(int(le.pop())):\\n    n,k=list(map(int,le.pop().split()))\\n    a=list(map(int,le.pop().split()))\\n    n-=1\\n    for i in range(n):\\n        if i==0:\\n            continue\\n        a[i]-=1\\n        af.append(\"YES\" if a[k] else \"NO\")\\nprint(\"\\n\".join(af))\\n", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "9", "task_id": "54", "completion": "from __future__ import division,print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf=[]\\nfor zorg in range(int(le.pop())):\\n    n,k=list(map(int,le.pop().split()))\\n    if k==0:\\n        print(1)\\n    else:\\n        o=pow(2,k-1,1000000007)-1\\n        print(o*(o-1))%(1000000007)\\n", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "9", "task_id": "60", "completion": "\\nfor _ in range(input()):\\n    n=input()\\n    a=map(int,raw_input().split())\\n    x=[]\\n    for i in range(n):\\n        x.append(a[i]&a[i+1])\\n    m=0\\n    for i in range(n):\\n        m=max(m,x[i]&x[n-i-1])\\n    print m\\n", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "9", "task_id": "61", "completion": "t = input()\\nfor _ in range(t):\\n    n = input()\\n    s = raw_input()\\n    ans = ''\\n    for i in range(n):\\n        if s[i]!= '?' and s[i]!= s[i + 1]:\\n            if s[i] == s[i + 1]:\\n                if s[i] == s[i + 2]:\\n                    ans += 'B'\\n                    s[i] = 'R'\\n                    s[i + 1] = 'B'\\n                elif s[i] == '?':\\n                    ans += 'B'\\n                    s[i] = 'R'\\n            elif s[i] == s[i + 1]:\\n                if s[i] == '?':\\n                    ans += 'R'\\n                elif s[i] == '?' and s[i + 1] == '?':\\n                    ans += 'B'\\n                    s[i + 1] = 'B'\\n            else:\\n                if s[i] == '?' and s[i + 1] == '?':\\n                    ans += 'R'\\n                    s[i + 2] = '", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "9", "task_id": "62", "completion": "for _ in range(input()):\\n    n=input()\\n    a=[0]*n\\n    a=map(int,raw_input().split())\\n    for i in range(n):\\n        if a[i]==1:\\n            print i+1,\\n        else:\\n            print a[i],\\n    print \\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "9", "task_id": "66", "completion": "import sys\\n\\ninp = sys.stdin.read().splitlines()\\n\\ndef solve():\\n    n = int(inp[0])\\n    a = [0]*1000\\n    while n>0:\\n        n -= 1\\n        a[3] = a[3] + 1\\n        n /= 3\\n    print a[n-1]\\n\\nt = int(inp[0])\\nfor _ in range(t):\\n    solve()", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "9", "task_id": "67", "completion": "\\nimport sys\\n\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................... '''\\n\\nfor _ in xrange(RN()):\\n    a,b,c = RI()\\n    if a%c==0:\\n        if b%c==0:\\n            print c\\n            continue\\n        else:\\n            print -1\\n        continue\\n    a -= 1\\n    if b%c==0:\\n        print -1\\n    else:\\n        print c\\n\\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "9", "task_id": "68", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    k = int(input())\\n    x = []\\n    for i in range(len(range(1, len(range(1, len(range(1, len(range(1, len(range(1, len(input)) + 1) - 1) + 1) - 1) + 1, 2))):\\n        x.append(i)\\n    x = x[::-1]\\n    print x.index(n) + 1, x.index(n) + 1\\n", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "9", "task_id": "69", "completion": "def count(n):\\n    cnt = 0\\n    while n!= 0:\\n        cnt += 1\\n        n /= 2\\n    return cnt\\n\\n\\nfor _ in xrange(int(raw_input())):\\n    n = int(raw_input())\\n    res = count(n)\\n    if res == 0:\\n        print len(str(n)) - res\\n    else:\\n        n += count(n) - res\\n        print len(str(n)) - res\\n", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "9", "task_id": "70", "completion": "t=int(input())\\nfor i in range(t):\\n\\ts=raw_input()\\n\\tfor i in range(len(s)):\\n\\t\\tc=s[i]\\n\\t\\tif c==s[i]:\\n\\t\\t\\tprint -1\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]==c:\\n\\t\\t\\tprint -1\\n\\t\\t\\tcontinue\\n\\t\\ti=s.find(c)\\n\\t\\tif s[i+1]==s[i+2]:\\n\\t\\t\\tif s[i+2]==c:\\n\\t\\t\\t\\tprint i,\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprint -1\\n\\t\\t\\t\\tcontinue\\n\\t\\tprint s[i],\\n\\tprint\\n\\t\\t\\n\\n", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "9", "task_id": "71", "completion": "from collections import defaultdict\\nt = int(raw_input())\\nfor _ in xrange(t):\\n    n, k = map(int, raw_input().split())\\n    res = str(n)\\n    k_num = k\\n    while k_num >= 0:\\n        if k == 2:\\n            res += str(n)\\n        else:\\n            k_num -= 1\\n        res += str(n) + \"0\"\\n    print res", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "9", "task_id": "72", "completion": "for _ in range(input()):\\n    n,k=map(int,raw_input().split())\\n    l=[]\\n    i=0\\n    while i<10:\\n        i+=1\\n        l.append(str(i))\\n        if k==10:\\n            i+=1\\n    l=sorted(l,key=lambda x:x[0])\\n    if k==1:\\n        for j in l:\\n            if int(j[0])<=int(k):\\n                break\\n        print ''.join(l[1:])\\n    else:\\n        l.reverse()", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "9", "task_id": "73", "completion": "for _ in range(input()):\\n    n = input()\\n    a = map(int,raw_input().split())\\n    ans = 0\\n    for i in range(1,n):\\n        if a[i] > a[i-1]:\\n            ans+=1\\n    print ans\\n", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "9", "task_id": "74", "completion": "for _ in range(input()):\\n    a,b=map(int,raw_input().split())\\n    ans=[2,1,0]\\n    print(ans[0]+ans[1])\\n    for i in range(a,b+1):\\n        ans[i]-=2\\n    print(len(ans))\\n    for i in ans:\\n        print(i),\\n    print(len(ans))\\n", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "9", "task_id": "75", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n \\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n = RN()\\n    a = RI()\\n    ans = 0\\n    for i in xrange(n-1):\\n        k = RI()\\n        if k==1:\\n            a[k-1] = min(a[k-1],a[k])\\n        elif k==2:\\n            a[k] = min(a[k-1],a[k])\\n        else:\\n            ans += 1\\n    print ans\\n", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "9", "task_id": "76", "completion": "n, m = map(int, raw_input().split())\\nans = 1\\nfor i in xrange(n):\\n    ans = (ans * (i + 1)) % m\\nprint ans\\n", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "9", "task_id": "77", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef main():\\n    n,m=map(int,stdin.readline().split())\\n    t=1\\n    for i in xrange(2,n+1):\\n        t*=i%m\\n    print t\\nmain()", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "9", "task_id": "78", "completion": "for _ in range(input()):\\n    l,r=[int(x) for x in raw_input().split()]\\n    print (r-l+1)//2\\n", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "9", "task_id": "79", "completion": "t = input()\\nwhile t>0:\\n    t-=1\\n    n = input()\\n    s = raw_input()\\n    a = list(s)\\n    a.sort(reverse=True)\\n    for i in xrange(len(a)):\\n        if a[i] == '2':\\n            break\\n    for i in xrange(len(a)):\\n        if a[i] == '4':\\n            continue\\n        for j in xrange(i, len(a)):\\n            if a[j] == '3':\\n                break\\n            a[j] = '4'\\n    print len(a)\\n    print''.join(a)\\n", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "9", "task_id": "80", "completion": "for _ in range(input()):\\n    n = input()\\n    s = raw_input()\\n    c = []\\n    for i in range(n):\\n        if s[i] == '0':\\n            c.append(i)\\n        else:\\n            c.append(i)\\n    s1 = c[:]\\n    s2 = c[:]\\n    print len(s1), len(s2), len(s1), len(s2), len(s1), len(s2)\\n    for i in range(len(s2)):\\n        print s1, s2[i], s1[i]\\n", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "9", "task_id": "81", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n\\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n,q = RI()\\n    s = RI()\\n    res = 0\\n\\n    pos = [0]*(n+1)\\n    ans = 1\\n    for i in xrange(q):\\n        l,r = RI()\\n        if s[l]=='+':\\n            pos[r] = 0\\n        else:\\n            pos[l] += 1\\n\\n        if pos[r]=='-':\\n            pos[r] -= 1", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "9", "task_id": "84", "completion": "t=input()\\nwhile t:\\n    t-=1\\n    n,s=map(int,raw_input().split())\\n    if n==1:\\n        print 0\\n    else:\\n        if n>s:\\n            print n\\n        else:\\n            i=s//(n-1)\\n            print i+1\\n", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "9", "task_id": "85", "completion": "for _ in range(input()):\\n    s=raw_input()\\n    count=[]\\n    for i in range(len(s)):\\n        if s[i]==\"1\":\\n            count.append(0)\\n        else:\\n            count[1]+=1\\n    ans=0\\n    for i in count:\\n        if i!=0:\\n            ans+=1\\n    print ans", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "9", "task_id": "86", "completion": "t = input()\\nfor _ in xrange(t):\\n    n = input()\\n    s = raw_input()\\n    b = []\\n    for x in xrange(n):\\n        a = raw_input()\\n        b.append(int(a,2))\\n    s = sum(b)\\n    d = [2 ** i for i in xrange(n)]\\n    for x in xrange(n):\\n        if x % 2:\\n            s += min(b[x][0],b[x][1])\\n        else:\\n            s += min(b[x][1],b[x][0])\\n    d.append(s)\\n    res = sum(d)\\n    print res\\n", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "9", "task_id": "87", "completion": "t=input()\\nfor _ in range(t):\\n    n,m=map(int,raw_input().split())\\n    arr=map(int,raw_input().split())\\n    ans=0\\n    a=[0]*m\\n    for i in range(1,n+1):\\n        a[i-1]+=1\\n    j=n-1\\n    while j>=0:\\n        if arr[j]<arr[j-1]:\\n            j-=1\\n            ans+=1\\n        j-=1\\n        a[j]-=1\\n    print ans", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "9", "task_id": "88", "completion": "# cook your code here\\nfor _ in xrange(input()):\\n    n, m = map(int, raw_input().split())\\n    a = map(int, raw_input().split())\\n    a.sort()\\n    a = [0] * m\\n    x = 0\\n    for i in xrange(1, n+1):\\n        if a[i-1] > a[i]:\\n            x += a[i]\\n        else:\\n            break\\n    if x > m:\\n        x -= 1\\n    print x\\n", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "9", "task_id": "93", "completion": "for _ in range(input()):\\n    a, b = map(int, raw_input().split())\\n    if a == b:\\n        print 3\\n    elif a < b:\\n        print 2\\n    else:\\n        print 3", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "9", "task_id": "94", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    if n == 2:\\n        print 9\\n    else:\\n        a = (n + 1) / 2\\n        a = a / 2\\n        print a * (a + 1) / 2\\n", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "9", "task_id": "95", "completion": "for _ in range(input()):\\n    s,n=map(int,raw_input().split())\\n    if n==1:\\n        print s\\n        continue\\n    ans=[]\\n    for i in range(0,n):\\n        ans.append(str(s%i))\\n    while n:\\n        ans.append(str(10*s%i))\\n        n/=10\\n    print''.join(ans)\\n", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "9", "task_id": "98", "completion": "import sys\\n\\n__author__ = 'abbas'\\n\\nfrom collections import deque\\n\\n__import__ ='mroher'\\n\\n\\n\\ndef solve():\\n    [t] = [int(i) for i in sys.stdin.readline().split()]\\n    print(' '.join(map(str, sorted(list(sys.stdin.readline().strip()))) + '\\n')\\n\\n\\n\\ndef solve():\\n    [t] = [int(i) for i in sys.stdin.readline().split()]\\n    st = [int(i) for i in sys.stdin.readline().strip()]\\n\\n    a = [0] * t\\n    b = [0] * t\\n\\n    for i in xrange(0, t):\\n        if st[i] == 'a':\\n            a[i] = a[i - 1] + 1\\n            b[i] = b[i - 1] + 1\\n\\n    ans = []\\n    for i in xrange(1, t):\\n        if st[i] == 'b':\\n            a[i] = a[i - 1", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "9", "task_id": "99", "completion": "# cook your code here\\n\\nfor _ in range(int(raw_input())):\\n    n = int(raw_input())\\n    s = raw_input()\\n    ans = []\\n    i, j = 0, 0\\n    while i < n:\\n        if s[i] == 1:\\n            ans.append('+')\\n            i += 1\\n        elif s[i] == 2:\\n            ans.append('+')\\n            i += 1\\n        elif s[j] == 1:\\n            ans.append('-')\\n            i += 1\\n        else:\\n            j += 1\\n    print 'YES'\\n    print '\\n'.join(ans)\\n", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "9", "task_id": "100", "completion": "from __future__ import division,print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf=[]\\nmod=998244353\\nfor u in range(int(le.pop())):\\n    n=int(le.pop())\\n    l=list(map(int,le.pop().split()))\\n    c=0\\n    x=0\\n    y=0\\n    for v in l:\\n        x+=v\\n        y+=v\\n        c+=1\\n    af.append(int(ceil(x/2.0)*(y%mod)))\\nprint(\"\\n\".join(map(str,af)))\\n", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "9", "task_id": "101", "completion": "for _ in range(input()):\\n    n,m,k=map(int,raw_input().split())\\n    x=list(map(int,raw_input().split()))\\n    y=list(map(int,raw_input().split()))\\n    z=[]\\n    for _ in range(k):\\n        a,b=map(int,raw_input().split())\\n        z.append([a,b])\\n    z.sort()\\n    z.sort()\\n    ans=0\\n    for i in range(n):\\n        if i[0]<z[i[1]][0]:\\n            ans+=2\\n        elif z[i[0]][1]>z[i[1]][0]:\\n            ans+=2\\n    print ans", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "9", "task_id": "109", "completion": "for t in range(input()):\\n    n=input()\\n    a=raw_input()\\n    if n==1:\\n        print 0\\n        continue\\n    cnt=0\\n    for i in range(n-1):\\n        if a[i]==0:\\n            cnt+=1\\n            a[i]=0\\n        else:\\n            cnt+=1\\n    print min(cnt,n-cnt)\\n", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "9", "task_id": "110", "completion": "from sys import stdin\\n\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, ans = rint(), rints()\\n    cur, cur_arr = n - 1, n - 1\\n    while cur_arr:\\n        cur_arr.pop(cur_arr.pop(cur_arr.pop(cur_arr.pop(cur_arr.pop(cur_arr.pop(cur_arr.pop(cur_arr.pop(0).pop(0))) + 1))\\n        cur_arr.append(cur_arr.pop(cur_arr.pop(cur_arr.pop(cur_arr.pop(cur_arr.pop(0))))\\n\\n    if not ans:\\n        out.append(\"-1\")\\n\\nprint('\\n'.join(map(str, out)))\\n", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "9", "task_id": "111", "completion": "from __future__ import print_function, division\\nfrom sys import stdin, stdout\\nfrom fractions import gcd\\nfrom math import *\\nfrom collections import *\\nfrom operator import mul\\nfrom functools import reduce\\nfrom copy import copy\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\narr_2d = lambda n: [rints() for i in range(n)]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, ans = rint(), []\\n    for i in range(n):\\n        ans.append('(')\\n        ans.append(')')\\n    ans.append('\\n')\\n    for i in ans:\\n        print(i)\\n", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "9", "task_id": "112", "completion": "for _ in range(input()):\\n    a,b,c,m=map(int,raw_input().split())\\n    a,b,c,m=sorted(a),sorted(b),sorted(c)\\n    if m==0:\\n        if a!=b:\\n            print \"YES\"\\n        else:\\n            print \"NO\"\\n    else:\\n        print \"YES\"\\n", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "9", "task_id": "113", "completion": "n=input()\\na=map(int,raw_input().split())\\nm=input()\\na=sorted(a)\\n\\ns=0\\nfor i in range(m):\\n    x,y=map(int,raw_input().split())\\n    p=a[0]\\n    p1=a[1]\\n    p2=a[0]\\n    q=a[0]\\n    while p<x:\\n        p=q+1\\n        q=q-1\\n    t=p1+q\\n    while p<=x:\\n        p=q+1\\n    print t\\n\\n", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "9", "task_id": "114", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nn = int(input())\\nA = [0] * n\\nfor i in range(n):\\n    A[i] = [int(x) for x in input().split()]\\n\\nm = int(input())\\n\\nB = [0] * m\\n\\nfor i in range(m):\\n    A[i] = [int(x) for x in input().split()]\\n\\nans = []\\nfor i in range(m):\\n    B[i] = [int(x) for x in input().split()]\\n\\nbanned = [0] * m\\nfor i in range(m):\\n    banned[B[i]] = [i] * m\\n\\nfor i in range(m):\\n    if B[i] in B:\\n        for j in range(i, n):\\n            if banned[j] == i:\\n                continue\\n            if a[i] > ans[j]:\\n                ans[j] = a[i]\\n\\nans.sort()\\n\\nans = sorted(ans, key = lambda (x", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
{"epoch": "10", "task_id": "4", "completion": "def f(a):\\n    a, b = 0, 0\\n    while a < len(a):\\n        if a % 2 == 0:\\n            a, b = a, b + 1\\n        else:\\n            break\\n    return b, a\\n\\nt = int(raw_input())\\n\\nwhile t > 0:\\n    a = int(raw_input())\\n    f(a)\\n    f(a + 1)\\n", "prompt": "Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\\n\\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\\n\\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \\n  * 2 \u2264 a < b \u2264 P. \\n\\n\\n\\nHelp Gregor find two bases of his favorite prime number!\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\\n\\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n17\\n5\\n\\n\\nOutput\\n\\n\\n3 5\\n2 4\\n\\nNote\\n\\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\\n\\nIn the second query, with P=5, the only solution is a=2 and b=4."}
{"epoch": "10", "task_id": "5", "completion": "from sys import stdin, stdout\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n = int(stdin.readline())\\n    s = stdin.readline()\\n    e = stdin.readline()\\n    dp = [0 for i in xrange(n)]\\n    for i in xrange(n):\\n        dp[i] = s[i]\\n        if i == n - 1:\\n            dp[i + 1] += 1\\n        else:\\n            dp[i] += 1\\n    dp[0] = 0\\n    dp[0] = 0\\n    if s[0] == s[n - 1]:\\n        dp[0] = max(dp[0], n - 1)\\n    else:\\n        dp[0] = max(dp[0], n - 1)\\n    dp[n - 1] = max(dp[n - 1], n - 1)\\n    stdout.write(str(dp[0]) + '\\n')\\n", "prompt": "There is a chessboard of size n by n. The square in the i-th row from top and j-th column from the left is labelled (i,j).\\n\\nCurrently, Gregor has some pawns in the n-th row. There are also enemy pawns in the 1-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from (i,j) to (i-1,j)) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from (i,j) to either (i-1,j-1) or (i-1,j+1)) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\\n\\nGregor wants to know what is the maximum number of his pawns that can reach row 1?\\n\\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row 1, it is stuck and cannot make any further moves.\\n\\nInput\\n\\nThe first line of the input contains one integer t (1\u2264 t\u2264 2\u22c5 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of three lines. The first line contains a single integer n (2\u2264 n\u2264 2\u22c5{10}^{5}) \u2014 the size of the chessboard.\\n\\nThe second line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nThe third line consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.\\n\\nIt is guaranteed that the sum of n across all test cases is less than 2\u22c5{10}^{5}.\\n\\nOutput\\n\\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the 1-st row.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n000\\n111\\n4\\n1111\\n1111\\n3\\n010\\n010\\n5\\n11001\\n00000\\n\\n\\nOutput\\n\\n\\n3\\n4\\n0\\n0\\n\\nNote\\n\\nIn the first example, Gregor can simply advance all 3 of his pawns forward. Thus, the answer is 3.\\n\\nIn the second example, Gregor can guarantee that all 4 of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\\n\\n<image>\\n\\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\\n\\nIn the fourth example, Gregor has no pawns, so the answer is clearly 0."}
{"epoch": "10", "task_id": "6", "completion": "import os, sys\\nfrom atexit import register\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\\n\\nn, m = map(int, input().split())\\n\\narr = []\\n\\nfor i in range(m):\\n\\tarr.append(tuple(map(int, input().split())))\\n\\nq = int(input())\\n\\nfriends = [False] * n\\n\\ncurr = [0] * n\\n\\ncurr[0] = 1\\n\\nfor i in range(1, n + 1):\\n\\tcurr[i] = curr[i - 1] + 1\\n\\nfor i in range(q):\\n\\tu, v = input().split()\\n\\tu -= 1\\n\\tv -= 1\\n\\n\\tif u == v:\\n\\t\\tcurr", "prompt": "When you play the game of thrones, you win, or you die. There is no middle ground.\\n\\nCersei Lannister, A Game of Thrones by George R. R. Martin\\n\\nThere are n nobles, numbered from 1 to n. Noble i has a power of i. There are also m \"friendships\". A friendship between nobles a and b is always mutual.\\n\\nA noble is defined to be vulnerable if both of the following conditions are satisfied: \\n\\n  * the noble has at least one friend, and \\n  * all of that noble's friends have a higher power. \\n\\n\\n\\nYou will have to process the following three types of queries. \\n\\n  1. Add a friendship between nobles u and v. \\n  2. Remove a friendship between nobles u and v. \\n  3. Calculate the answer to the following process. \\n\\n\\n\\nThe process: all vulnerable nobles are simultaneously killed, and all their friendships end. Then, it is possible that new nobles become vulnerable. The process repeats itself until no nobles are vulnerable. It can be proven that the process will end in finite time. After the process is complete, you need to calculate the number of remaining nobles.\\n\\nNote that the results of the process are not carried over between queries, that is, every process starts with all nobles being alive!\\n\\nInput\\n\\nThe first line contains the integers n and m (1 \u2264 n \u2264 2\u22c5 10^5, 0 \u2264 m \u2264 2\u22c5 10^5) \u2014 the number of nobles and number of original friendships respectively.\\n\\nThe next m lines each contain the integers u and v (1 \u2264 u,v \u2264 n, u \u2260 v), describing a friendship. No friendship is listed twice.\\n\\nThe next line contains the integer q (1 \u2264 q \u2264 2\u22c5 {10}^{5}) \u2014 the number of queries. \\n\\nThe next q lines contain the queries themselves, each query has one of the following three formats. \\n\\n  * 1 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 add a friendship between u and v. It is guaranteed that u and v are not friends at this moment. \\n  * 2 u v (1 \u2264 u,v \u2264 n, u \u2260 v) \u2014 remove a friendship between u and v. It is guaranteed that u and v are friends at this moment. \\n  * 3 \u2014 print the answer to the process described in the statement. \\n\\nOutput\\n\\nFor each type 3 query print one integer to a new line. It is guaranteed that there will be at least one type 3 query.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 1\\n1 3\\n3 4\\n4\\n3\\n1 2 3\\n2 3 1\\n3\\n\\n\\nOutput\\n\\n\\n2\\n1\\n\\n\\nInput\\n\\n\\n4 3\\n2 3\\n3 4\\n4 1\\n1\\n3\\n\\n\\nOutput\\n\\n\\n1\\n\\nNote\\n\\nConsider the first example. In the first type 3 query, we have the diagram below.\\n\\nIn the first round of the process, noble 1 is weaker than all of his friends (2 and 3), and is thus killed. No other noble is vulnerable in round 1. In round 2, noble 3 is weaker than his only friend, noble 4, and is therefore killed. At this point, the process ends, and the answer is 2.\\n\\n<image>\\n\\nIn the second type 3 query, the only surviving noble is 4.\\n\\nThe second example consists of only one type 3 query. In the first round, two nobles are killed, and in the second round, one noble is killed. The final answer is 1, since only one noble survives.\\n\\n<image>"}
{"epoch": "10", "task_id": "7", "completion": "from collections import Counter\\nfrom sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nfor _ in range(int(input())):\\n    n, a, ans = rints(), Counter(a), []\\n    for i in range(n):\\n        tmp = 0\\n        for j in range(i + 1, n):\\n            tmp += a[i] % j\\n        if tmp > ans[-1]:\\n            out.append(i)\\n\\n    out.reverse()\\n\\nprint('\\n'.join(map(str, out)))\\n", "prompt": "British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\\n\\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \\n\\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\\n\\nYour friend Gregor wants to know the size of the largest friend group in a.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \\n\\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\\n\\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\\n\\nOutput\\n\\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n5\\n1 5 2 4 6\\n4\\n8 2 5 10\\n2\\n1000 2000\\n8\\n465 55 3 54 234 12 45 78\\n\\n\\nOutput\\n\\n\\n3\\n3\\n2\\n6\\n\\nNote\\n\\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\\n\\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\\n\\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work."}
{"epoch": "10", "task_id": "8", "completion": "for _ in range(input()):\\n    n=input()\\n    a,b=1,n/2\\n    for i in range(1,b+1):\\n        if i%2==1:\\n            a+=i\\n            b+=i\\n            break\\n    print a,b\\n", "prompt": "Polycarp must pay exactly n burles at the checkout. He has coins of two nominal values: 1 burle and 2 burles. Polycarp likes both kinds of coins equally. So he doesn't want to pay with more coins of one type than with the other.\\n\\nThus, Polycarp wants to minimize the difference between the count of coins of 1 burle and 2 burles being used. Help him by determining two non-negative integer values c_1 and c_2 which are the number of coins of 1 burle and 2 burles, respectively, so that the total value of that number of coins is exactly n (i. e. c_1 + 2 \u22c5 c_2 = n), and the absolute value of the difference between c_1 and c_2 is as little as possible (i. e. you must minimize |c_1-c_2|).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line. This line contains one integer n (1 \u2264 n \u2264 10^9) \u2014 the number of burles to be paid by Polycarp.\\n\\nOutput\\n\\nFor each test case, output a separate line containing two integers c_1 and c_2 (c_1, c_2 \u2265 0) separated by a space where c_1 is the number of coins of 1 burle and c_2 is the number of coins of 2 burles. If there are multiple optimal solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1000\\n30\\n1\\n32\\n1000000000\\n5\\n\\n\\nOutput\\n\\n\\n334 333\\n10 10\\n1 0\\n10 11\\n333333334 333333333\\n1 2\\n\\nNote\\n\\nThe answer for the first test case is \"334 333\". The sum of the nominal values of all coins is 334 \u22c5 1 + 333 \u22c5 2 = 1000, whereas |334 - 333| = 1. One can't get the better value because if |c_1 - c_2| = 0, then c_1 = c_2 and c_1 \u22c5 1 + c_1 \u22c5 2 = 1000, but then the value of c_1 isn't an integer.\\n\\nThe answer for the second test case is \"10 10\". The sum of the nominal values is 10 \u22c5 1 + 10 \u22c5 2 = 30 and |10 - 10| = 0, whereas there's no number having an absolute value less than 0."}
{"epoch": "10", "task_id": "9", "completion": "T = input()\\nfor _ in range(T):\\n    s = raw_input()\\n    c = [0]*26\\n    for i in range(26):\\n        c[ord(s[i])-97]+=1\\n    print min(c)", "prompt": "This is a simplified version of the problem B2. Perhaps you should read the problem B2 before you start solving B1.\\n\\nPaul and Mary have a favorite string s which consists of lowercase letters of the Latin alphabet. They want to paint it using pieces of chalk of two colors: red and green. Let's call a coloring of a string wonderful if the following conditions are met:\\n\\n  1. each letter of the string is either painted in exactly one color (red or green) or isn't painted; \\n  2. each two letters which are painted in the same color are different; \\n  3. the number of letters painted in red is equal to the number of letters painted in green; \\n  4. the number of painted letters of this coloring is maximum among all colorings of the string which meet the first three conditions. \\n\\n\\n\\nE. g. consider a string s equal to \"kzaaa\". One of the wonderful colorings of the string is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the string \"kzaaa\".\\n\\nPaul and Mary want to learn by themselves how to find a wonderful coloring of the string. But they are very young, so they need a hint. Help them find k \u2014 the number of red (or green, these numbers are equal) letters in a wonderful coloring.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one non-empty string s which consists of lowercase letters of the Latin alphabet. The number of characters in the string doesn't exceed 50.\\n\\nOutput\\n\\nFor each test case, output a separate line containing one non-negative integer k \u2014 the number of letters which will be painted in red in a wonderful coloring.\\n\\nExample\\n\\nInput\\n\\n\\n5\\nkzaaa\\ncodeforces\\narchive\\ny\\nxxxxxx\\n\\n\\nOutput\\n\\n\\n2\\n5\\n3\\n0\\n1\\n\\nNote\\n\\nThe first test case contains the string from the statement. One of the wonderful colorings is shown in the figure. There's no wonderful coloring containing 3 or more red letters because the total number of painted symbols will exceed the string's length.\\n\\nThe string from the second test case can be painted as follows. Let's paint the first occurrence of each of the letters \"c\", \"o\", \"e\" in red and the second ones in green. Let's paint the letters \"d\", \"f\" in red and \"r\", \"s\" in green. So every letter will be painted in red or green, hence the answer better than 5 doesn't exist.\\n\\nThe third test case contains the string of distinct letters, so you can paint any set of characters in red, as long as the size of this set doesn't exceed half of the size of the string and is the maximum possible.\\n\\nThe fourth test case contains a single letter which cannot be painted in red because there will be no letter able to be painted in green.\\n\\nThe fifth test case contains a string of identical letters, so there's no way to paint more than one letter in red."}
{"epoch": "10", "task_id": "10", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    n, k = map(int, stdin.readline().split())\\n    a = map(int, stdin.readline().split())\\n    b = [0] + map(int, stdin.readline().split(), repeat(10, n))\\n    b[n - k - 1] = 0\\n    ans = []\\n    for i in xrange(k):\\n        if i < n - 1 and b[i]!= b[i + 1]:\\n            ans.append(str(b[i]) + \" \" * (k - i))\\n        elif i > n - 1 and b[i]!= b[i + 1]:\\n            ans.append(str(b[i]) + \" \" * (k - i))\\n            b[i] = b[i] - b[i + 1]\\n        elif i < n - 1 and b[i]!= b[i + 1]:\\n            ans.append(str(b[i + 1]))\\n        elif i < n - 1 and b[i]!= b", "prompt": "This problem is an extension of the problem \"Wonderful Coloring - 1\". It has quite many differences, so you should read this statement completely.\\n\\nRecently, Paul and Mary have found a new favorite sequence of integers a_1, a_2,..., a_n. They want to paint it using pieces of chalk of k colors. The coloring of a sequence is called wonderful if the following conditions are met:\\n\\n  1. each element of the sequence is either painted in one of k colors or isn't painted; \\n  2. each two elements which are painted in the same color are different (i. e. there's no two equal values painted in the same color); \\n  3. let's calculate for each of k colors the number of elements painted in the color \u2014 all calculated numbers must be equal; \\n  4. the total number of painted elements of the sequence is the maximum among all colorings of the sequence which meet the first three conditions. \\n\\n\\n\\nE. g. consider a sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the wonderful colorings of the sequence is shown in the figure.\\n\\n<image> The example of a wonderful coloring of the sequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. Note that one of the elements isn't painted.\\n\\nHelp Paul and Mary to find a wonderful coloring of a given sequence a.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of two lines. The first one contains two integers n and k (1 \u2264 n \u2264 2\u22c510^5, 1 \u2264 k \u2264 n) \u2014 the length of a given sequence and the number of colors, respectively. The second one contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nOutput t lines, each of them must contain a description of a wonderful coloring for the corresponding test case.\\n\\nEach wonderful coloring must be printed as a sequence of n integers c_1, c_2,..., c_n (0 \u2264 c_i \u2264 k) separated by spaces where\\n\\n  * c_i=0, if i-th element isn't painted; \\n  * c_i>0, if i-th element is painted in the c_i-th color. \\n\\n\\n\\nRemember that you need to maximize the total count of painted elements for the wonderful coloring. If there are multiple solutions, print any one.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n10 3\\n3 1 1 1 1 10 3 10 10 2\\n4 4\\n1 1 1 1\\n1 1\\n1\\n13 1\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 2\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n13 3\\n3 1 4 1 5 9 2 6 5 3 5 8 9\\n\\n\\nOutput\\n\\n\\n1 1 0 2 3 2 2 1 3 3\\n4 2 1 3\\n1\\n0 0 1 1 0 1 1 1 0 1 1 1 0\\n2 1 2 2 1 1 1 1 2 1 0 2 2\\n1 1 3 2 1 3 3 1 2 2 3 2 0\\n\\nNote\\n\\nIn the first test case, the answer is shown in the figure in the statement. The red color has number 1, the blue color \u2014 2, the green \u2014 3."}
{"epoch": "10", "task_id": "11", "completion": "for _ in range(input()):\\n    n=input()\\n    a=[]\\n    s=[]\\n    for _ in range(n):\\n        s.append(raw_input())\\n        a.append(s)\\n    s.sort(key=len)\\n    s=sorted(s,key=len)\\n    i=0\\n    ans=0\\n    while i<n-1:\\n        k=a[i][0]\\n        if(k>s[i+1][1]):\\n            k=a[i][0]\\n        else:\\n            break\\n        ans+=1\\n    print ans", "prompt": "Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!\\n\\nTo compose a story, Stephen wrote out n words consisting of the first 5 lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.\\n\\nLet a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.\\n\\nFor example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs 5 times, all other letters occur 4 times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).\\n\\nYou are given a sequence of n words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output 0.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of the words in the sequence. Then n lines follow, each of them contains a word \u2014 a non-empty string consisting of lowercase letters of the Latin alphabet. The words in the sequence may be non-distinct (i. e. duplicates are allowed). Only the letters 'a', 'b', 'c', 'd' and 'e' may occur in the words.\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2 \u22c5 10^5; the sum of the lengths of all words over all test cases doesn't exceed 4 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, output the maximum number of words that compose an interesting story. Print 0 if there's no way to make a non-empty interesting story.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n3\\nbac\\naaada\\ne\\n3\\naba\\nabcde\\naba\\n2\\nbaba\\nbaba\\n4\\nab\\nab\\nc\\nbc\\n5\\ncbdca\\nd\\na\\nd\\ne\\n3\\nb\\nc\\nca\\n\\n\\nOutput\\n\\n\\n3\\n2\\n0\\n2\\n3\\n2\\n\\nNote\\n\\nIn the first test case of the example, all 3 words can be used to make an interesting story. The interesting story is \"bac aaada e\".\\n\\nIn the second test case of the example, the 1-st and the 3-rd words can be used to make an interesting story. The interesting story is \"aba aba\". Stephen can't use all three words at the same time.\\n\\nIn the third test case of the example, Stephen can't make a non-empty interesting story. So the answer is 0.\\n\\nIn the fourth test case of the example, Stephen can use the 3-rd and the 4-th words to make an interesting story. The interesting story is \"c bc\"."}
{"epoch": "10", "task_id": "12", "completion": "for _ in xrange(input()):\\n    n,m,k=map(int,raw_input().split())\\n    if k<=1 or k>m*(n/2):\\n        print \"NO\"\\n    elif n%2==k or m%2==k:\\n        print \"YES\"\\n    else:\\n        print \"NO\"", "prompt": "The only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\\n\\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\\n\\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\\n\\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\\n\\nOutput\\n\\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n8\\n4 4 2\\n2 3 0\\n3 2 3\\n1 2 0\\n2 4 2\\n5 2 2\\n2 17 16\\n2 1 1\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO"}
{"epoch": "10", "task_id": "16", "completion": "for _ in range(input()):\\n    n=input()\\n    s=list(raw_input())\\n    s.sort()\\n    print n-len(set(s))\\n", "prompt": "A string s of length n, consisting of lowercase letters of the English alphabet, is given.\\n\\nYou must choose some number k between 0 and n. Then, you select k characters of s and permute them however you want. In this process, the positions of the other n-k characters remain unchanged. You have to perform this operation exactly once.\\n\\nFor example, if s=\"andrea\", you can choose the k=4 characters \"a_d_ea\" and permute them into \"d_e_aa\" so that after the operation the string becomes \"dneraa\".\\n\\nDetermine the minimum k so that it is possible to sort s alphabetically (that is, after the operation its characters appear in alphabetical order).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 40) \u2014 the length of the string.\\n\\nThe second line of each test case contains the string s. It is guaranteed that s contains only lowercase letters of the English alphabet.\\n\\nOutput\\n\\nFor each test case, output the minimum k that allows you to obtain a string sorted alphabetically, through the operation described above.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\nlol\\n10\\ncodeforces\\n5\\naaaaa\\n4\\ndcba\\n\\n\\nOutput\\n\\n\\n2\\n6\\n0\\n4\\n\\nNote\\n\\nIn the first test case, we can choose the k=2 characters \"_ol\" and rearrange them as \"_lo\" (so the resulting string is \"llo\"). It is not possible to sort the string choosing strictly less than 2 characters.\\n\\nIn the second test case, one possible way to sort s is to consider the k=6 characters \"_o__force_\" and rearrange them as \"_c__efoor_\" (so the resulting string is \"ccdeefoors\"). One can show that it is not possible to sort the string choosing strictly less than 6 characters.\\n\\nIn the third test case, string s is already sorted (so we can choose k=0 characters).\\n\\nIn the fourth test case, we can choose all k=4 characters \"dcba\" and reverse the whole string (so the resulting string is \"abcd\")."}
{"epoch": "10", "task_id": "17", "completion": "for _ in range(input()):\\n    n=input()\\n    l=[]\\n    for i in range(n):\\n        l.append(map(int,raw_input().split()))\\n    for i in range(1,6,3):\\n        for j in range(n):\\n            if i==j:\\n                break\\n        if l[i][j] not in l:\\n            l.remove(l[i][j])\\n    if len(l)==3:\\n        print -1\\n    else:\\n        print l.index(max(l))+1\\n", "prompt": "The Olympic Games have just started and Federico is eager to watch the marathon race.\\n\\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\\n\\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\\n\\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\\n\\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\\n\\nThen n lines follow, each describing the ranking positions of one athlete.\\n\\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j}, ...,  r_{n, j} are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\n50000 1 50000 50000 50000\\n3\\n10 10 20 30 30\\n20 20 30 10 10\\n30 30 10 20 20\\n3\\n1 1 1 1 1\\n2 2 2 2 2\\n3 3 3 3 3\\n6\\n9 5 3 7 1\\n7 4 1 6 8\\n5 6 7 3 2\\n6 7 8 8 6\\n4 2 2 4 5\\n8 3 6 9 4\\n\\n\\nOutput\\n\\n\\n1\\n-1\\n1\\n5\\n\\nNote\\n\\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\\n\\nExplanation of the second test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \\n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \\n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \\n\\n\\n\\nExplanation of the third test case: There are n=3 athletes. \\n\\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 2 is superior to athlete 3. \\n  * Athlete 3 is not superior to any other athlete. \\n\\n\\n\\nExplanation of the fourth test case: There are n=6 athletes. \\n\\n  * Athlete 1 is superior to athletes 3, 4, 6. \\n  * Athlete 2 is superior to athletes 1, 4, 6. \\n  * Athlete 3 is superior to athletes 2, 4, 6. \\n  * Athlete 4 is not superior to any other athlete. \\n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \\n  * Athlete 6 is only superior to athlete 4. "}
{"epoch": "10", "task_id": "18", "completion": "def main():\\n    t = int(raw_input())\\n    for _ in xrange(t):\\n        n, k = map(int, raw_input().split())\\n        a = [map(int, raw_input().split()) for _ in xrange(k)]\\n        c = [0]*(2*n+1)\\n        for x, y in a:\\n            c[x-1] += 1\\n            c[y-1] += 1\\n        ans = 0\\n        for i in xrange(k):\\n            x, y = map(int, raw_input().split())\\n            if (x+1) in c:\\n                ans += c[(x+1)%n]\\n            c[(x+1)%n] -= 1\\n        print ans\\n\\nmain()\\n", "prompt": "On a circle lie 2n distinct points, with the following property: however you choose 3 chords that connect 3 disjoint pairs of points, no point strictly inside the circle belongs to all 3 chords. The points are numbered 1,   2,  ...,   2n in clockwise order.\\n\\nInitially, k chords connect k pairs of points, in such a way that all the 2k endpoints of these chords are distinct.\\n\\nYou want to draw n - k additional chords that connect the remaining 2(n - k) points (each point must be an endpoint of exactly one chord).\\n\\nIn the end, let x be the total number of intersections among all n chords. Compute the maximum value that x can attain if you choose the n - k chords optimally.\\n\\nNote that the exact position of the 2n points is not relevant, as long as the property stated in the first paragraph holds.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 n \u2264 100, 0 \u2264 k \u2264 n) \u2014 half the number of points and the number of chords initially drawn.\\n\\nThen k lines follow. The i-th of them contains two integers x_i and y_i (1 \u2264 x_i,   y_i \u2264 2n, x_i \u2260 y_i) \u2014 the endpoints of the i-th chord. It is guaranteed that the 2k numbers x_1,   y_1,   x_2,   y_2,  ...,   x_k,   y_k are all distinct.\\n\\nOutput\\n\\nFor each test case, output the maximum number of intersections that can be obtained by drawing n - k additional chords.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 2\\n8 2\\n1 5\\n1 1\\n2 1\\n2 0\\n10 6\\n14 6\\n2 20\\n9 10\\n13 18\\n15 12\\n11 7\\n\\n\\nOutput\\n\\n\\n4\\n0\\n1\\n14\\n\\nNote\\n\\nIn the first test case, there are three ways to draw the 2 additional chords, shown below (black chords are the ones initially drawn, while red chords are the new ones):\\n\\n<image>\\n\\nWe see that the third way gives the maximum number of intersections, namely 4.\\n\\nIn the second test case, there are no more chords to draw. Of course, with only one chord present there are no intersections.\\n\\nIn the third test case, we can make at most one intersection by drawing chords 1-3 and 2-4, as shown below:\\n\\n<image>"}
{"epoch": "10", "task_id": "19", "completion": "t=int(raw_input())\\nwhile t>0:\\n\\tt-=1\\n\\tn=int(raw_input())\\n\\ta=list(map(int,raw_input().split()))\\n\\ta.sort()\\n\\tx=0\\n\\tfor i in xrange(n):\\n\\t\\tif a[i]>0:\\n\\t\\t\\tx+=a[i]\\n\\t\\telse:\\n\\t\\t\\tbreak\\n\\tif x==0:\\n\\t\\tprint \"NO\"\\n\\telse:\\n\\t\\tprint \"YES\"", "prompt": "You are given a sequence of n integers a_1,   a_2,  ...,   a_n.\\n\\nDoes there exist a sequence of n integers b_1,   b_2,  ...,   b_n such that the following property holds?\\n\\n  * For each 1 \u2264 i \u2264 n, there exist two (not necessarily distinct) indices j and k (1 \u2264 j,   k \u2264 n) such that a_i = b_j - b_k. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Then t test cases follow.\\n\\nThe first line of each test case contains one integer n (1 \u2264 n \u2264 10).\\n\\nThe second line of each test case contains the n integers a_1,  ...,   a_n (-10^5 \u2264 a_i \u2264 10^5).\\n\\nOutput\\n\\nFor each test case, output a line containing YES if a sequence b_1,  ...,   b_n satisfying the required property exists, and NO otherwise.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n5\\n4 -7 -1 5 10\\n1\\n0\\n3\\n1 10 100\\n4\\n-3 2 10 2\\n9\\n25 -171 250 174 152 242 100 -205 -258\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\n\\nNote\\n\\nIn the first test case, the sequence b = [-9,   2,   1,   3,   -2] satisfies the property. Indeed, the following holds: \\n\\n  * a_1 = 4 = 2 - (-2) = b_2 - b_5; \\n  * a_2 = -7 = -9 - (-2) = b_1 - b_5; \\n  * a_3 = -1 = 1 - 2 = b_3 - b_2; \\n  * a_4 = 5 = 3 - (-2) = b_4 - b_5; \\n  * a_5 = 10 = 1 - (-9) = b_3 - b_1. \\n\\n\\n\\nIn the second test case, it is sufficient to choose b = [0], since a_1 = 0 = 0 - 0 = b_1 - b_1.\\n\\nIn the third test case, it is possible to show that no sequence b of length 3 satisfies the property."}
{"epoch": "10", "task_id": "20", "completion": "n,k=map(int,raw_input().split())\\na=map(int,raw_input().split())\\na.sort(reverse=True)\\nfor i in range(k):\\n    c=a[i]\\n    b=[i+1]*(n-k+1)\\n    for j in range(n):\\n        a[c][b[j]]=a[c][b[j]]+1\\n    print min(a),max(a)\\n", "prompt": "The numbers 1,   2,  ...,   n \u22c5 k are colored with n colors. These colors are indexed by 1,   2,  ...,   n. For each 1 \u2264 i \u2264 n, there are exactly k numbers colored with color i.\\n\\nLet [a,   b] denote the interval of integers between a and b inclusive, that is, the set \\\\{a,   a + 1,  ...,   b\\}. You must choose n intervals [a_1,   b_1],   [a_2,   b_2],  ..., [a_n,   b_n] such that: \\n\\n  * for each 1 \u2264 i \u2264 n, it holds 1 \u2264 a_i < b_i \u2264 n \u22c5 k; \\n  * for each 1 \u2264 i \u2264 n, the numbers a_i and b_i are colored with color i; \\n  * each number 1 \u2264 x \u2264 n \u22c5 k belongs to at most \\left\u2308 (n)/(k - 1) \\right\u2309 intervals. \\n\\n\\n\\nOne can show that such a family of intervals always exists under the given constraints.\\n\\nInput\\n\\nThe first line contains two integers n and k (1 \u2264 n \u2264 100, 2 \u2264 k \u2264 100) \u2014 the number of colors and the number of occurrences of each color.\\n\\nThe second line contains n \u22c5 k integers c_1,   c_2,  ...,   c_{nk} (1 \u2264 c_j \u2264 n), where c_j is the color of number j. It is guaranteed that, for each 1 \u2264 i \u2264 n, it holds c_j = i for exactly k distinct indices j.\\n\\nOutput\\n\\nOutput n lines. The i-th line should contain the two integers a_i and b_i.\\n\\nIf there are multiple valid choices of the intervals, output any.\\n\\nExamples\\n\\nInput\\n\\n\\n4 3\\n2 4 3 1 1 4 2 3 2 1 3 4\\n\\n\\nOutput\\n\\n\\n4 5\\n1 7\\n8 11\\n6 12\\n\\nInput\\n\\n\\n1 2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n\\n\\nInput\\n\\n\\n3 3\\n3 1 2 3 2 1 2 1 3\\n\\n\\nOutput\\n\\n\\n6 8\\n3 7\\n1 4\\n\\nInput\\n\\n\\n2 3\\n2 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n2 3\\n5 6\\n\\nNote\\n\\nIn the first sample, each number can be contained in at most \\left\u2308 (4)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>\\n\\nIn the second sample, the only interval to be chosen is forced to be [1,   2], and each number is indeed contained in at most \\left\u2308 (1)/(2 - 1) \\right\u2309 = 1 interval.\\n\\nIn the third sample, each number can be contained in at most \\left\u2308 (3)/(3 - 1) \\right\u2309 = 2 intervals. The output is described by the following picture:\\n\\n<image>"}
{"epoch": "10", "task_id": "21", "completion": "from sys import stdin\\nfrom itertools import repeat\\ndef main():\\n    n = int(stdin.readline())\\n    p = map(int, stdin.read().split(), repeat(10, n))\\n    ans = [0] * n\\n    p = [map(int, stdin.readline().split(), repeat(10, n)) for _ in xrange(n)]\\n    for x, y, s in p:\\n        p[y - 1] = (x, s)\\n        ans[x - 1] += s\\n    ans = [0] * n\\n    for x in xrange(n):\\n        for y, s in p[x]:\\n            ans[y - 1] += s\\n    ans[n] = p[n]\\n    for i in xrange(n - 1):\\n        ans[i] = (ans[i + 1] + p[n] + s) % 998244353\\n    print ans[n]\\nmain()\\n", "prompt": "An ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\\n\\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \\n\\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \\n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \\n\\n\\n\\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\\n\\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\\n\\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,  ...,   x_n,   y_1,   y_2,  ...,   y_n are all distinct.\\n\\nOutput\\n\\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n3 2 0\\n6 5 1\\n7 4 0\\n8 1 1\\n\\n\\nOutput\\n\\n\\n23\\n\\n\\nInput\\n\\n\\n1\\n454971987 406874902 1\\n\\n\\nOutput\\n\\n\\n503069073\\n\\n\\nInput\\n\\n\\n5\\n243385510 42245605 0\\n644426565 574769163 0\\n708622105 208990040 0\\n786625660 616437691 0\\n899754846 382774619 0\\n\\n\\nOutput\\n\\n\\n899754847\\n\\n\\nInput\\n\\n\\n5\\n200000000 100000000 1\\n600000000 400000000 0\\n800000000 300000000 0\\n900000000 700000000 1\\n1000000000 500000000 0\\n\\n\\nOutput\\n\\n\\n3511295\\n\\nNote\\n\\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\\n\\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\\n\\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847."}
{"epoch": "10", "task_id": "24", "completion": "n=int(raw_input())\\nfor i in range(n):\\n    x=int(raw_input())\\n    if(x<10):\\n        print 0\\n    else:\\n        y=str(x)\\n        l=len(y)\\n        while(y[l-1]!=x[l-2]):\\n            l-=1\\n            y=str(y[l-1])\\n        print y[l-1]", "prompt": "Let's define S(x) to be the sum of digits of number x written in decimal system. For example, S(5) = 5, S(10) = 1, S(322) = 7.\\n\\nWe will call an integer x interesting if S(x + 1) < S(x). In each test you will be given one integer n. Your task is to calculate the number of integers x such that 1 \u2264 x \u2264 n and x is interesting.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 number of test cases.\\n\\nThen t lines follow, the i-th line contains one integer n (1 \u2264 n \u2264 10^9) for the i-th test case.\\n\\nOutput\\n\\nPrint t integers, the i-th should be the answer for the i-th test case.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1\\n9\\n10\\n34\\n880055535\\n\\n\\nOutput\\n\\n\\n0\\n1\\n1\\n3\\n88005553\\n\\nNote\\n\\nThe first interesting number is equal to 9."}
{"epoch": "10", "task_id": "25", "completion": "t=int(raw_input())\\nfor _ in range(t):\\n    a=list(raw_input())\\n    b=list(raw_input())\\n    a1=list(a)\\n    b1=list(b)\\n    for i in range(len(a)):\\n        if a[i]>b[i]:\\n            print \"NO\"\\n            break\\n    else:\\n        print \"YES\"", "prompt": "You have a string s and a chip, which you can place onto any character of this string. \\n\\nAfter placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i + 1. Of course, moving the chip to the right is impossible if it is already in the last position.\\n\\nAfter moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is i, you move it to the position i - 1. Of course, moving the chip to the left is impossible if it is already in the first position.\\n\\nWhen you place a chip or move it, you write down the character where the chip ends up after your action. For example, if s is abcdef, you place the chip onto the 3-rd character, move it to the right 2 times and then move it to the left 3 times, you write down the string cdedcb.\\n\\nYou are given two strings s and t. Your task is to determine whether it's possible to perform the described operations with s so that you write down the string t as a result.\\n\\nInput\\n\\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains the string s (1 \u2264 |s| \u2264 500), the second line contains the string t (1 \u2264 |t| \u2264 2 \u22c5 |s| - 1). Both strings consist of lowercase English characters.\\n\\nIt is guaranteed that the sum of |s| over all test cases does not exceed 500.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by performing the process mentioned in the statement with the string s, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n6\\nabcdef\\ncdedcb\\naaa\\naaaaa\\naab\\nbaaa\\nab\\nb\\nabcdef\\nabcdef\\nba\\nbaa\\n\\n\\nOutput\\n\\n\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\n\\nNote\\n\\nConsider the examples.\\n\\nThe first test case is described in the statement.\\n\\nIn the second test case, you can place the chip on the 1-st position, move it twice to the right, and then move it twice to the left.\\n\\nIn the fourth test case, you can place the chip on the 2-nd position, and then don't move it at all.\\n\\nIn the fifth test case, you can place the chip on the 1-st position, move it 5 times to the right, and then finish the process."}
{"epoch": "10", "task_id": "26", "completion": "from collections import Counter\\nfor _ in range(input()):\\n    s = Counter(raw_input())\\n    print len(s.keys())", "prompt": "Consider a simplified penalty phase at the end of a football match.\\n\\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\\n\\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or?. This string represents your predictions in the following way:\\n\\n  * if s_i is 1, then the i-th kick will definitely score a goal; \\n  * if s_i is 0, then the i-th kick definitely won't score a goal; \\n  * if s_i is?, then the i-th kick could go either way. \\n\\n\\n\\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 1 000) \u2014 the number of test cases.\\n\\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or?.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1?0???1001\\n1111111111\\n??????????\\n0100000000\\n\\n\\nOutput\\n\\n\\n7\\n10\\n6\\n9\\n\\nNote\\n\\nConsider the example test:\\n\\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\\n\\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\\n\\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\\n\\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick."}
{"epoch": "10", "task_id": "27", "completion": "from collections import Counter\\n\\nq = int(raw_input())\\nfor _ in xrange(q):\\n    s = raw_input()\\n    t = raw_input()\\n    d = Counter(s)\\n    n = len(t)\\n    if d.most_common(1)[0][1] == n - 1:\\n        print 'YES'\\n    else:\\n        print 'NO'\\n", "prompt": "You are given two strings s and t, both consisting of lowercase English letters. You are going to type the string s character by character, from the first character to the last one.\\n\\nWhen typing a character, instead of pressing the button corresponding to it, you can press the \"Backspace\" button. It deletes the last character you have typed among those that aren't deleted yet (or does nothing if there are no characters in the current string). For example, if s is \"abcbd\" and you press Backspace instead of typing the first and the fourth characters, you will get the string \"bd\" (the first press of Backspace deletes no character, and the second press deletes the character 'c'). Another example, if s is \"abcaa\" and you press Backspace instead of the last two letters, then the resulting text is \"a\".\\n\\nYour task is to determine whether you can obtain the string t, if you type the string s and press \"Backspace\" instead of typing several (maybe zero) characters of s.\\n\\nInput\\n\\nThe first line contains a single integer q (1 \u2264 q \u2264 10^5) \u2014 the number of test cases.\\n\\nThe first line of each test case contains the string s (1 \u2264 |s| \u2264 10^5). Each character of s is a lowercase English letter.\\n\\nThe second line of each test case contains the string t (1 \u2264 |t| \u2264 10^5). Each character of t is a lowercase English letter.\\n\\nIt is guaranteed that the total number of characters in the strings over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print \"YES\" if you can obtain the string t by typing the string s and replacing some characters with presses of \"Backspace\" button, or \"NO\" if you cannot.\\n\\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\\n\\nExample\\n\\nInput\\n\\n\\n4\\nababa\\nba\\nababa\\nbb\\naaa\\naaaa\\naababa\\nababa\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nNO\\nYES\\n\\nNote\\n\\nConsider the example test from the statement.\\n\\nIn order to obtain \"ba\" from \"ababa\", you may press Backspace instead of typing the first and the fourth characters.\\n\\nThere's no way to obtain \"bb\" while typing \"ababa\".\\n\\nThere's no way to obtain \"aaaa\" while typing \"aaa\".\\n\\nIn order to obtain \"ababa\" while typing \"aababa\", you have to press Backspace instead of typing the first character, then type all the remaining characters."}
{"epoch": "10", "task_id": "28", "completion": "for _ in range(input()):\\n    n, m = map(int, raw_input().split())\\n    p = map(int, raw_input().split())\\n    pos = 0\\n    for i in range(n):\\n        pos += 1\\n        if p[i] <= m:\\n            pos -= 1\\n        if pos == n - 1:\\n            break\\n    for i in range(n - k, n):\\n        print pos,\\n    print\\n", "prompt": "An identity permutation of length n is an array [1, 2, 3,..., n].\\n\\nWe performed the following operations to an identity permutation of length n:\\n\\n  * firstly, we cyclically shifted it to the right by k positions, where k is unknown to you (the only thing you know is that 0 \u2264 k \u2264 n - 1). When an array is cyclically shifted to the right by k positions, the resulting array is formed by taking k last elements of the original array (without changing their relative order), and then appending n - k first elements to the right of them (without changing relative order of the first n - k elements as well). For example, if we cyclically shift the identity permutation of length 6 by 2 positions, we get the array [5, 6, 1, 2, 3, 4]; \\n  * secondly, we performed the following operation at most m times: pick any two elements of the array and swap them. \\n\\n\\n\\nYou are given the values of n and m, and the resulting array. Your task is to find all possible values of k in the cyclic shift operation.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^5) \u2014 the number of test cases.\\n\\nEach test case consists of two lines. The first line contains two integers n and m (3 \u2264 n \u2264 3 \u22c5 10^5; 0 \u2264 m \u2264 n/3).\\n\\nThe second line contains n integers p_1, p_2,..., p_n (1 \u2264 p_i \u2264 n, each integer from 1 to n appears in this sequence exactly once) \u2014 the resulting array.\\n\\nThe sum of n over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the answer in the following way:\\n\\n  * firstly, print one integer r (0 \u2264 r \u2264 n) \u2014 the number of possible values of k for the cyclic shift operation; \\n  * secondly, print r integers k_1, k_2,..., k_r (0 \u2264 k_i \u2264 n - 1) \u2014 all possible values of k in increasing order. \\n\\nExample\\n\\nInput\\n\\n\\n4\\n4 1\\n2 3 1 4\\n3 1\\n1 2 3\\n3 1\\n3 2 1\\n6 0\\n1 2 3 4 6 5\\n\\n\\nOutput\\n\\n\\n1 3\\n1 0\\n3 0 1 2\\n0\\n\\nNote\\n\\nConsider the example: \\n\\n  * in the first test case, the only possible value for the cyclic shift is 3. If we shift [1, 2, 3, 4] by 3 positions, we get [2, 3, 4, 1]. Then we can swap the 3-rd and the 4-th elements to get the array [2, 3, 1, 4]; \\n  * in the second test case, the only possible value for the cyclic shift is 0. If we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we don't change the array at all (we stated that we made at most 1 swap), so the resulting array stays [1, 2, 3]; \\n  * in the third test case, all values from 0 to 2 are possible for the cyclic shift: \\n    * if we shift [1, 2, 3] by 0 positions, we get [1, 2, 3]. Then we can swap the 1-st and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 1 position, we get [3, 1, 2]. Then we can swap the 2-nd and the 3-rd elements to get [3, 2, 1]; \\n    * if we shift [1, 2, 3] by 2 positions, we get [2, 3, 1]. Then we can swap the 1-st and the 2-nd elements to get [3, 2, 1]; \\n  * in the fourth test case, we stated that we didn't do any swaps after the cyclic shift, but no value of cyclic shift could produce the array [1, 2, 3, 4, 6, 5]. "}
{"epoch": "10", "task_id": "33", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = [int(x) for x in input().split()]\\n    a.sort()\\n    s = 0\\n    for i in range(n):\\n        s += a[i]\\n        s %= n\\n    print s", "prompt": "You are given n integers a_1, a_2, \u2026, a_n. Find the maximum value of max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r) over all pairs (l, r) of integers for which 1 \u2264 l < r \u2264 n.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^6).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of the product from the statement.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n2 4 3\\n4\\n3 2 3 1\\n2\\n69 69\\n6\\n719313 273225 402638 473783 804745 323328\\n\\n\\nOutput\\n\\n\\n12\\n6\\n4761\\n381274500335\\n\\nNote\\n\\nLet f(l, r) = max(a_l, a_{l + 1}, \u2026, a_r) \u22c5 min(a_l, a_{l + 1}, \u2026, a_r).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = max(a_1, a_2) \u22c5 min(a_1, a_2) = max(2, 4) \u22c5 min(2, 4) = 4 \u22c5 2 = 8. \\n  * f(1, 3) = max(a_1, a_2, a_3) \u22c5 min(a_1, a_2, a_3) = max(2, 4, 3) \u22c5 min(2, 4, 3) = 4 \u22c5 2 = 8. \\n  * f(2, 3) = max(a_2, a_3) \u22c5 min(a_2, a_3) = max(4, 3) \u22c5 min(4, 3) = 4 \u22c5 3 = 12. \\n\\n\\n\\nSo the maximum is f(2, 3) = 12.\\n\\nIn the second test case, the maximum is f(1, 2) = f(1, 3) = f(2, 3) = 6."}
{"epoch": "10", "task_id": "34", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n,k = [int(x) for x in input().split()]\\n    A = [int(x) for x in input().split()]\\n    ans = []\\n\\n    for x in A:\\n        p = x & 1\\n        ans.append(p)\\n\\n    for x in A:\\n        m = 0\\n        for k in range(1,k+1):\\n            if x & 1:\\n                m = max(m, (k+1)*(x-1))\\n        ans.append(m)\\n\\n    ans.sort()\\n\\n    ans.reverse()\\n    ans.reverse()\\n\\n    ans.reverse()\\n    ans.append(0)\\n\\n    for x in ans:\\n        print x\\n    print ''.join(map(str,ans))", "prompt": "You are given n integers a_1, a_2, \u2026, a_n and an integer k. Find the maximum value of i \u22c5 j - k \u22c5 (a_i | a_j) over all pairs (i, j) of integers with 1 \u2264 i < j \u2264 n. Here, | is the [bitwise OR operator](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10 000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains two integers n (2 \u2264 n \u2264 10^5) and k (1 \u2264 k \u2264 min(n, 100)).\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 n).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the maximum possible value of i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 3\\n1 1 3\\n2 2\\n1 2\\n4 3\\n0 1 2 3\\n6 6\\n3 2 0 0 5 6\\n\\n\\nOutput\\n\\n\\n-1\\n-4\\n3\\n12\\n\\nNote\\n\\nLet f(i, j) = i \u22c5 j - k \u22c5 (a_i | a_j).\\n\\nIn the first test case, \\n\\n  * f(1, 2) = 1 \u22c5 2 - k \u22c5 (a_1 | a_2) = 2 - 3 \u22c5 (1 | 1) = -1. \\n  * f(1, 3) = 1 \u22c5 3 - k \u22c5 (a_1 | a_3) = 3 - 3 \u22c5 (1 | 3) = -6. \\n  * f(2, 3) = 2 \u22c5 3 - k \u22c5 (a_2 | a_3) = 6 - 3 \u22c5 (1 | 3) = -3. \\n\\n\\n\\nSo the maximum is f(1, 2) = -1.\\n\\nIn the fourth test case, the maximum is f(3, 4) = 12."}
{"epoch": "10", "task_id": "35", "completion": "from collections import Counter\\nfor _ in range(input()):\\n    n,m = map(int, raw_input().split())\\n    if n == m:\\n        print n\\n    else:\\n        print m ^ n\\n", "prompt": "You are given two integers n and m. Find the \\operatorname{MEX} of the sequence n \u2295 0, n \u2295 1, \u2026, n \u2295 m. Here, \u2295 is the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\n\\operatorname{MEX} of the sequence of non-negative integers is the smallest non-negative integer that doesn't appear in this sequence. For example, \\operatorname{MEX}(0, 1, 2, 4) = 3, and \\operatorname{MEX}(1, 2021) = 0. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 30 000) \u2014 the number of test cases.\\n\\nThe first and only line of each test case contains two integers n and m (0 \u2264 n, m \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the answer to the problem.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3 5\\n4 6\\n3 2\\n69 696\\n123456 654321\\n\\n\\nOutput\\n\\n\\n4\\n3\\n0\\n640\\n530866\\n\\nNote\\n\\nIn the first test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, 3 \u2295 3, 3 \u2295 4, 3 \u2295 5, or 3, 2, 1, 0, 7, 6. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 4.\\n\\nIn the second test case, the sequence is 4 \u2295 0, 4 \u2295 1, 4 \u2295 2, 4 \u2295 3, 4 \u2295 4, 4 \u2295 5, 4 \u2295 6, or 4, 5, 6, 7, 0, 1, 2. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 3.\\n\\nIn the third test case, the sequence is 3 \u2295 0, 3 \u2295 1, 3 \u2295 2, or 3, 2, 1. The smallest non-negative integer which isn't present in the sequence i. e. the \\operatorname{MEX} of the sequence is 0."}
{"epoch": "10", "task_id": "36", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    kase = inp()\\n    pans = []\\n    for _ in range(kase):\\n        n = inp()\\n        res = \"\"\\n        for x in range(26):\\n            if pans[x]%2 == 1:\\n                res = res + x\\n            else:\\n                res = res + x\\n    print res\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "You are given an integer n. Find any string s of length n consisting only of English lowercase letters such that each non-empty substring of s occurs in s an odd number of times. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 500) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5).\\n\\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single line containing the string s. If there are multiple such strings, output any. It can be shown that such string always exists under the given constraints.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n5\\n9\\n19\\n\\n\\nOutput\\n\\n\\nabc\\ndiane\\nbbcaabbba\\nyouarethecutestuwuu\\n\\nNote\\n\\nIn the first test case, each substring of \"abc\" occurs exactly once.\\n\\nIn the third test case, each substring of \"bbcaabbba\" occurs an odd number of times. In particular, \"b\" occurs 5 times, \"a\" and \"bb\" occur 3 times each, and each of the remaining substrings occurs exactly once."}
{"epoch": "10", "task_id": "38", "completion": "t=int(input())\\nfor i in range(t):\\n    n=int(input())\\n    x=n/6\\n    ans=n-x*15\\n    s=x*10\\n    for j in range(6):\\n        if j==n/6:\\n            ans+=15\\n        elif j==n/8:\\n            ans+=20\\n        else:\\n            ans+=25\\n    print(ans)", "prompt": "PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\\n\\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\\n\\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \\n\\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \\n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \\n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \\n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\\n\\nOutput\\n\\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n12\\n15\\n300\\n1\\n9999999999999999\\n3\\n\\n\\nOutput\\n\\n\\n30\\n40\\n750\\n15\\n25000000000000000\\n15"}
{"epoch": "10", "task_id": "39", "completion": "t = int(raw_input())\\n\\nfor _ in xrange(t):\\n    w, h = map(int, raw_input().split())\\n    x1, y1, x2, y2 = map(int, raw_input().split())\\n    w, h = map(int, raw_input().split())\\n\\n    if w > w:\\n        dx = (w - w) * (h - h)\\n    if h < h:\\n        dx = (h - w) * (h - h)\\n\\n    print min(dx, dy)\\n", "prompt": "You have an axis-aligned rectangle room with width W and height H, so the lower left corner is in point (0, 0) and the upper right corner is in (W, H).\\n\\nThere is a rectangular table standing in this room. The sides of the table are parallel to the walls, the lower left corner is in (x_1, y_1), and the upper right corner in (x_2, y_2).\\n\\nYou want to place another rectangular table in this room with width w and height h with the width of the table parallel to the width of the room.\\n\\nThe problem is that sometimes there is not enough space to place the second table without intersecting with the first one (there are no problems with tables touching, though).\\n\\nYou can't rotate any of the tables, but you can move the first table inside the room. \\n\\n<image> Example of how you may move the first table.\\n\\nWhat is the minimum distance you should move the first table to free enough space for the second one?\\n\\nInput\\n\\nThe first line contains the single integer t (1 \u2264 t \u2264 5000) \u2014 the number of the test cases.\\n\\nThe first line of each test case contains two integers W and H (1 \u2264 W, H \u2264 10^8) \u2014 the width and the height of the room.\\n\\nThe second line contains four integers x_1, y_1, x_2 and y_2 (0 \u2264 x_1 < x_2 \u2264 W; 0 \u2264 y_1 < y_2 \u2264 H) \u2014 the coordinates of the corners of the first table.\\n\\nThe third line contains two integers w and h (1 \u2264 w \u2264 W; 1 \u2264 h \u2264 H) \u2014 the width and the height of the second table.\\n\\nOutput\\n\\nFor each test case, print the minimum distance you should move the first table, or -1 if there is no way to free enough space for the second table.\\n\\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n8 5\\n2 1 7 4\\n4 2\\n5 4\\n2 2 5 4\\n3 3\\n1 8\\n0 3 1 6\\n1 5\\n8 1\\n3 0 6 1\\n5 1\\n8 10\\n4 5 7 8\\n8 5\\n\\n\\nOutput\\n\\n\\n1.000000000\\n-1\\n2.000000000\\n2.000000000\\n0.000000000\\n\\nNote\\n\\nThe configuration of the first test case is shown in the picture. But the movement of the first table is not optimal. One of the optimal movement, for example, is to move the table by (0, -1), so the lower left corner will move from (2, 1) to (2, 0). Then you can place the second table at (0, 3)-(4, 5).\\n\\nIn the second test case, there is no way to fit both tables in the room without intersecting.\\n\\nIn the third test case, you can move the first table by (0, 2), so the lower left corner will move from (0, 3) to (0, 5)."}
{"epoch": "10", "task_id": "40", "completion": "import os\\nimport sys\\nfrom atexit import register\\nfrom io import BytesIO\\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\\nsys.stdout = BytesIO()\\nregister(lambda: os.write(1, sys.stdout.getvalue()))\\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    a = []\\n    s = 0\\n    for _ in range(2):\\n        a.append(map(int,input().split()))\\n    s += max(a)\\n    print(s)\\n", "prompt": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m columns. The cell in the i-th row in the j-th column contains a_{i, j} coins in it.\\n\\nInitially, both Alice and Bob are standing in a cell (1, 1). They are going to perform a sequence of moves to reach a cell (2, m).\\n\\nThe possible moves are: \\n\\n  * Move right \u2014 from some cell (x, y) to (x, y + 1); \\n  * Move down \u2014 from some cell (x, y) to (x + 1, y). \\n\\n\\n\\nFirst, Alice makes all her moves until she reaches (2, m). She collects the coins in all cells she visit (including the starting cell).\\n\\nWhen Alice finishes, Bob starts his journey. He also performs the moves to reach (2, m) and collects the coins in all cells that he visited, but Alice didn't.\\n\\nThe score of the game is the total number of coins Bob collects.\\n\\nAlice wants to minimize the score. Bob wants to maximize the score. What will the score of the game be if both players play optimally?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer m (1 \u2264 m \u2264 10^5) \u2014 the number of columns of the matrix.\\n\\nThe i-th of the next 2 lines contain m integers a_{i,1}, a_{i,2},..., a_{i,m} (1 \u2264 a_{i,j} \u2264 10^4) \u2014 the number of coins in the cell in the i-th row in the j-th column of the matrix.\\n\\nThe sum of m over all testcases doesn't exceed 10^5.\\n\\nOutput\\n\\nFor each testcase print a single integer \u2014 the score of the game if both players play optimally.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1 3 7\\n3 5 1\\n3\\n1 3 9\\n3 5 1\\n1\\n4\\n7\\n\\n\\nOutput\\n\\n\\n7\\n8\\n0\\n\\nNote\\n\\nThe paths for the testcases are shown on the following pictures. Alice's path is depicted in red and Bob's path is depicted in blue.\\n\\n<image>"}
{"epoch": "10", "task_id": "41", "completion": "n, m = map(int, raw_input().split())\\ns = raw_input()\\n\\nt = [0] * n\\nfor i in range(n - 1):\\n    t[i] = ord(s[i]) - ord('a')\\n\\nfor i in range(m):\\n    l, r = map(int, raw_input().split())\\n    for j in range(l, r + 1):\\n        t[j] = t[j - 1] + 1\\n    print min(t)", "prompt": "Let's call the string beautiful if it does not contain a substring of length at least 2, which is a palindrome. Recall that a palindrome is a string that reads the same way from the first character to the last and from the last character to the first. For example, the strings a, bab, acca, bcabcbacb are palindromes, but the strings ab, abbbaa, cccb are not.\\n\\nLet's define cost of a string as the minimum number of operations so that the string becomes beautiful, if in one operation it is allowed to change any character of the string to one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou are given a string s of length n, each character of the string is one of the first 3 letters of the Latin alphabet (in lowercase).\\n\\nYou have to answer m queries \u2014 calculate the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the length of the string s and the number of queries.\\n\\nThe second line contains the string s, it consists of n characters, each character one of the first 3 Latin letters.\\n\\nThe following m lines contain two integers l_i and r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 parameters of the i-th query.\\n\\nOutput\\n\\nFor each query, print a single integer \u2014 the cost of the substring of the string s from l_i-th to r_i-th position, inclusive.\\n\\nExample\\n\\nInput\\n\\n\\n5 4\\nbaacb\\n1 3\\n1 5\\n4 5\\n2 3\\n\\n\\nOutput\\n\\n\\n1\\n2\\n0\\n1\\n\\nNote\\n\\nConsider the queries of the example test.\\n\\n  * in the first query, the substring is baa, which can be changed to bac in one operation; \\n  * in the second query, the substring is baacb, which can be changed to cbacb in two operations; \\n  * in the third query, the substring is cb, which can be left unchanged; \\n  * in the fourth query, the substring is aa, which can be changed to ba in one operation. "}
{"epoch": "10", "task_id": "44", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    a,b = map(int,stdin.readline().split())\\n    if a == 0 and b == 0:\\n        print 0\\n    elif a == 0 and b == 0:\\n        print 1\\n    elif a == b:\\n        print 2\\n    elif a < b:\\n        print -1\\n    else:\\n        a,b = a + b,a + b\\n        print 1 if a == b else 2", "prompt": "<image>\\n\\nWilliam has two numbers a and b initially both equal to zero. William mastered performing three different operations with them quickly. Before performing each operation some positive integer k is picked, which is then used to perform one of the following operations: (note, that for each operation you can choose a new positive integer k)\\n\\n  1. add number k to both a and b, or \\n  2. add number k to a and subtract k from b, or \\n  3. add number k to b and subtract k from a. \\n\\n\\n\\nNote that after performing operations, numbers a and b may become negative as well.\\n\\nWilliam wants to find out the minimal number of operations he would have to perform to make a equal to his favorite number c and b equal to his second favorite number d.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe only line of each test case contains two integers c and d (0 \u2264 c, d \u2264 10^9), which are William's favorite numbers and which he wants a and b to be transformed into.\\n\\nOutput\\n\\nFor each test case output a single number, which is the minimal number of operations which William would have to perform to make a equal to c and b equal to d, or -1 if it is impossible to achieve this using the described operations.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n1 2\\n3 5\\n5 3\\n6 6\\n8 0\\n0 0\\n\\n\\nOutput\\n\\n\\n-1\\n2\\n2\\n1\\n2\\n0\\n\\nNote\\n\\nLet us demonstrate one of the suboptimal ways of getting a pair (3, 5):\\n\\n  * Using an operation of the first type with k=1, the current pair would be equal to (1, 1). \\n  * Using an operation of the third type with k=8, the current pair would be equal to (-7, 9). \\n  * Using an operation of the second type with k=7, the current pair would be equal to (0, 2). \\n  * Using an operation of the first type with k=3, the current pair would be equal to (3, 5). "}
{"epoch": "10", "task_id": "45", "completion": "t = input()\\nfor _ in xrange(t):\\n\\tn = input()\\n\\ta = map(int, raw_input().split())\\n\\tm = max(a)\\n\\ta.insert(0,0)\\n\\tif a.count(1) > 1:\\n\\t\\tprint 0\\n\\t\\tcontinue\\n\\tans = -1\\n\\tfor i in xrange(m):\\n\\t\\tif a[i] == 1:\\n\\t\\t\\tans = i + 1\\n\\t\\tif a[i] > 1:\\n\\t\\t\\tans = -1\\n\\tif ans >= 2:\\n\\t\\tprint ans\\n\\telse:\\n\\t\\tprint ans", "prompt": "<image>\\n\\nWilliam has an array of n integers a_1, a_2,..., a_n. In one move he can swap two neighboring items. Two items a_i and a_j are considered neighboring if the condition |i - j| = 1 is satisfied.\\n\\nWilliam wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 10^5) which is the total number of items in William's array.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) which are William's array.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case output the minimal number of operations needed or -1 if it is impossible to get the array to a state when no neighboring numbers have the same parity.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n3\\n6 6 1\\n1\\n9\\n6\\n1 1 1 2 2 2\\n2\\n8 6\\n6\\n6 2 3 4 5 1\\n\\n\\nOutput\\n\\n\\n1\\n0\\n3\\n-1\\n2\\n\\nNote\\n\\nIn the first test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 1, 6] \\n\\n\\n\\nIn the second test case the array initially does not contain two neighboring items of the same parity.\\n\\nIn the third test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(3, 4). Array after performing the operation: [1, 1, 2, 1, 2, 2] \\n  2. swap(2, 3). Array after performing the operation: [1, 2, 1, 1, 2, 2] \\n  3. swap(4, 5). Array after performing the operation: [1, 2, 1, 2, 1, 2] \\n\\n\\n\\nIn the fourth test case it is impossible to satisfy the requirements.\\n\\nIn the fifth test case the following sequence of operations would satisfy the requirements: \\n\\n  1. swap(2, 3). Array after performing the operation: [6, 3, 2, 4, 5, 1] \\n  2. swap(4, 5). Array after performing the operation: [6, 3, 2, 5, 4, 1] "}
{"epoch": "10", "task_id": "46", "completion": "n=input()\\na=map(int,raw_input().split())\\n\\nans=0\\n\\nfor i in xrange(n):\\n    if a[i]%2==0:\\n        ans+=i\\n    else:\\n        if a[i]>1:\\n            ans+=i\\n        else:\\n            ans+=i\\nprint ans", "prompt": "<image>\\n\\nWilliam has a favorite bracket sequence. Since his favorite sequence is quite big he provided it to you as a sequence of positive integers c_1, c_2,..., c_n where c_i is the number of consecutive brackets \"(\" if i is an odd number or the number of consecutive brackets \")\" if i is an even number.\\n\\nFor example for a bracket sequence \"((())()))\" a corresponding sequence of numbers is [3, 2, 1, 3].\\n\\nYou need to find the total number of continuous subsequences (subsegments) [l, r] (l \u2264 r) of the original bracket sequence, which are regular bracket sequences.\\n\\nA bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are regular, while \")(\", \"(()\" and \"(()))(\" are not.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 1000), the size of the compressed sequence.\\n\\nThe second line contains a sequence of integers c_1, c_2,..., c_n (1 \u2264 c_i \u2264 10^9), the compressed sequence.\\n\\nOutput\\n\\nOutput a single integer \u2014 the total number of subsegments of the original bracket sequence, which are regular bracket sequences.\\n\\nIt can be proved that the answer fits in the signed 64-bit integer data type.\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4 1 2 3 1\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n6\\n1 3 2 1 2 4\\n\\n\\nOutput\\n\\n\\n6\\n\\n\\nInput\\n\\n\\n6\\n1 1 1 1 2 2\\n\\n\\nOutput\\n\\n\\n7\\n\\nNote\\n\\nIn the first example a sequence (((()(()))( is described. This bracket sequence contains 5 subsegments which form regular bracket sequences:\\n\\n  1. Subsequence from the 3rd to 10th character: (()(()))\\n  2. Subsequence from the 4th to 5th character: ()\\n  3. Subsequence from the 4th to 9th character: ()(())\\n  4. Subsequence from the 6th to 9th character: (())\\n  5. Subsequence from the 7th to 8th character: ()\\n\\n\\n\\nIn the second example a sequence ()))(()(()))) is described.\\n\\nIn the third example a sequence ()()(()) is described."}
{"epoch": "10", "task_id": "52", "completion": "for _ in range(input()):\\n    n=input()\\n    arr=map(int,raw_input().split())\\n    arr.sort()\\n    x=sum(arr)\\n    y=0\\n    x1=0\\n    y1=0\\n    for i in arr:\\n        y+=i\\n        x1+=1\\n        y1-=1\\n        if i==0:\\n            x1+=x\\n        else:\\n            y1+=x\\n    ans=x1*y1/x1+x*x1\\n    print ans", "prompt": "Ezzat has an array of n integers (maybe negative). He wants to split it into two non-empty subsequences a and b, such that every element from the array belongs to exactly one subsequence, and the value of f(a) + f(b) is the maximum possible value, where f(x) is the average of the subsequence x. \\n\\nA sequence x is a subsequence of a sequence y if x can be obtained from y by deletion of several (possibly, zero or all) elements.\\n\\nThe average of a subsequence is the sum of the numbers of this subsequence divided by the size of the subsequence.\\n\\nFor example, the average of [1,5,6] is (1+5+6)/3 = 12/3 = 4, so f([1,5,6]) = 4.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3)\u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the maximum value that Ezzat can achieve.\\n\\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-6}.\\n\\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-6}.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3\\n3 1 2\\n3\\n-7 -6 -6\\n3\\n2 2 2\\n4\\n17 3 5 -3\\n\\n\\nOutput\\n\\n\\n4.500000000\\n-12.500000000\\n4.000000000\\n18.666666667\\n\\nNote\\n\\nIn the first test case, the array is [3, 1, 2]. These are all the possible ways to split this array: \\n\\n  * a = [3], b = [1,2], so the value of f(a) + f(b) = 3 + 1.5 = 4.5. \\n  * a = [3,1], b = [2], so the value of f(a) + f(b) = 2 + 2 = 4. \\n  * a = [3,2], b = [1], so the value of f(a) + f(b) = 2.5 + 1 = 3.5. \\n\\nTherefore, the maximum possible value 4.5.\\n\\nIn the second test case, the array is [-7, -6, -6]. These are all the possible ways to split this array: \\n\\n  * a = [-7], b = [-6,-6], so the value of f(a) + f(b) = (-7) + (-6) = -13. \\n  * a = [-7,-6], b = [-6], so the value of f(a) + f(b) = (-6.5) + (-6) = -12.5. \\n\\nTherefore, the maximum possible value -12.5."}
{"epoch": "10", "task_id": "53", "completion": "t=int(input())\\nfor i in range(t):\\n    n,k=map(int,raw_input().split())\\n    a=map(int,raw_input().split())\\n    if k==1:\\n        print('NO')\\n    else:\\n        print('YES')\\n", "prompt": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\\n\\n  1. Split the array into exactly k non-empty subarrays such that each element belongs to exactly one subarray. \\n  2. Reorder these subarrays arbitrary. \\n  3. Merge the subarrays in their new order. \\n\\n\\n\\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 10^5).\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9). It is guaranteed that all numbers are distinct.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^5.\\n\\nOutput\\n\\nFor each test case, you should output a single string.\\n\\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\\n\\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n5 4\\n6 3 4 2 1\\n4 2\\n1 -4 0 -2\\n5 1\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\nYes\\nNo\\nYes\\n\\nNote\\n\\nIn the first test case, a = [6, 3, 4, 2, 1], and k = 4, so we can do the operations as follows: \\n\\n  1. Split a into \\{ [6], [3, 4], [2], [1] \\}. \\n  2. Reorder them: \\{ [1], [2], [3,4], [6] \\}. \\n  3. Merge them: [1, 2, 3, 4, 6], so now the array is sorted. \\n\\n\\n\\nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\\n\\nAs an example, if we split it into \\{ [1, -4], [0, -2] \\}, we can reorder them into \\{ [1, -4], [0, -2] \\} or \\{ [0, -2], [1, -4] \\}. However, after merging the subarrays, it is impossible to get a sorted array."}
{"epoch": "10", "task_id": "54", "completion": "\\nt = input()\\nfor _ in range(t):\\n    n, k = map(int, raw_input().split())\\n    if k == 0:\\n        print 1\\n    else:\\n        ans = 1\\n        for i in range(1, 2**k+1):\\n            ans = (ans * i) % 1000000007\\n        print ans", "prompt": "Moamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\\n\\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\\n\\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\\n\\nPlease calculate the number of winning for Moamen arrays a.\\n\\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\\n\\nOutput\\n\\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\\n\\nPrint the result modulo 1 000 000 007 (10^9 + 7).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3 1\\n2 1\\n4 0\\n\\n\\nOutput\\n\\n\\n5\\n2\\n1\\n\\nNote\\n\\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\\n\\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1]."}
{"epoch": "10", "task_id": "60", "completion": "for _ in range(input()):\\n    n = input()\\n    a = map(int,raw_input().split())\\n    ans = 1 << 20\\n    for i in range(1,n+1):\\n        s = 1 << i\\n        for j in range(i+1,n+1):\\n            if a[i] & s:\\n                s = 0\\n            else:\\n                s = 0\\n    if s == 0:\\n        ans = 0\\n    else:\\n        s = 0\\n    ans = max(ans,s)\\n    print ans\\n", "prompt": "Mocha is a young girl from high school. She has learned so much interesting knowledge from her teachers, especially her math teacher. Recently, Mocha is learning about binary system and very interested in bitwise operation.\\n\\nThis day, Mocha got a sequence a of length n. In each operation, she can select an arbitrary interval [l, r] and for all values i (0\u2264 i \u2264 r-l), replace a_{l+i} with a_{l+i}  \\&  a_{r-i} at the same time, where \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). This operation can be performed any number of times.\\n\\nFor example, if n=5, the array is [a_1,a_2,a_3,a_4,a_5], and Mocha selects the interval [2,5], then the new array is [a_1,a_2 \\&  a_5, a_3 \\&  a_4, a_4 \\&  a_3, a_5 \\&  a_2].\\n\\nNow Mocha wants to minimize the maximum value in the sequence. As her best friend, can you help her to get the answer?\\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the minimal value of the maximum value in the sequence.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n1 1 3\\n4\\n3 11 3 7\\n5\\n11 7 15 3 7\\n\\n\\nOutput\\n\\n\\n0\\n1\\n3\\n3\\n\\nNote\\n\\nIn the first test case, Mocha can choose the interval [1,2], then the sequence becomes [ 0, 0], where the first element is 1 \\& 2, and the second element is 2 \\& 1.\\n\\nIn the second test case, Mocha can choose the interval [1,3], then the sequence becomes [ 1,1,1], where the first element is 1 \\& 3, the second element is 1 \\& 1, and the third element is 3 \\& 1."}
{"epoch": "10", "task_id": "61", "completion": "t = int(input())\\nwhile t:\\n\\tn = int(input())\\n\\ts = raw_input()\\n\\tl = []\\n\\tfor i in xrange(n):\\n\\t\\tl.append(s[i])\\n\\tl.sort()\\n\\tl.reverse()\\n\\tp = 0\\n\\tfor i in xrange(len(l)):\\n\\t\\tif l[i]!= '?':\\n\\t\\t\\tif l[i] == '?':\\n\\t\\t\\t\\tif l[i] == 'B':\\n\\t\\t\\t\\t\\tp += 1\\n\\t\\t\\telif l[i] == '?':\\n\\t\\t\\t\\tif l[i] == 'B':\\n\\t\\t\\t\\t\\tp += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif l[i] == 'B':\\n\\t\\t\\t\\t\\tp += 1\\n\\t\\t\\t\\telif l[i] == 'R':\\n\\t\\t\\t\\t\\tif l[i] == 'B':\\n\\t\\t\\t\\t\\t\\tif l[i] == 'R':\\n\\t\\t\\t\\t\\t\\t\\tif l[i] == '?':\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tp -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif l[i] == 'B':\\n\\t\\t\\t\\t\\t", "prompt": "As their story unravels, a timeless tale is told once again...\\n\\nShirahime, a friend of Mocha's, is keen on playing the music game Arcaea and sharing Mocha interesting puzzles to solve. This day, Shirahime comes up with a new simple puzzle and wants Mocha to solve them. However, these puzzles are too easy for Mocha to solve, so she wants you to solve them and tell her the answers. The puzzles are described as follow.\\n\\nThere are n squares arranged in a row, and each of them can be painted either red or blue.\\n\\nAmong these squares, some of them have been painted already, and the others are blank. You can decide which color to paint on each blank square.\\n\\nSome pairs of adjacent squares may have the same color, which is imperfect. We define the imperfectness as the number of pairs of adjacent squares that share the same color.\\n\\nFor example, the imperfectness of \"BRRRBBR\" is 3, with \"BB\" occurred once and \"RR\" occurred twice.\\n\\nYour goal is to minimize the imperfectness and print out the colors of the squares after painting. \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains an integer n (1\u2264 n\u2264 100) \u2014 the length of the squares row.\\n\\nThe second line of each test case contains a string s with length n, containing characters 'B', 'R' and '?'. Here 'B' stands for a blue square, 'R' for a red square, and '?' for a blank square.\\n\\nOutput\\n\\nFor each test case, print a line with a string only containing 'B' and 'R', the colors of the squares after painting, which imperfectness is minimized. If there are multiple solutions, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n7\\n?R???BR\\n7\\n???R???\\n1\\n?\\n1\\nB\\n10\\n?R??RB??B?\\n\\n\\nOutput\\n\\n\\nBRRBRBR\\nBRBRBRB\\nB\\nB\\nBRRBRBBRBR\\n\\nNote\\n\\nIn the first test case, if the squares are painted \"BRRBRBR\", the imperfectness is 1 (since squares 2 and 3 have the same color), which is the minimum possible imperfectness."}
{"epoch": "10", "task_id": "62", "completion": "for _ in range(input()):\\n    n = input()\\n    a = map(int, raw_input().split())\\n    print''.join(map(str, [(a[i], i+1) if a[i] else i+1) for i in range(n)]))\\n", "prompt": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \\n\\nThere are two kinds of roads:\\n\\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \\n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \\n\\n\\n\\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \\n\\nInput\\n\\nEach test contains multiple test cases. \\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\\n\\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\\n\\nIf there are multiple correct answers, you can print any one of them.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n3\\n0 1 0\\n3\\n1 1 0\\n\\n\\nOutput\\n\\n\\n1 4 2 3 \\n4 1 2 3 \\n\\nNote\\n\\nIn the first test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\\n\\nIn the second test case, the city looks like the following graph:\\n\\n<image>\\n\\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1)."}
{"epoch": "10", "task_id": "66", "completion": "def solve(k):\\n\\tn = len(str(k))\\n\\t\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\n\\tif n % 3 == 1:\\n\\t\\treturn (1 + solve(k - 1)) / 3\\n\\telse:\\n\\t\\treturn (k - 1) * (k - 1) / 3\\n\\n\\ndef main():\\n\\tt = int(raw_input())\\n\\tfor i in range(t):\\n\\t\\tk = int(raw_input())\\n\\t\\tprint solve(k)\\n\\nif __name__ == '__main__':\\n\\tmain()", "prompt": "Polycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\\n\\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\\n\\nExample\\n\\nInput\\n\\n\\n10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n1000\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n5\\n7\\n8\\n10\\n11\\n14\\n1666"}
{"epoch": "10", "task_id": "67", "completion": "from __future__ import division, print_function\\nfrom heapq import*\\nimport sys\\nle = sys.__stdin__.read().split(\"\\n\")[::-1]\\naf = []\\nfor zorg in range(int(le.pop())):\\n\\ta,b,c = list(map(int,le.pop().split()))\\n\\tif b==c and a in map(int,le.pop().split()):\\n\\t\\tprint(-1)\\n\\telif c in map(int,le.pop().split()):\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\ta,b,c = list(map(int,le.pop().split()))\\n\\t\\tif b in map(int,le.pop().split()):\\n\\t\\t\\tprint(b-1)\\n\\t\\telse:\\n\\t\\t\\tprint(-1)\\n", "prompt": "Some number of people (this number is even) have stood in a circle. The people stand in the circle evenly. They are numbered clockwise starting from a person with the number 1. Each person is looking through the circle's center at the opposite person.\\n\\n<image> A sample of a circle of 6 persons. The orange arrows indicate who is looking at whom.\\n\\nYou don't know the exact number of people standing in the circle (but this number is even, no doubt). It is known that the person with the number a is looking at the person with the number b (and vice versa, of course). What is the number associated with a person being looked at by the person with the number c? If, for the specified a, b, and c, no such circle exists, output -1.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing three distinct integers a, b, c (1 \u2264 a,b,c \u2264 10^8).\\n\\nOutput\\n\\nFor each test case output in a separate line a single integer d \u2014 the number of the person being looked at by the person with the number c in a circle such that the person with the number a is looking at the person with the number b. If there are multiple solutions, print any of them. Output -1 if there's no circle meeting the given conditions.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6 2 4\\n2 3 1\\n2 4 10\\n5 3 4\\n1 3 2\\n2 5 4\\n4 3 2\\n\\n\\nOutput\\n\\n\\n8\\n-1\\n-1\\n-1\\n4\\n1\\n-1\\n\\nNote\\n\\nIn the first test case, there's a desired circle of 8 people. The person with the number 6 will look at the person with the number 2 and the person with the number 8 will look at the person with the number 4.\\n\\nIn the second test case, there's no circle meeting the conditions. If the person with the number 2 is looking at the person with the number 3, the circle consists of 2 people because these persons are neighbors. But, in this case, they must have the numbers 1 and 2, but it doesn't meet the problem's conditions.\\n\\nIn the third test case, the only circle with the persons with the numbers 2 and 4 looking at each other consists of 4 people. Therefore, the person with the number 10 doesn't occur in the circle."}
{"epoch": "10", "task_id": "68", "completion": "t = int(raw_input())\\n\\nfor i in range(t):\\n    n = int(raw_input())\\n    if n == 1:\\n        print 1, 1\\n    else:\\n        print 1, 2\\n        print 1, 1\\n\\n", "prompt": "Polycarp has found a table having an infinite number of rows and columns. The rows are numbered from 1, starting from the topmost one. The columns are numbered from 1, starting from the leftmost one.\\n\\nInitially, the table hasn't been filled and Polycarp wants to fix it. He writes integers from 1 and so on to the table as follows.\\n\\n<image> The figure shows the placement of the numbers from 1 to 10. The following actions are denoted by the arrows.\\n\\nThe leftmost topmost cell of the table is filled with the number 1. Then he writes in the table all positive integers beginning from 2 sequentially using the following algorithm.\\n\\nFirst, Polycarp selects the leftmost non-filled cell in the first row and fills it. Then, while the left neighbor of the last filled cell is filled, he goes down and fills the next cell. So he goes down until the last filled cell has a non-filled neighbor to the left (look at the vertical arrow going down in the figure above).\\n\\nAfter that, he fills the cells from the right to the left until he stops at the first column (look at the horizontal row in the figure above). Then Polycarp selects the leftmost non-filled cell in the first row, goes down, and so on.\\n\\nA friend of Polycarp has a favorite number k. He wants to know which cell will contain the number. Help him to find the indices of the row and the column, such that the intersection of the row and the column is the cell containing the number k.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 10^9) which location must be found.\\n\\nOutput\\n\\nFor each test case, output in a separate line two integers r and c (r, c \u2265 1) separated by spaces \u2014 the indices of the row and the column containing the cell filled by the number k, respectively.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n11\\n14\\n5\\n4\\n1\\n2\\n1000000000\\n\\n\\nOutput\\n\\n\\n2 4\\n4 3\\n1 3\\n2 1\\n1 1\\n1 2\\n31623 14130"}
{"epoch": "10", "task_id": "69", "completion": "import sys\\n\\nfor _ in range(input()):\\n    n=raw_input()\\n    ans=n.count('0')\\n    x=n.count('1')\\n    if int(x)>0:\\n        if int(x)<=0:\\n            print int(x)\\n        else:\\n            print x-int(x)\\n        continue\\n    ans=int(0)\\n    if x==0:\\n        print ans\\n        continue\\n    while x:\\n        y=x%2\\n        if y==0:\\n            ans=ans+1\\n        x/=2\\n        else:\\n            ans+=1\\n    print ans\\n", "prompt": "You are given an integer n. In 1 move, you can do one of the following actions:\\n\\n  * erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\"); \\n  * add one digit to the right. \\n\\n\\n\\nThe actions may be performed in any order any number of times.\\n\\nNote that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number 301 the digit 3, the result is the number 01 (not 1).\\n\\nYou need to perform the minimum number of actions to make the number any power of 2 (i.e. there's an integer k (k \u2265 0) such that the resulting number is equal to 2^k). The resulting number must not have leading zeroes.\\n\\nE.g. consider n=1052. The answer is equal to 2. First, let's add to the right one digit 4 (the result will be 10524). Then let's erase the digit 5, so the result will be 1024 which is a power of 2.\\n\\nE.g. consider n=8888. The answer is equal to 3. Let's erase any of the digits 8 three times. The result will be 8 which is a power of 2.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 10^9).\\n\\nOutput\\n\\nFor each test case, output in a separate line one integer m \u2014 the minimum number of moves to transform the number into any power of 2.\\n\\nExample\\n\\nInput\\n\\n\\n12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\\n\\n\\nOutput\\n\\n\\n2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\\n\\nNote\\n\\nThe answer for the first test case was considered above.\\n\\nThe answer for the second test case was considered above.\\n\\nIn the third test case, it's enough to add to the right the digit 4 \u2014 the number 6 will turn into 64.\\n\\nIn the fourth test case, let's add to the right the digit 8 and then erase 7 and 5 \u2014 the taken number will turn into 8.\\n\\nThe numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.\\n\\nIn the seventh test case, you can delete first of all the digit 3 (the result is 01) and then the digit 0 (the result is 1)."}
{"epoch": "10", "task_id": "70", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    t = input()\\n    s = [chr(ord('a')+i) for i in range(97,123)]\\n    ans = []\\n    for i in range(97,123):\\n        if s[i] not in s:\\n            ans.append(s[i])\\n        else:\\n            if s[i] not in s:\\n                ans.append(s[i])\\n                s[i] = []\\n            else:\\n                s[i] = []\\n            for i in range(97,123):\\n                if s[i] not in s:\\n                    s[i] = []\\n                    s[i] = []\\n            if i not in s:\\n                ans.append(s[i])\\n                s[i] = []\\n        ans.append(s[97])\\n    if len(ans) == 0:\\n        print -1\\n    else:\\n        print''.join(ans)\\n", "prompt": "Polycarp has a string s. Polycarp performs the following actions until the string s is empty (t is initially an empty string):\\n\\n  * he adds to the right to the string t the string s, i.e. he does t = t + s, where t + s is a concatenation of the strings t and s; \\n  * he selects an arbitrary letter of s and removes from s all its occurrences (the selected letter must occur in the string s at the moment of performing this action). \\n\\n\\n\\nPolycarp performs this sequence of actions strictly in this order.\\n\\nNote that after Polycarp finishes the actions, the string s will be empty and the string t will be equal to some value (that is undefined and depends on the order of removing).\\n\\nE.g. consider s=\"abacaba\" so the actions may be performed as follows:\\n\\n  * t=\"abacaba\", the letter 'b' is selected, then s=\"aacaa\"; \\n  * t=\"abacabaaacaa\", the letter 'a' is selected, then s=\"c\"; \\n  * t=\"abacabaaacaac\", the letter 'c' is selected, then s=\"\" (the empty string). \\n\\n\\n\\nYou need to restore the initial value of the string s using only the final value of t and find the order of removing letters from s.\\n\\nInput\\n\\nThe first line contains one integer T (1 \u2264 T \u2264 10^4) \u2014 the number of test cases. Then T test cases follow.\\n\\nEach test case contains one string t consisting of lowercase letters of the Latin alphabet. The length of t doesn't exceed 5 \u22c5 10^5. The sum of lengths of all strings t in the test cases doesn't exceed 5 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case output in a separate line:\\n\\n  * -1, if the answer doesn't exist; \\n  * two strings separated by spaces. The first one must contain a possible initial value of s. The second one must contain a sequence of letters \u2014 it's in what order one needs to remove letters from s to make the string t. E.g. if the string \"bac\" is outputted, then, first, all occurrences of the letter 'b' were deleted, then all occurrences of 'a', and then, finally, all occurrences of 'c'. If there are multiple solutions, print any one. \\n\\nExample\\n\\nInput\\n\\n\\n7\\nabacabaaacaac\\nnowyouknowthat\\npolycarppoycarppoyarppyarppyrpprppp\\nisi\\neverywherevrywhrvryhrvrhrvhv\\nhaaha\\nqweqeewew\\n\\n\\nOutput\\n\\n\\nabacaba bac\\n-1\\npolycarp lcoayrp\\nis si\\neverywhere ewyrhv\\n-1\\n-1\\n\\nNote\\n\\nThe first test case is considered in the statement."}
{"epoch": "10", "task_id": "71", "completion": "for _ in range(input()):\\n    n,k = map(int,raw_input().split())\\n    ans = n\\n    p = 10**k\\n    while p>=p:\\n        ans = ans + \"0\"\\n        p = p-p\\n    p = p/10\\n    if n%p==0 and k==1:\\n        p = n/p\\n    ans = str(n)\\n    if p%10==1 and k==2:\\n        ans = str(n)\\n    print ans", "prompt": "It is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n221 2\\n177890 2\\n998244353 1\\n\\n\\nOutput\\n\\n\\n1\\n221\\n181111\\n999999999"}
{"epoch": "10", "task_id": "72", "completion": "t = int(raw_input())\\nfor _ in xrange(t):\\n    n, k = [int(x) for x in raw_input().split()]\\n    n = n + str(k)\\n    k_list = []\\n    k_list.append(n)\\n    i = 1\\n    while(k_list!= []):\\n        if(k_list!= []):\\n            k_list.append(0)\\n            k_list.append(1)\\n        else:\\n            i += 1\\n    while(k_list!= []):\\n        i += 1\\n        k_list.append(0)\\n    i = 0\\n    while(i < k_list[-1]):\\n        i += 1\\n        k_list.pop()\\n        if(k_list!= []):\\n            i += 1\\n        else:\\n            i -= 1\\n    if(i == k):\\n        i += 1\\n    print n", "prompt": "It is a complicated version of problem F1. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\\n\\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\\n\\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\\n\\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 10).\\n\\nOutput\\n\\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n2021 3\\n177890 2\\n34512 3\\n724533 4\\n998244353 1\\n12345678 10\\n\\n\\nOutput\\n\\n\\n2021\\n181111\\n34533\\n724542\\n999999999\\n12345678"}
{"epoch": "10", "task_id": "73", "completion": "\\nfor _ in range(input()):\\n    n=input()\\n    l=map(int,raw_input().split())\\n    l1=[]\\n    if n%2==0:\\n        for i in range(1,n/2+1):\\n            if l[i]>l[i-1]:\\n                l1.append(i)\\n                l1.append(n)\\n    if len(l1)>0:\\n        print(0)\\n    else:\\n        l=[]\\n        for i in range(n/2):\\n            if l[i]<l[i-1]:\\n                l.append(l[i-1])\\n            else:\\n                l.append(l[i])\\n        print(len(l))", "prompt": "You have a permutation: an array a = [a_1, a_2, \u2026, a_n] of distinct integers from 1 to n. The length of the permutation n is odd.\\n\\nConsider the following algorithm of sorting the permutation in increasing order.\\n\\nA helper procedure of the algorithm, f(i), takes a single argument i (1 \u2264 i \u2264 n-1) and does the following. If a_i > a_{i+1}, the values of a_i and a_{i+1} are exchanged. Otherwise, the permutation doesn't change.\\n\\nThe algorithm consists of iterations, numbered with consecutive integers starting with 1. On the i-th iteration, the algorithm does the following: \\n\\n  * if i is odd, call f(1), f(3), \u2026, f(n - 2); \\n  * if i is even, call f(2), f(4), \u2026, f(n - 1). \\n\\n\\n\\nIt can be proven that after a finite number of iterations the permutation will be sorted in increasing order.\\n\\nAfter how many iterations will this happen for the first time?\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (3 \u2264 n \u2264 999; n is odd) \u2014 the length of the permutation.\\n\\nThe second line contains n distinct integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the permutation itself. \\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 999.\\n\\nOutput\\n\\nFor each test case print the number of iterations after which the permutation will become sorted in increasing order for the first time.\\n\\nIf the given permutation is already sorted, print 0.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n3 2 1\\n7\\n4 5 7 1 3 2 6\\n5\\n1 2 3 4 5\\n\\n\\nOutput\\n\\n\\n3\\n5\\n0\\n\\nNote\\n\\nIn the first test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [2, 3, 1]; \\n  * after the 2-nd iteration: [2, 1, 3]; \\n  * after the 3-rd iteration: [1, 2, 3]. \\n\\n\\n\\nIn the second test case, the permutation will be changing as follows: \\n\\n  * after the 1-st iteration: [4, 5, 1, 7, 2, 3, 6]; \\n  * after the 2-nd iteration: [4, 1, 5, 2, 7, 3, 6]; \\n  * after the 3-rd iteration: [1, 4, 2, 5, 3, 7, 6]; \\n  * after the 4-th iteration: [1, 2, 4, 3, 5, 6, 7]; \\n  * after the 5-th iteration: [1, 2, 3, 4, 5, 6, 7]. \\n\\n\\n\\nIn the third test case, the permutation is already sorted and the answer is 0."}
{"epoch": "10", "task_id": "74", "completion": "for _ in xrange(input()):\\n    a,b=map(int,raw_input().split())\\n    a=min(a,b)\\n    b=max(a,b)\\n    if a+b>a:\\n        print a+b\\n    else:\\n        print b+a-1\\n        print a+b,\\n        print 2\\n    for i in xrange(b-a+1):\\n        print i,\\n    print a,\\n    print", "prompt": "Alice and Borys are playing tennis.\\n\\nA tennis match consists of games. In each game, one of the players is serving and the other one is receiving.\\n\\nPlayers serve in turns: after a game where Alice is serving follows a game where Borys is serving, and vice versa.\\n\\nEach game ends with a victory of one of the players. If a game is won by the serving player, it's said that this player holds serve. If a game is won by the receiving player, it's said that this player breaks serve.\\n\\nIt is known that Alice won a games and Borys won b games during the match. It is unknown who served first and who won which games.\\n\\nFind all values of k such that exactly k breaks could happen during the match between Alice and Borys in total.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3). Description of the test cases follows.\\n\\nEach of the next t lines describes one test case and contains two integers a and b (0 \u2264 a, b \u2264 10^5; a + b > 0) \u2014 the number of games won by Alice and Borys, respectively.\\n\\nIt is guaranteed that the sum of a + b over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case print two lines.\\n\\nIn the first line, print a single integer m (1 \u2264 m \u2264 a + b + 1) \u2014 the number of values of k such that exactly k breaks could happen during the match.\\n\\nIn the second line, print m distinct integers k_1, k_2, \u2026, k_m (0 \u2264 k_1 < k_2 < \u2026 < k_m \u2264 a + b) \u2014 the sought values of k in increasing order.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 1\\n1 1\\n0 5\\n\\n\\nOutput\\n\\n\\n4\\n0 1 2 3\\n2\\n0 2\\n2\\n2 3\\n\\nNote\\n\\nIn the first test case, any number of breaks between 0 and 3 could happen during the match: \\n\\n  * Alice holds serve, Borys holds serve, Alice holds serve: 0 breaks; \\n  * Borys holds serve, Alice holds serve, Alice breaks serve: 1 break; \\n  * Borys breaks serve, Alice breaks serve, Alice holds serve: 2 breaks; \\n  * Alice breaks serve, Borys breaks serve, Alice breaks serve: 3 breaks. \\n\\n\\n\\nIn the second test case, the players could either both hold serves (0 breaks) or both break serves (2 breaks).\\n\\nIn the third test case, either 2 or 3 breaks could happen: \\n\\n  * Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve: 2 breaks; \\n  * Borys breaks serve, Borys holds serve, Borys breaks serve, Borys holds serve, Borys breaks serve: 3 breaks. "}
{"epoch": "10", "task_id": "75", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    kase = inp()\\n    pans = []\\n    for _ in range(kase):\\n        n = inp()\\n        a = []\\n        for _ in range(n):\\n            a.append(inp())\\n        mx = max(a)\\n        if n > mx:\\n            mx = mx\\n        ans = mx\\n        for x in a:\\n            if x == mx:\\n                mx = min(mx, x)\\n            else:\\n                ans =", "prompt": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.\\n\\nOn the current level, the hero is facing n caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave i, he will have to fight k_i monsters in a row: first a monster with armor a_{i, 1}, then a monster with armor a_{i, 2} and so on, finally, a monster with armor a_{i, k_i}.\\n\\nThe hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.\\n\\nEach time the hero beats a monster, the hero's power increases by 1.\\n\\nFind the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of caves.\\n\\nThe i-th of the next n lines contains an integer k_i (1 \u2264 k_i \u2264 10^5) \u2014 the number of monsters in the i-th cave, followed by k_i integers a_{i, 1}, a_{i, 2}, \u2026, a_{i, k_i} (1 \u2264 a_{i, j} \u2264 10^9) \u2014 armor levels of the monsters in cave i in order the hero has to fight them.\\n\\nIt is guaranteed that the sum of k_i over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\\n\\n\\nOutput\\n\\n\\n43\\n13\\n\\nNote\\n\\nIn the first test case, the hero has to beat a single monster with armor 42, it's enough to have power 43 to achieve that.\\n\\nIn the second test case, the hero can pass the level with initial power 13 as follows: \\n\\n  * enter cave 2: \\n    * beat a monster with armor 12, power increases to 14; \\n    * beat a monster with armor 11, power increases to 15; \\n  * enter cave 1: \\n    * beat a monster with armor 10, power increases to 16; \\n    * beat a monster with armor 15, power increases to 17; \\n    * beat a monster with armor 8, power increases to 18. "}
{"epoch": "10", "task_id": "76", "completion": "n,m=map(int,raw_input().split())\\nif n==1:\\n\\tprint 2\\nelse:\\n\\tif n%2==1:\\n\\t\\tprint (n-2)*(n-1)%m\\n\\telse:\\n\\t\\tprint (pow(n-1,m)-1)*(pow(n,m-1,m))%m", "prompt": "This version of the problem differs from the next one only in the constraint on n.\\n\\nNote that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "10", "task_id": "77", "completion": "n, m = map(int, raw_input().split())\\n\\nprint n - 1 if n == 1 else (pow(2, n - 2, m) - 1) % m", "prompt": "Note that the memory limit in this problem is lower than in others.\\n\\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\\n\\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\\n\\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \\n\\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \\n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \\n\\n\\n\\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\\n\\nInput\\n\\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\\n\\nOutput\\n\\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\\n\\nExamples\\n\\nInput\\n\\n\\n3 998244353\\n\\n\\nOutput\\n\\n\\n5\\n\\n\\nInput\\n\\n\\n5 998244353\\n\\n\\nOutput\\n\\n\\n25\\n\\n\\nInput\\n\\n\\n42 998244353\\n\\n\\nOutput\\n\\n\\n793019428\\n\\n\\nInput\\n\\n\\n787788 100000007\\n\\n\\nOutput\\n\\n\\n94810539\\n\\nNote\\n\\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\\n\\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\\n\\nTherefore, there are five ways in total."}
{"epoch": "10", "task_id": "78", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = stdin.readline\\npr = stdout.write\\nmod=10**9+7\\n\\ndef ni():\\n    return int(raw_input())\\n\\n\\ndef li():\\n    return list(map(int,raw_input().split()))\\n\\n\\n\\ndef pn(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\ndef pa(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers\\n    # Use Ctrl+D to flush stdin.\\n    return map(int,stdin.read().split())\\n\\nrange = xrange # not for python 3.0+\\n\\n# main code\\nfor t in range(ni()):\\n    l,r=li()\\n    if r-l>=1 and l%2==0:\\n        print 0\\n        continue\\n    ans=1\\n    if r-l>=1", "prompt": "You are given two integers l and r, l\u2264 r. Find the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nAs a reminder, a mod b is a remainder we get when dividing a by b. For example, 26 mod 8 = 2.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1\u2264 t\u2264 10^4), denoting the number of test cases. Description of the test cases follows.\\n\\nThe only line of each test case contains two integers l, r (1\u2264 l \u2264 r \u2264 10^9).\\n\\nOutput\\n\\nFor every test case, output the largest possible value of a mod b over all pairs (a, b) of integers for which r\u2265 a \u2265 b \u2265 l.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 1\\n999999999 1000000000\\n8 26\\n1 999999999\\n\\n\\nOutput\\n\\n\\n0\\n1\\n12\\n499999999\\n\\nNote\\n\\nIn the first test case, the only allowed pair is (a, b) = (1, 1), for which a mod b = 1 mod 1 = 0.\\n\\nIn the second test case, the optimal choice is pair (a, b) = (1000000000, 999999999), for which a mod b = 1."}
{"epoch": "10", "task_id": "79", "completion": "from sys import stdin\\nt = int(stdin.readline())\\nfor _ in xrange(t):\\n    k = int(stdin.readline())\\n    n = stdin.readline().strip()\\n    p = 0\\n    for i in xrange(len(n)):\\n        if n[i] == '1':\\n            p += 1\\n    if p == k:\\n        print k - 1\\n        print n\\n    else:\\n        print k - 1\\n        print n", "prompt": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \\n\\nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\\n\\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\\n\\nNote that you cannot remove all the digits from the number.\\n\\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer k (1 \u2264 k \u2264 50) \u2014 the number of digits in the number.\\n\\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10^{k-1} \u2264 n < 10^{k}). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\\n\\nIt is guaranteed that the sum of k over all test cases does not exceed 10^4.\\n\\nOutput\\n\\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n237\\n5\\n44444\\n3\\n221\\n2\\n35\\n3\\n773\\n1\\n4\\n30\\n626221626221626221626221626221\\n\\n\\nOutput\\n\\n\\n2\\n27\\n1\\n4\\n1\\n1\\n2\\n35\\n2\\n77\\n1\\n4\\n1\\n6\\n\\nNote\\n\\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27 = 3^3.\\n\\nIn the second test case, you can delete all digits except one, as 4 = 2^2 is a composite number."}
{"epoch": "10", "task_id": "80", "completion": "from sys import stdin\\n\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nout = []\\n\\nt, = rints(), [0] * (n + 1)\\n\\nfor _ in range(t):\\n    n, s = rint(), rints()\\n\\n    prev = s[-1]\\n    ans = [1] * (n + 1)\\n\\n    while prev!= s[0]:\\n        ans[0] += 1\\n        prev = s[-1]\\n        prev = s[-1]\\n    if prev == s[0]:\\n        ans[1] += 1\\n        prev = s[-1]\\n        ans[2] += 1\\n\\n    print(\" \".join(map(str, ans)))\\n", "prompt": "Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents \u2014there was a pile of different rings: gold and silver...\\n\\n\"How am I to tell which is the One?!\" the mage howled.\\n\\n\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" \\n\\nSomewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found n rings. And the i-th ring was either gold or silver. For convenience Saruman wrote down a binary string s of n characters, where the i-th character was 0 if the i-th ring was gold, and 1 if it was silver.\\n\\nSaruman has a magic function f, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, f(001010) = 10, f(111) = 7, f(11011101) = 221.\\n\\nSaruman, however, thinks that the order of the rings plays some important role. He wants to find 2 pairs of integers (l_1, r_1), (l_2, r_2), such that:\\n\\n  * 1 \u2264 l_1 \u2264 n, 1 \u2264 r_1 \u2264 n, r_1-l_1+1\u2265 \u230a n/2 \u230b \\n  * 1 \u2264 l_2 \u2264 n, 1 \u2264 r_2 \u2264 n, r_2-l_2+1\u2265 \u230a n/2 \u230b \\n  * Pairs (l_1, r_1) and (l_2, r_2) are distinct. That is, at least one of l_1 \u2260 l_2 and r_1 \u2260 r_2 must hold.\\n  * Let t be the substring s[l_1:r_1] of s, and w be the substring s[l_2:r_2] of s. Then there exists non-negative integer k, such that f(t) = f(w) \u22c5 k.\\n\\n\\n\\nHere substring s[l:r] denotes s_ls_{l+1}\u2026 s_{r-1}s_r, and \u230a x \u230b denotes rounding the number down to the nearest integer.\\n\\nHelp Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains one positive integer n (2 \u2264 n \u2264 2 \u22c5 10^4) \u2014 length of the string.\\n\\nThe second line of each test case contains a non-empty binary string of length n.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor every test case print four integers l_1, r_1, l_2, r_2, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.\\n\\nIf there are multiple solutions, print any.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n6\\n101111\\n9\\n111000111\\n8\\n10000000\\n5\\n11011\\n6\\n001111\\n3\\n101\\n30\\n100000000000000100000000000000\\n\\n\\nOutput\\n\\n\\n3 6 1 3\\n1 9 4 9\\n5 8 1 4\\n1 5 3 5\\n1 6 2 4\\n1 2 2 3\\n1 15 16 30\\n\\nNote\\n\\nIn the first testcase f(t) = f(1111) = 15, f(w) = f(101) = 5.\\n\\nIn the second testcase f(t) = f(111000111) = 455, f(w) = f(000111) = 7.\\n\\nIn the third testcase f(t) = f(0000) = 0, f(w) = f(1000) = 8.\\n\\nIn the fourth testcase f(t) = f(11011) = 27, f(w) = f(011) = 3.\\n\\nIn the fifth testcase f(t) = f(001111) = 15, f(w) = f(011) = 3."}
{"epoch": "10", "task_id": "81", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\n\\ndef my_main():\\n    t = inp()\\n    for _ in range(t):\\n        n, q = inp()\\n        s = inp()\\n        l = [[] for i in range(n)]\\n        for i in range(q):\\n            l[i], r[i] = inp()\\n            l.sort()\\n            r.sort()\\n            if s[0] == '+' or s[r[-1]] == '-':\\n                print 1\\n                continue\\n            l[-1] += 1\\n            r[-", "prompt": "This is the easy version of the problem. The difference between the versions is that the easy version does not require you to output the numbers of the rods to be removed. You can make hacks only if all versions of the problem are solved.\\n\\nStitch likes experimenting with different machines with his friend Sparky. Today they built another machine.\\n\\nThe main element of this machine are n rods arranged along one straight line and numbered from 1 to n inclusive. Each of these rods must carry an electric charge quantitatively equal to either 1 or -1 (otherwise the machine will not work). Another condition for this machine to work is that the sign-variable sum of the charge on all rods must be zero.\\n\\nMore formally, the rods can be represented as an array of n numbers characterizing the charge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 - a_4 + \u2026 = 0, or \u2211_{i=1}^n (-1)^{i-1} \u22c5 a_i = 0.\\n\\nSparky charged all n rods with an electric current, but unfortunately it happened that the rods were not charged correctly (the sign-variable sum of the charge is not zero). The friends decided to leave only some of the rods in the machine. Sparky has q questions. In the ith question Sparky asks: if the machine consisted only of rods with numbers l_i to r_i inclusive, what minimal number of rods could be removed from the machine so that the sign-variable sum of charges on the remaining ones would be zero? Perhaps the friends got something wrong, and the sign-variable sum is already zero. In that case, you don't have to remove the rods at all.\\n\\nIf the number of rods is zero, we will assume that the sign-variable sum of charges is zero, that is, we can always remove all rods.\\n\\nHelp your friends and answer all of Sparky's questions!\\n\\nInput\\n\\nEach test contains multiple test cases.\\n\\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two positive integers n and q (1 \u2264 n, q \u2264 3 \u22c5 10^5) \u2014 the number of rods and the number of questions.\\n\\nThe second line of each test case contains a non-empty string s of length n, where the charge of the i-th rod is 1 if s_i is the \"+\" symbol, or -1 if s_i is the \"-\" symbol.\\n\\nEach next line from the next q lines contains two positive integers l_i ans r_i (1 \u2264 l_i \u2264 r_i \u2264 n) \u2014 numbers, describing Sparky's questions.\\n\\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \u22c5 10^5, and the sum of q over all test cases does not exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print a single integer \u2014 the minimal number of rods that can be removed.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n14 1\\n+--++---++-++-\\n1 14\\n14 3\\n+--++---+++---\\n1 14\\n6 12\\n3 10\\n4 10\\n+-+-\\n1 1\\n1 2\\n1 3\\n1 4\\n2 2\\n2 3\\n2 4\\n3 3\\n3 4\\n4 4\\n\\n\\nOutput\\n\\n\\n2\\n2\\n1\\n0\\n1\\n2\\n1\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n\\nNote\\n\\nIn the first test case for the first query you can remove the rods numbered 5 and 8, then the following set of rods will remain: +--+--++-++-. It is easy to see that here the sign-variable sum is zero.\\n\\nIn the second test case:\\n\\n  * For the first query, we can remove the rods numbered 1 and 11, then the following set of rods will remain: --++---++---. It is easy to see that here the sign-variable sum is zero. \\n  * For the second query we can remove the rod numbered 9, then the following set of rods will remain: ---++-. It is easy to see that here the variable sum is zero. \\n  * For the third query we can not remove the rods at all. "}
{"epoch": "10", "task_id": "84", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    t = inp()\\n    for _ in range(t):\\n        n, s = inp()\\n        ret = 0\\n        while n>1:\\n            ret += my_main()\\n            n -= 1\\n        s -= my_main()\\n        print ret\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "prompt": "You are given two positive integers n and s. Find the maximum possible median of an array of n non-negative integers (not necessarily distinct), such that the sum of its elements is equal to s.\\n\\nA median of an array of integers of length m is the number standing on the \u2308 {m/2} \u2309-th (rounding up) position in the non-decreasing ordering of its elements. Positions are numbered starting from 1. For example, a median of the array [20,40,20,50,50,30] is the \u2308 m/2 \u2309-th element of [20,20,30,40,50,50], so it is 30. There exist other definitions of the median, but in this problem we use the described definition.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single line with two integers n and s (1 \u2264 n, s \u2264 10^9) \u2014 the length of the array and the required sum of the elements.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximum possible median.\\n\\nExample\\n\\nInput\\n\\n\\n8\\n1 5\\n2 5\\n3 5\\n2 1\\n7 17\\n4 14\\n1 1000000000\\n1000000000 1\\n\\n\\nOutput\\n\\n\\n5\\n2\\n2\\n0\\n4\\n4\\n1000000000\\n0\\n\\nNote\\n\\nPossible arrays for the first three test cases (in each array the median is underlined):\\n\\n  * In the first test case [\\underline{5}] \\n  * In the second test case [\\underline{2}, 3] \\n  * In the third test case [1, \\underline{2}, 2] "}
{"epoch": "10", "task_id": "85", "completion": "\\nfor _ in range(int(input())):\\n    s = raw_input()\\n    k = s.count('1')\\n    ans = 0\\n    for i in range(len(s)):\\n        if s[i] == '0':\\n            if k > 0:\\n                ans += 1\\n                k -= 1\\n        else:\\n            if k > 0:\\n                ans += 1\\n            else:\\n                k -= 1\\n        if ans < 0:\\n            ans = 1\\n            break\\n    print ans\\n", "prompt": "A binary string is a string that consists of characters 0 and 1.\\n\\nLet \\operatorname{MEX} of a binary string be the smallest digit among 0, 1, or 2 that does not occur in the string. For example, \\operatorname{MEX} of 001011 is 2, because 0 and 1 occur in the string at least once, \\operatorname{MEX} of 1111 is 0, because 0 and 2 do not occur in the string and 0 < 2.\\n\\nA binary string s is given. You should cut it into any number of substrings such that each character is in exactly one substring. It is possible to cut the string into a single substring \u2014 the whole string.\\n\\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\\n\\nWhat is the minimal sum of \\operatorname{MEX} of all substrings pieces can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nEach test case contains a single binary string s (1 \u2264 |s| \u2264 10^5).\\n\\nIt's guaranteed that the sum of lengths of s over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal sum of \\operatorname{MEX} of all substrings that it is possible to get by cutting s optimally.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n01\\n1111\\n01100\\n101\\n0000\\n01010\\n\\n\\nOutput\\n\\n\\n1\\n0\\n2\\n1\\n1\\n2\\n\\nNote\\n\\nIn the first test case the minimal sum is \\operatorname{MEX}(0) + \\operatorname{MEX}(1) = 1 + 0 = 1.\\n\\nIn the second test case the minimal sum is \\operatorname{MEX}(1111) = 0.\\n\\nIn the third test case the minimal sum is \\operatorname{MEX}(01100) = 2."}
{"epoch": "10", "task_id": "86", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    ans=0\\n    for i in range(n):\\n        k,d=map(int,raw_input())\\n        p=map(int,raw_input())\\n        if k>n:\\n            ans=max(ans,k+d)\\n        elif d>=k:\\n            ans=max(ans,k+d)\\n            d=0\\n        else:\\n            p=map(int,raw_input().split())\\n            p=p+1\\n    print ans", "prompt": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet \\operatorname{MEX} of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, \\operatorname{MEX} for \\begin{bmatrix} 0011\\\\\\ 1010 \\end{bmatrix} is 2, because 0 and 1 occur in the bi-table at least once. \\operatorname{MEX} for \\begin{bmatrix} 111\\\\\\ 111 \\end{bmatrix} is 0, because 0 and 2 do not occur in the bi-table, and 0 < 2.\\n\\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of \\operatorname{MEX} of all resulting bi-tables can be?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length n \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of n over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the maximal sum of \\operatorname{MEX} of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\n\\n\\nOutput\\n\\n\\n8\\n8\\n2\\n12\\n\\nNote\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 10\\\\\\ 10 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 1\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 0.\\n  * \\begin{bmatrix} 0\\\\\\ 1 \\end{bmatrix}, its \\operatorname{MEX} is 2.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n  * \\begin{bmatrix} 0\\\\\\ 0 \\end{bmatrix}, its \\operatorname{MEX} is 1.\\n\\n\\n\\nThe sum of \\operatorname{MEX} is 8."}
{"epoch": "10", "task_id": "87", "completion": "import math\\nfor _ in range(int(raw_input())):\\n    n,m = map(int,raw_input().split())\\n    a = map(int,raw_input().split())\\n    a.sort()\\n    ans = 0\\n    for i in range(1,n+1):\\n        for j in range(i,m):\\n            ans += a[j]\\n    print(ans)\\n", "prompt": "It is the easy version of the problem. The only difference is that in this version n = 1.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (n = 1, 1 \u2264 m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\\n\\n\\nOutput\\n\\n\\n3\\n6\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0 + 1 + 2 = 3.\\n\\nIn the second test case, people should sit as follows: s_1 = 2, s_2 = 1, s_3 = 5, s_4 = 4, s_5 = 3. The total inconvenience will be 6."}
{"epoch": "10", "task_id": "88", "completion": "T = int(raw_input())\\n\\nfor _ in xrange(T):\\n    N, M = map(int, raw_input().split())\\n    A = map(int, raw_input().split())\\n    D = [0] * M\\n    for i in xrange(1, N):\\n        if i % 2 == 0:\\n            D[i] = i + 1\\n        else:\\n            D[i] = i + 1\\n\\n    ans = 0\\n    for i in xrange(1, N):\\n        for j in xrange(M):\\n            if D[j] < A[i]:\\n                D[j] = A[i]\\n                ans += D[j]\\n\\n    ans += len(D) - 2 * min(D)\\n    print ans", "prompt": "It is the hard version of the problem. The only difference is that in this version 1 \u2264 n \u2264 300.\\n\\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m (k - 1) + 1 to m k for all rows 1 \u2264 k \u2264 n.\\n\\n1| 2| \u22c5\u22c5\u22c5| m - 1| m  \\n---|---|---|---|---  \\nm + 1| m + 2| \u22c5\u22c5\u22c5| 2 m - 1| 2 m  \\n2m + 1| 2m + 2| \u22c5\u22c5\u22c5| 3 m - 1| 3 m  \\n\\vdots| \\vdots| \\ddots| \\vdots| \\vdots  \\nm (n - 1) + 1| m (n - 1) + 2| \u22c5\u22c5\u22c5| n m - 1| n m  \\nThe table with seats indices\\n\\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\\n\\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight a_i. Let's define s_i as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that a_i < a_j it should be satisfied that s_i < s_j.\\n\\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\\n\\nLet's consider an example: m = 5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\\n\\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers n and m (1 \u2264 n, m \u2264 300) \u2014 the number of rows and places in each row respectively.\\n\\nThe second line of each test case contains n \u22c5 m integers a_1, a_2, \u2026, a_{n \u22c5 m} (1 \u2264 a_i \u2264 10^9), where a_i is the sight level of i-th person.\\n\\nIt's guaranteed that the sum of n \u22c5 m over all test cases does not exceed 10^5.\\n\\nOutput\\n\\nFor each test case print a single integer \u2014 the minimal total inconvenience that can be achieved.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n1 2\\n1 2\\n3 2\\n1 1 2 2 3 3\\n3 3\\n3 4 4 1 1 1 1 1 2\\n2 2\\n1 1 2 1\\n4 2\\n50 50 50 50 3 50 50 50\\n4 2\\n6 6 6 6 2 2 9 6\\n2 9\\n1 3 3 3 3 3 1 1 3 1 3 1 1 3 3 1 1 3\\n\\n\\nOutput\\n\\n\\n1\\n0\\n4\\n0\\n0\\n0\\n1\\n\\nNote\\n\\nIn the first test case, there is a single way to give seats: the first person sits in the first place and the second person \u2014 in the second. The total inconvenience is 1.\\n\\nIn the second test case the optimal seating looks like this: \\n\\n<image>\\n\\nIn the third test case the optimal seating looks like this: \\n\\n<image>\\n\\nThe number in a cell is the person's index that sits on this place."}
{"epoch": "10", "task_id": "93", "completion": "t=int(raw_input())\\nfor i in range(t):\\n    a,b=map(int,raw_input().split())\\n    if b==0:\\n        print 2\\n    elif a>0:\\n        print 2\\n    else:\\n        if a<=0 and b<=0:\\n            print 3\\n        elif a==0:\\n            print 1\\n        else:\\n            print 2\\n", "prompt": "Alice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\\n\\nWhat is the shortest possible length of the array Bob wrote?\\n\\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\\n\\nOutput\\n\\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n1 1\\n2 1\\n2 0\\n1 10000\\n2 10000\\n\\n\\nOutput\\n\\n\\n3\\n2\\n3\\n2\\n3\\n\\nNote\\n\\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\\n\\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\\n\\nIt can be shown that these arrays are the shortest arrays possible."}
{"epoch": "10", "task_id": "94", "completion": "for _ in range(input()):\\n    n = input()\\n    x = n // 2\\n    print x * (x - 1) + (n % 2 == 1)", "prompt": "Alice has just learned addition. However, she hasn't learned the concept of \"carrying\" fully \u2014 instead of carrying to the next column, she carries to the column two columns to the left.\\n\\nFor example, the regular way to evaluate the sum 2039 + 2976 would be as shown: \\n\\n<image>\\n\\nHowever, Alice evaluates it as shown: \\n\\n<image>\\n\\nIn particular, this is what she does: \\n\\n  * add 9 and 6 to make 15, and carry the 1 to the column two columns to the left, i. e. to the column \"0 9\"; \\n  * add 3 and 7 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column \"2 2\"; \\n  * add 1, 0, and 9 to make 10 and carry the 1 to the column two columns to the left, i. e. to the column above the plus sign; \\n  * add 1, 2 and 2 to make 5; \\n  * add 1 to make 1. \\n\\nThus, she ends up with the incorrect result of 15005.\\n\\nAlice comes up to Bob and says that she has added two numbers to get a result of n. However, Bob knows that Alice adds in her own way. Help Bob find the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. Note that pairs (a, b) and (b, a) are considered different if a \u2260 b.\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains an integer n (2 \u2264 n \u2264 10^9) \u2014 the number Alice shows Bob.\\n\\nOutput\\n\\nFor each test case, output one integer \u2014 the number of ordered pairs of positive integers such that when Alice adds them, she will get a result of n. \\n\\nExample\\n\\nInput\\n\\n\\n5\\n100\\n12\\n8\\n2021\\n10000\\n\\n\\nOutput\\n\\n\\n9\\n4\\n7\\n44\\n99\\n\\nNote\\n\\nIn the first test case, when Alice evaluates any of the sums 1 + 9, 2 + 8, 3 + 7, 4 + 6, 5 + 5, 6 + 4, 7 + 3, 8 + 2, or 9 + 1, she will get a result of 100. The picture below shows how Alice evaluates 6 + 4: \\n\\n<image>"}
{"epoch": "10", "task_id": "95", "completion": "t = input()\\n\\nwhile(t>0):\\n\\ts,n = map(int,raw_input().split())\\n\\t\\n\\tif(n==1):\\n\\t\\tprint s\\n\\t\\tcontinue\\n\\n\\tl = list(str(s))\\n\\n\\twhile(n>0):\\n\\t\\tl.append(str(10*(n-1)) +'' * ((n-1)) + ''.join(l)\\n\\t\\tn-=1\\n\\n\\tfor i in range(n):\\n\\t\\tprint l[i],\\n\\t\\tn-=1\\n\\n\\tprint ''\\n\\tt-=1", "prompt": "On the board, Bob wrote n positive integers in [base](https://en.wikipedia.org/wiki/Positional_notation#Base_of_the_numeral_system) 10 with sum s (i. e. in decimal numeral system). Alice sees the board, but accidentally interprets the numbers on the board as base-11 integers and adds them up (in base 11).\\n\\nWhat numbers should Bob write on the board, so Alice's sum is as large as possible?\\n\\nInput\\n\\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe only line of each test case contains two integers s and n (1 \u2264 s \u2264 10^9; 1 \u2264 n \u2264 min(100, s)) \u2014 the sum and amount of numbers on the board, respectively. Numbers s and n are given in decimal notation (base 10).\\n\\nOutput\\n\\nFor each test case, output n positive integers \u2014 the numbers Bob should write on the board, so Alice's sum is as large as possible. If there are multiple answers, print any of them.\\n\\nExample\\n\\nInput\\n\\n\\n6\\n97 2\\n17 1\\n111 4\\n100 2\\n10 9\\n999999 3\\n\\n\\nOutput\\n\\n\\n70 27 \\n17 \\n3 4 100 4\\n10 90\\n1 1 2 1 1 1 1 1 1 \\n999900 90 9\\n\\nNote\\n\\nIn the first test case, 70_{10} + 27_{10} = 97_{10}, and Alice's sum is $$$70_{11} + 27_{11} = 97_{11} = 9 \u22c5 11 + 7 = 106_{10}. (Here x_b represents the number x in base b.) It can be shown that it is impossible for Alice to get a larger sum than 106_{10}$$$.\\n\\nIn the second test case, Bob can only write a single number on the board, so he must write 17.\\n\\nIn the third test case, 3_{10} + 4_{10} + 100_{10} + 4_{10} = 111_{10}, and Alice's sum is $$$3_{11} + 4_{11} + 100_{11} + 4_{11} = 110_{11} = 1 \u22c5 11^2 + 1 \u22c5 11 = 132_{10}. It can be shown that it is impossible for Alice to get a larger sum than 132_{10}$$$."}
{"epoch": "10", "task_id": "98", "completion": "import sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    s = input()\\n    a = [i for i in range(n)]\\n\\n    a1 = [0]*(n-1)\\n    for i in range(n-1):\\n        if s[i] == 'a':\\n            a1[i+1] += 1\\n\\n    #print(a1)\\n    a1 = a1[::-1]\\n    for i in range(n-1):\\n        if s[i] == 'b':\\n            if a1[i] == 0:\\n                a1[i+1] = 0\\n            else:\\n                a1[i+1] = 0\\n            a1[i+1] += 1\\n\\n    s = [i for i in a1]\\n    a1.sort()\\n    if len(a1) == 0:\\n        print(-1,-1)\\n    else:\\n        print(a1[0][0],a1[1][1])", "prompt": "You are given a string s, consisting of n letters, each letter is either 'a' or 'b'. The letters in the string are numbered from 1 to n.\\n\\ns[l; r] is a continuous substring of letters from index l to r of the string inclusive. \\n\\nA string is called balanced if the number of letters 'a' in it is equal to the number of letters 'b'. For example, strings \"baba\" and \"aabbab\" are balanced and strings \"aaab\" and \"b\" are not.\\n\\nFind any non-empty balanced substring s[l; r] of string s. Print its l and r (1 \u2264 l \u2264 r \u2264 n). If there is no such substring, then print -1 -1.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\\n\\nThen the descriptions of t testcases follow.\\n\\nThe first line of the testcase contains a single integer n (1 \u2264 n \u2264 50) \u2014 the length of the string.\\n\\nThe second line of the testcase contains a string s, consisting of n letters, each letter is either 'a' or 'b'.\\n\\nOutput\\n\\nFor each testcase print two integers. If there exists a non-empty balanced substring s[l; r], then print l r (1 \u2264 l \u2264 r \u2264 n). Otherwise, print -1 -1.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n1\\na\\n6\\nabbaba\\n6\\nabbaba\\n9\\nbabbabbaa\\n\\n\\nOutput\\n\\n\\n-1 -1\\n1 6\\n3 6\\n2 5\\n\\nNote\\n\\nIn the first testcase there are no non-empty balanced subtrings.\\n\\nIn the second and third testcases there are multiple balanced substrings, including the entire string \"abbaba\" and substring \"baba\"."}
{"epoch": "10", "task_id": "99", "completion": "for _ in range(input()):\\n    n=input()\\n    s=raw_input()\\n    l=len(s)\\n    i=0\\n    j=0\\n    for i in range(n):\\n        if s[i]=='1':\\n            l-=1\\n        else:\\n            print 'YES'\\n            j+=1\\n            print '+'*l\\n            if j>n-1:\\n                print '-'*l+-'\\n                print '+'*(l-i)\\n                j-=1\\n                break\\n        i+=1\\n    if j>=n-1:\\n        print 'NO'\\n", "prompt": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\\n\\nEach of the players has their own expectations about the tournament, they can be one of two types:\\n\\n  1. a player wants not to lose any game (i. e. finish the tournament with zero losses); \\n  2. a player wants to win at least one game. \\n\\n\\n\\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 200) \u2014 the number of test cases.\\n\\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 50) \u2014 the number of chess players.\\n\\nThe second line contains the string s (|s| = n; s_i \u2208 \\{1, 2\\}). If s_i = 1, then the i-th player has expectations of the first type, otherwise of the second type.\\n\\nOutput\\n\\nFor each test case, print the answer in the following format:\\n\\nIn the first line, print NO if it is impossible to meet the expectations of all players.\\n\\nOtherwise, print YES, and the matrix of size n \u00d7 n in the next n lines.\\n\\nThe matrix element in the i-th row and j-th column should be equal to:\\n\\n  * +, if the i-th player won in a game against the j-th player; \\n  * -, if the i-th player lost in a game against the j-th player; \\n  * =, if the i-th and j-th players' game resulted in a draw; \\n  * X, if i = j. \\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n111\\n2\\n21\\n4\\n2122\\n\\n\\nOutput\\n\\n\\nYES\\nX==\\n=X=\\n==X\\nNO\\nYES\\nX--+\\n+X++\\n+-X-\\n--+X"}
{"epoch": "10", "task_id": "100", "completion": "from __future__ import division\\nfrom sys import stdin, stdout\\nfrom collections import *\\n\\nrstr = lambda: stdin.readline().strip()\\nrstrs = lambda: [str(x) for x in stdin.readline().split()]\\nrstr_2d = lambda n: [rstr() for _ in range(n)]\\nrint = lambda: int(stdin.readline())\\nrints = lambda: [int(x) for x in stdin.readline().split()]\\nrint_2d = lambda n: [rint() for _ in range(n)]\\nrints_2d = lambda n: [rints() for _ in range(n)]\\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\\nceil1, out = lambda a, b: (a + b - 1) // b, []\\nout = []\\n\\nMOD = 998244353\\nt, = rint(), rints()\\nfor _ in range(t):\\n    n, a = rint(), rints()\\n    m = 1000000007\\n   ", "prompt": "n people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\\n\\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\\n\\nThen the discussion goes as follows:\\n\\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  *... \\n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \\n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \\n\\n\\n\\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \\n\\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\\n\\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\\n\\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n2\\n1 2\\n3\\n5 5 5\\n4\\n1 3 3 7\\n6\\n3 4 2 1 3 3\\n\\n\\nOutput\\n\\n\\n1\\n6\\n0\\n540\\n\\nNote\\n\\nExplanation of the first test case from the example:\\n\\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\\n\\n  1. the first jury member tells a task; \\n  2. the second jury member tells a task; \\n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \\n  4. the second jury member tells a task. \\n\\n\\n\\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\\n\\nFor p = [2, 1], the process is the following:\\n\\n  1. the second jury member tells a task; \\n  2. the first jury member tells a task; \\n  3. the second jury member tells a task. \\n\\n\\n\\nSo, this permutation is nice."}
{"epoch": "10", "task_id": "101", "completion": "import sys\\nrange = xrange\\ninput = raw_input\\n\\nt = int(input())\\nfor _ in range(t):\\n    n,m,k = [int(x) for x in input().split()]\\n    X = [int(x) for x in input().split()]\\n    Y = [int(y) for y in input().split()]\\n\\n    xs = sorted(X)\\n    ys = sorted(Y)\\n\\n    d1 = {}\\n    d2 = {}\\n\\n    for i in range(n):\\n        x,y = [int(x) for x in input().split()]\\n        d1[x] = d1.get(x,0) + 1\\n        d2[y] = d2.get(y,0) + 1\\n\\n    ans = 0\\n\\n    for i in range(n):\\n        if d1[i] < d2[i]:\\n            ans += 1\\n            d1[i] = d1.get(i,0) + 1\\n            d2[i] = d2.get(i,0) + 1\\n", "prompt": "There is a city that can be represented as a square grid with corner points in (0, 0) and (10^6, 10^6).\\n\\nThe city has n vertical and m horizontal streets that goes across the whole city, i. e. the i-th vertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th horizontal street goes from (0, y_j) to (10^6, y_j). \\n\\nAll streets are bidirectional. Borders of the city are streets as well.\\n\\nThere are k persons staying on the streets: the p-th person at point (x_p, y_p) (so either x_p equal to some x_i or y_p equal to some y_j, or both).\\n\\nLet's say that a pair of persons form an inconvenient pair if the shortest path from one person to another going only by streets is strictly greater than the Manhattan distance between them.\\n\\nCalculate the number of inconvenient pairs of persons (pairs (x, y) and (y, x) are the same pair).\\n\\nLet's recall that Manhattan distance between points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\\n\\nThe first line of each test case contains three integers n, m and k (2 \u2264 n, m \u2264 2 \u22c5 10^5; 2 \u2264 k \u2264 3 \u22c5 10^5) \u2014 the number of vertical and horizontal streets and the number of persons.\\n\\nThe second line of each test case contains n integers x_1, x_2,..., x_n (0 = x_1 < x_2 <... < x_{n - 1} < x_n = 10^6) \u2014 the x-coordinates of vertical streets.\\n\\nThe third line contains m integers y_1, y_2,..., y_m (0 = y_1 < y_2 <... < y_{m - 1} < y_m = 10^6) \u2014 the y-coordinates of horizontal streets.\\n\\nNext k lines contains description of people. The p-th line contains two integers x_p and y_p (0 \u2264 x_p, y_p \u2264 10^6; x_p \u2208 \\\\{x_1,..., x_n\\} or y_p \u2208 \\\\{y_1,..., y_m\\}) \u2014 the coordinates of the p-th person. All points are distinct.\\n\\nIt guaranteed that sum of n doesn't exceed 2 \u22c5 10^5, sum of m doesn't exceed 2 \u22c5 10^5 and sum of k doesn't exceed 3 \u22c5 10^5.\\n\\nOutput\\n\\nFor each test case, print the number of inconvenient pairs.\\n\\nExample\\n\\nInput\\n\\n\\n2\\n2 2 4\\n0 1000000\\n0 1000000\\n1 0\\n1000000 1\\n999999 1000000\\n0 999999\\n5 4 9\\n0 1 2 6 1000000\\n0 4 8 1000000\\n4 4\\n2 5\\n2 2\\n6 3\\n1000000 1\\n3 8\\n5 8\\n8 8\\n6 8\\n\\n\\nOutput\\n\\n\\n2\\n5\\n\\nNote\\n\\nThe second test case is pictured below: \\n\\n<image>\\n\\nFor example, points 3 and 4 form an inconvenient pair, since the shortest path between them (shown red and equal to 7) is greater than its Manhattan distance (equal to 5).\\n\\nPoints 3 and 5 also form an inconvenient pair: the shortest path equal to 1000001 (shown green) is greater than the Manhattan distance equal to 999999.\\n\\nBut points 5 and 9 don't form an inconvenient pair, since the shortest path (shown purple) is equal to its Manhattan distance."}
{"epoch": "10", "task_id": "109", "completion": "from sys import stdin, stdout\\nfrom collections import Counter, defaultdict\\nfrom itertools import permutations, combinations\\nraw_input = stdin.readline\\npr = stdout.write\\n\\n\\ndef in_arr():\\n    return map(int,raw_input().split())\\n\\n\\ndef pr_num(n):\\n    stdout.write(str(n)+'\\n')\\n\\n\\ndef pr_arr(arr):\\n    pr(' '.join(map(str,arr)))\\n\\n\\ndef pr_arr(arr):\\n    pr(' '.join(map(str,arr))+'\\n')\\n\\n# fast read function for total integer input\\n\\ndef inp():\\n    # this function returns whole input of\\n    # space/line seperated integers \\n    # Use Ctrl+D to flush stdin.\\n    return map(int,stdin.read().split())\\n\\nrange = xrange # not for python 3.0+\\n\\n# main code\\n\\nfor t in range(in_num()):\\n    n=in_arr()\\n    s=in_arr()\\n\\n    if n==1:\\n        print s\\n    else:\\n        ans=10\\n       ", "prompt": "You are given a digital clock with n digits. Each digit shows an integer from 0 to 9, so the whole clock shows an integer from 0 to 10^n-1. The clock will show leading zeroes if the number is smaller than 10^{n-1}.\\n\\nYou want the clock to show 0 with as few operations as possible. In an operation, you can do one of the following: \\n\\n  * decrease the number on the clock by 1, or \\n  * swap two digits (you can choose which digits to swap, and they don't have to be adjacent). \\n\\n\\n\\nYour task is to determine the minimum number of operations needed to make the clock show 0.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 100) \u2014 number of digits on the clock.\\n\\nThe second line of each test case contains a string of n digits s_1, s_2, \u2026, s_n (0 \u2264 s_1, s_2, \u2026, s_n \u2264 9) \u2014 the number on the clock.\\n\\nNote: If the number is smaller than 10^{n-1} the clock will show leading zeroes.\\n\\nOutput\\n\\nFor each test case, print one integer: the minimum number of operations needed to make the clock show 0.\\n\\nExample\\n\\nInput\\n\\n\\n7\\n3\\n007\\n4\\n1000\\n5\\n00000\\n3\\n103\\n4\\n2020\\n9\\n123456789\\n30\\n001678294039710047203946100020\\n\\n\\nOutput\\n\\n\\n7\\n2\\n0\\n5\\n6\\n53\\n115\\n\\nNote\\n\\nIn the first example, it's optimal to just decrease the number 7 times.\\n\\nIn the second example, we can first swap the first and last position and then decrease the number by 1.\\n\\nIn the third example, the clock already shows 0, so we don't have to perform any operations."}
{"epoch": "10", "task_id": "110", "completion": "from collections import defaultdict\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\ndef main():\\n    q = map(int, stdin.readline().split(), repeat(10, 2 * n))[::-1]\\n    for _ in xrange(q):\\n        n = int(stdin.readline())\\n        a = [map(int, stdin.readline().split(), repeat(10, 2 * n)) for _ in xrange(n)]\\n        ans = [0] * n\\n        for i in xrange(n):\\n            cur = a[i]\\n            cur[0] += 1\\n            ans[i + 1] = cur[1]\\n            if cur[0] < n:\\n                ans[0] = 1\\n            ans[1] = 1\\n            if cur[1] >= n:\\n                ans[0] = 1\\n                ans[1] = 1\\n                break\\n        print max(ans)\\nmain()\\n", "prompt": "You are given a book with n chapters.\\n\\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\\n\\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\\n\\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\\n\\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\\n\\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2},..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\\n\\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\\n\\nOutput\\n\\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\\n\\nExample\\n\\nInput\\n\\n\\n5\\n4\\n1 2\\n0\\n2 1 4\\n1 2\\n5\\n1 5\\n1 1\\n1 2\\n1 3\\n1 4\\n5\\n0\\n0\\n2 1 2\\n1 2\\n2 2 1\\n4\\n2 2 3\\n0\\n0\\n2 3 2\\n5\\n1 2\\n1 3\\n1 4\\n1 5\\n0\\n\\n\\nOutput\\n\\n\\n2\\n-1\\n1\\n2\\n5\\n\\nNote\\n\\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\\n\\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\\n\\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\\n\\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\\n\\nIn the fifth example, we will understand one chapter in every reading from 5 to 1."}
{"epoch": "10", "task_id": "111", "completion": "import sys\\nif sys.subversion[0] == \"PyPy\":\\n    import io, atexit\\n    sys.stdout = io.BytesIO()\\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\\n    \\n    sys.stdin = io.BytesIO(sys.stdin.read())\\n    input = lambda: sys.stdin.readline().rstrip()\\n \\nRS = raw_input\\nRI = lambda x=int: map(x,RS().split())\\nRN = lambda x=int: x(RS())\\n'''...................................................................... '''\\n\\nfor _ in xrange(RN()):\\n    n = RN()\\n    s = \"\"\\n    for x in xrange(n):\\n        s+='('\\n    print s\\n", "prompt": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\\n\\nYou are given an integer n. Your goal is to construct and print exactly n different regular bracket sequences of length 2n.\\n\\nInput\\n\\nThe first line contains one integer t (1 \u2264 t \u2264 50) \u2014 the number of test cases.\\n\\nEach test case consists of one line containing one integer n (1 \u2264 n \u2264 50).\\n\\nOutput\\n\\nFor each test case, print n lines, each containing a regular bracket sequence of length exactly 2n. All bracket sequences you output for a testcase should be different (though they may repeat in different test cases). If there are multiple answers, print any of them. It can be shown that it's always possible.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n3\\n1\\n3\\n\\n\\nOutput\\n\\n\\n()()()\\n((()))\\n(()())\\n()\\n((()))\\n(())()\\n()(())"}
{"epoch": "10", "task_id": "112", "completion": "t = input()\\n\\nfor _ in range(t):\\n    a, b, c, m = map(int, raw_input().split())\\n    if c * m >= a:\\n        if a == 'A':\\n            print 'NO'\\n        elif a == 'B':\\n            print 'NO'\\n        else:\\n            print 'YES'\\n    else:\\n        if c * m >= b:\\n            print 'NO'\\n        else:\\n            print 'YES'\\n\\n", "prompt": "You are given four integer values a, b, c and m.\\n\\nCheck if there exists a string that contains: \\n\\n  * a letters 'A'; \\n  * b letters 'B'; \\n  * c letters 'C'; \\n  * no other letters; \\n  * exactly m pairs of adjacent equal letters (exactly m such positions i that the i-th letter is equal to the (i+1)-th one). \\n\\nInput\\n\\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\\n\\nEach of the next t lines contains the description of the testcase \u2014 four integers a, b, c and m (1 \u2264 a, b, c \u2264 10^8; 0 \u2264 m \u2264 10^8).\\n\\nOutput\\n\\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\\n\\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\\n\\nExample\\n\\nInput\\n\\n\\n3\\n2 2 1 0\\n1 1 1 1\\n1 2 3 2\\n\\n\\nOutput\\n\\n\\nYES\\nNO\\nYES\\n\\nNote\\n\\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\\n\\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\\n\\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings."}
{"epoch": "10", "task_id": "113", "completion": "from collections import Counter\\nn = int(raw_input())\\na = map(int,raw_input().split())\\n\\nd = Counter(a)\\n\\nm = int(raw_input())\\n\\nfor i in range(m):\\n    x,y = map(int,raw_input().split())\\n    a.sort()\\n    d[i] = 0\\n    c = 0\\n    while 1:\\n        x -= d[i]\\n        if x<=0:\\n            x -= d[i]\\n            d[i] += 1\\n        else:\\n            break\\n    print c\\n    \\n", "prompt": "Recently, Petya learned about a new game \"Slay the Dragon\". As the name suggests, the player will have to fight with dragons. To defeat a dragon, you have to kill it and defend your castle. To do this, the player has a squad of n heroes, the strength of the i-th hero is equal to a_i.\\n\\nAccording to the rules of the game, exactly one hero should go kill the dragon, all the others will defend the castle. If the dragon's defense is equal to x, then you have to send a hero with a strength of at least x to kill it. If the dragon's attack power is y, then the total strength of the heroes defending the castle should be at least y.\\n\\nThe player can increase the strength of any hero by 1 for one gold coin. This operation can be done any number of times.\\n\\nThere are m dragons in the game, the i-th of them has defense equal to x_i and attack power equal to y_i. Petya was wondering what is the minimum number of coins he needs to spend to defeat the i-th dragon.\\n\\nNote that the task is solved independently for each dragon (improvements are not saved).\\n\\nInput\\n\\nThe first line contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of heroes.\\n\\nThe second line contains n integers a_1, a_2,..., a_n (1 \u2264 a_i \u2264 10^{12}), where a_i is the strength of the i-th hero.\\n\\nThe third line contains a single integer m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the number of dragons.\\n\\nThe next m lines contain two integers each, x_i and y_i (1 \u2264 x_i \u2264 10^{12}; 1 \u2264 y_i \u2264 10^{18}) \u2014 defense and attack power of the i-th dragon.\\n\\nOutput\\n\\nPrint m lines, i-th of which contains a single integer \u2014 the minimum number of coins that should be spent to defeat the i-th dragon.\\n\\nExample\\n\\nInput\\n\\n\\n4\\n3 6 2 3\\n5\\n3 12\\n7 9\\n4 14\\n1 10\\n8 7\\n\\n\\nOutput\\n\\n\\n1\\n2\\n4\\n0\\n2\\n\\nNote\\n\\nTo defeat the first dragon, you can increase the strength of the third hero by 1, then the strength of the heroes will be equal to [3, 6, 3, 3]. To kill the dragon, you can choose the first hero.\\n\\nTo defeat the second dragon, you can increase the forces of the second and third heroes by 1, then the strength of the heroes will be equal to [3, 7, 3, 3]. To kill the dragon, you can choose a second hero.\\n\\nTo defeat the third dragon, you can increase the strength of all the heroes by 1, then the strength of the heroes will be equal to [4, 7, 3, 4]. To kill the dragon, you can choose a fourth hero.\\n\\nTo defeat the fourth dragon, you don't need to improve the heroes and choose a third hero to kill the dragon.\\n\\nTo defeat the fifth dragon, you can increase the strength of the second hero by 2, then the strength of the heroes will be equal to [3, 8, 2, 3]. To kill the dragon, you can choose a second hero."}
{"epoch": "10", "task_id": "114", "completion": "from collections import Counter, defaultdict, deque\\nimport bisect\\nfrom sys import stdin, stdout\\nfrom itertools import repeat\\nimport math\\n\\n# sys.stdin = open('input')\\n\\ndef inp(force_list=False):\\n    re = map(int, raw_input().split())\\n    if len(re) == 1 and not force_list:\\n        return re[0]\\n    return re\\n\\ndef inst():\\n    return raw_input().strip()\\n\\ndef gcd(x, y):\\n   while(y):\\n       x, y = y, x % y\\n   return x\\n\\nmod = 1000000007\\n\\ndef my_main():\\n    n = inp()\\n    mem = []\\n    for _ in range(n):\\n        tem, a, b = inp()\\n        mem.append((mem[a], i))\\n    mem.sort(key=lambda x: x[1], reverse=True)\\n    m = inp()\\n    for _ in range(m):\\n        a, b = inst()\\n        mem.sort(key=lambda x: x[1])\\n        mem.sort(key=lambda", "prompt": "Ivan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} <... < a_{i,c_i}.\\n\\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2,..., b_n] is called a build.\\n\\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\\n\\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\\n\\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2},..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} <... < a_{i,c_i} \u2264 10^8).\\n\\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\\n\\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\\n\\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2,..., b_n (1 \u2264 b_i \u2264 c_i).\\n\\nThe builds are pairwise distinct, and there's at least one build that's not banned.\\n\\nOutput\\n\\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n3 2 2\\n\\n\\nOutput\\n\\n\\n2 2 3 \\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n1 2 3\\n\\n\\nInput\\n\\n\\n3\\n3 1 2 3\\n2 1 5\\n3 2 4 6\\n2\\n3 2 3\\n2 2 3\\n\\n\\nOutput\\n\\n\\n3 2 2\\n\\n\\nInput\\n\\n\\n4\\n1 10\\n1 4\\n1 7\\n1 3\\n0\\n\\n\\nOutput\\n\\n\\n1 1 1 1 "}
